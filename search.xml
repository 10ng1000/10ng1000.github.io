<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>批量任务的JS异步问题</title>
      <link href="/2024/10/15/%E6%89%B9%E9%87%8F%E4%BB%BB%E5%8A%A1%E7%9A%84JS%E5%BC%82%E6%AD%A5%E9%97%AE%E9%A2%98/"/>
      <url>/2024/10/15/%E6%89%B9%E9%87%8F%E4%BB%BB%E5%8A%A1%E7%9A%84JS%E5%BC%82%E6%AD%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>项目中遇到了这样一个情景，需要先向后端查询一个表的所有数据，然后这个表的每行数据都向后端查询这行数据的<code>id</code>是否在另一个表中存在。</p><blockquote><p>实际上为了减少网络传输的开支，这个动作应该在后端完成，但是正好借此机会学习这种情况的解决方式。</p></blockquote><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>起初我在第一个调用后的<code>then</code>范围内用<code>for</code>循环调用了若干个Promise请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">refreshList</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">loading</span> = <span class="literal">true</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">processService</span>.<span class="title function_">list</span>(&#123;</span><br><span class="line">        <span class="attr">currentPage</span>: <span class="variable language_">this</span>.<span class="property">tablePage</span>.<span class="property">currentPage</span>,</span><br><span class="line">        <span class="attr">pageSize</span>: <span class="variable language_">this</span>.<span class="property">tablePage</span>.<span class="property">pageSize</span></span><br><span class="line">      &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">records</span> = data.<span class="property">records</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">records</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">processService</span>.<span class="title function_">isFinish</span>(<span class="variable language_">this</span>.<span class="property">records</span>[i].<span class="property">id</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">records</span>[i].<span class="property">done</span> = data.<span class="property">done</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tablePage</span>.<span class="property">total</span> = <span class="variable language_">this</span>.<span class="property">records</span>.<span class="property">length</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">loading</span> = <span class="literal">false</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>但是这样做之后，前端显示的数据会先短暂闪烁，最终不显示。起初我以为是前端控件的问题，排除了很久都找不出问题的原因所在。后来才想到可能是异步程序的问题。</p><h1 id="异步问题"><a href="#异步问题" class="headerlink" title="异步问题"></a>异步问题</h1><p>首先，即使没有调用多个Promise，这个程序也存在问题。首先<code>.then</code>不会默认等待，在最外层的<code>list</code>调用链中，<code>this.records[i].done</code>的操作是需要异步请求的，这就导致了在这个操作完成前，<code>this.records</code>的值就已经读取完成并且<code>this.loading = false</code>，因此表格已经认为加载完毕，之后等待值传来时就没有完成响应式更新。</p><h1 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h1><p>之后我堆代码进行了如下更改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">async</span> <span class="title function_">refreshList</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">loading</span> = <span class="literal">true</span></span><br><span class="line">   <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">processService</span>.<span class="title function_">list</span>(&#123;</span><br><span class="line">     <span class="attr">currentPage</span>: <span class="variable language_">this</span>.<span class="property">tablePage</span>.<span class="property">currentPage</span>,</span><br><span class="line">     <span class="attr">pageSize</span>: <span class="variable language_">this</span>.<span class="property">tablePage</span>.<span class="property">pageSize</span></span><br><span class="line">   &#125;)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">records</span> = data.<span class="property">records</span></span><br><span class="line"><span class="keyword">const</span> promises = <span class="variable language_">this</span>.<span class="property">records</span>.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">processService</span>.<span class="title function_">isFinish</span>(item.<span class="property">id</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">item.<span class="property">done</span> = data;</span><br><span class="line"><span class="keyword">return</span> item;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">records</span> = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">tablePage</span>.<span class="property">total</span> = <span class="variable language_">this</span>.<span class="property">records</span>.<span class="property">length</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">loading</span> = <span class="literal">false</span></span><br><span class="line"> &#125;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>首先第一点就是我增加了<code>async/await</code>。通过<code>await</code>等待可以防止异步程序出现乱序的错误。</p><p>然后就是Array.prototype.<strong>map</strong>()可以返回一个数组，这个数组的每个元素都是原数组每个元素调用一次提供的函数的返回值后形成的。使用这个语法可以简化开发。</p><p>再者，学习到了一个新的知识点，<code>Promise.all()</code>支持对多个<code>promise</code>进行集中处理，聚合多个<code>promise</code>。这样也可以对多个<code>promise</code>进行<code>await</code>了。</p><p>这次的错误确实加深了对异步编程的印象。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 异步编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>46. 全排列</title>
      <link href="/2024/10/11/46-%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2024/10/11/46-%E5%85%A8%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/permutations/description/">46. 全排列</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>本题可以用回溯的思路来解决。对于搜索函数<code>dfs</code>，我们记录当前搜索进行到的位置，然后遍历所有可能的选项，继续调用<code>dfs</code>函数进行搜索，在搜索完毕后回溯回原来的状态，继续遍历。当搜索完全部位置时，<code>dfs</code>函数返回搜索的值。</p><h2 id="小tips"><a href="#小tips" class="headerlink" title="小tips"></a>小tips</h2><p>本题由于可以直接覆盖当前位置的选项，可以不用移除最后一个元素，同时把增加一个元素改成修改一个元素。</p><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[nums.length]);</span><br></pre></td></tr></table></figure><p>可以用n个整数初始化ArrayList，以使得set函数可用。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n×n!)$，，其中 n 为序列的长度。</li><li>空间复杂度: $O(n)$。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] vis;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; l = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; p;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        p = Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[nums.length]);</span><br><span class="line">        vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        dfs(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> [] nums, <span class="type">int</span> nowPos)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nowPos == nums.length) &#123;</span><br><span class="line">            l.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(p));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">                p.set(nowPos, nums[i]);</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">                dfs(nums, nowPos + <span class="number">1</span>);</span><br><span class="line">                vis[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>42. 接雨水</title>
      <link href="/2024/10/11/42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
      <url>/2024/10/11/42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/trapping-rain-water/description/">42. 接雨水</a>。比较朴素的做法。</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>我们用列的方式看这道题，先从左向右看，用双指针维护一个区间，这个区间满足区<strong>间右端点的高度大于等于左端点</strong>，这样这个区间内的水量可以用左端点高度乘以开区间宽度减去开区间内柱子高度求得。</p><p>但是这个求法可能无法解决最右边的区间水量。显然，从左往右看和从右往左看是一样的，我们只需要从右往左看到最后一个区间的开头，求出那一部分的水量，再加上去即可。</p><p>第二个做法为什么可行呢？因为当我们求不出最后一个区间的水量时，区间开头的高度一定是大于区间内的所有点的，这样从右往左算一定可以算出来。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$。最坏情况遍历两次数组，<code>n</code>为数组长度。</li><li>空间复杂度: $O(1)$。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; height[i] == <span class="number">0</span>) i++;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; height[i] &lt; height[start]) &#123;</span><br><span class="line">                curSum += height[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">                i = start;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = ret + (i - start - <span class="number">1</span>) * Math.min(height[start], height[i]) - curSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> j;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            j--;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; i &amp;&amp; height[j] &lt; height[start]) &#123;</span><br><span class="line">                curSum += height[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = ret + (start - j - <span class="number">1</span>) * Math.min(height[start], height[j]) - curSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12. 整数转罗马数字</title>
      <link href="/2024/10/11/12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
      <url>/2024/10/11/12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/integer-to-roman/description/">12. 整数转罗马数字</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>模拟题目所说罗马数字转换规则即可。另外，实际上不需要判断数字以哪位开头，因为每次选择选项中最大的那个时，自然会满足题目所说的转换规则。</p><p>另外，由于情况是有限的，可以给每个位的情况都列一个表，这样时间复杂度是$O(1)$。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$，<code>n</code>为<code>num</code>位数。</li><li>空间复杂度: $O(1)$。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] values = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span> , <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        String [] svalues = &#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>&#125;; </span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Integer.toString(num);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">13</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &gt;= values[i]) &#123;</span><br><span class="line">                    sb.append(svalues[i]);</span><br><span class="line">                    num -= values[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3164. 优质数对的总数 II</title>
      <link href="/2024/10/11/3164-%E4%BC%98%E8%B4%A8%E6%95%B0%E5%AF%B9%E7%9A%84%E6%80%BB%E6%95%B0-II/"/>
      <url>/2024/10/11/3164-%E4%BC%98%E8%B4%A8%E6%95%B0%E5%AF%B9%E7%9A%84%E6%80%BB%E6%95%B0-II/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/find-the-number-of-good-pairs-ii/description/">3164. 优质数对的总数 II</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>观察本题数据量，可以知道暴力模拟是会超时的，那要怎么求解呢？</p><p>首先，两个数组的长度都是$10^5$，每个数据的大小不大于$10^6$，如果我们遍历<code>nums2</code>，并在二重循环里以<code>nums2[j] * k</code>为步伐大小遍历<code>nums2[j] * k</code>，如果答案在<code>nums[1]</code>里有则记录下来（哈希查找时间复杂度$O(1)$），直到<code>nums[1]</code>的最大值为止。第二层遍历的期望时间是比遍历<code>nums1</code>要小的。</p><p>但是这样遇到一些测试用例仍然无法通过，仔细看可以发现，题目并没有说明<code>nums1</code>或<code>nums2</code>中的整数不重复，这样对于重复的整数的计算都是冗余的，我们用哈希表维护出现的次数，在找到时改成加上对应出现的次数的乘积即可。</p><blockquote><p>这些测试用例一般都是<code>nums2[j]</code>极小而<code>nums1[i]</code>极大，并且多次重复。如果没有重复，前者就会不可避免地增大，后者相应减小，这样时间复杂度是较低的。</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: $O(n+m+v&#x2F;k×logm)$，其中<code>n</code>和<code>m</code>分别是数组<code>nums1</code>和<code>nums2</code>的长度，<code>k</code>是给定的正整数，<code>v</code>是数组<code>nums1​</code>最大值，<code>logm</code>是「调和级数」求和的结果。</p></li><li><p>空间复杂度: $O(n + m)$。</p></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">numberOfPairs</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; m = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; m2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            max = max &lt; nums1[i] ? nums1[i] : max;</span><br><span class="line">            m.merge(nums1[i], <span class="number">1</span>, Integer::sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">            m2.merge(nums2[i], <span class="number">1</span>, Integer::sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; e : m2.entrySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">div</span> <span class="operator">=</span> e.getKey() * k;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> div; j &lt;= max; j += div) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m.containsKey(j)) ans += (<span class="type">long</span>)(m.get(j)) * (<span class="type">long</span>)(e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1436. 旅行终点站</title>
      <link href="/2024/10/08/1436-%E6%97%85%E8%A1%8C%E7%BB%88%E7%82%B9%E7%AB%99/"/>
      <url>/2024/10/08/1436-%E6%97%85%E8%A1%8C%E7%BB%88%E7%82%B9%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/destination-city/description/">1436. 旅行终点站</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>由于题目数据保证了一定有且仅有一个终点站，而且终点站的性质是不通往其他任意城市，我们只需要用哈希表保存所有在<code>cityB</code>出现的站，然后找出没有出现在<code>cityA</code>中的即可。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(nm)$：遍历两次数组。其中<code>n</code>是<code>paths</code>的长度，<code>m</code>是字符串的长度。</li><li>空间复杂度: $O(nm)$：哈希表。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">destCity</span><span class="params">(List&lt;List&lt;String&gt;&gt; paths)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> paths.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            s.add(paths.get(i).get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!s.contains(paths.get(i).get(<span class="number">1</span>))) <span class="keyword">return</span> paths.get(i).get(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>871. 最低加油次数</title>
      <link href="/2024/10/08/871-%E6%9C%80%E4%BD%8E%E5%8A%A0%E6%B2%B9%E6%AC%A1%E6%95%B0/"/>
      <url>/2024/10/08/871-%E6%9C%80%E4%BD%8E%E5%8A%A0%E6%B2%B9%E6%AC%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/minimum-number-of-refueling-stops/description/">871. 最低加油次数</a></p></blockquote><h1 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1.动态规划"></a>1.动态规划</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>起初看到题目的规模不大，便以为可以使用$O(n^2)$的算法来做，这是想到用动态规划的一个契机。</p><p>再就是题目是符合动态规划的条件的：</p><ol><li>题目符合无后效性，后面的加油站的选择对前面没有影响。</li><li>题目存在最优子结构，即我们可以通过构造<code>dp[i][j]</code>，其中<code>i</code>表示到达第<code>i</code>站，加了<code>j</code>次油时所剩的油，通过不断扩大<code>i</code>的规模即可求解。</li></ol><p>起初，设定<code>dp[0][0]</code>为<code>startFuel - stations[0][0]</code>，表示到达第<code>0</code>站而且未加油，如果这个值大于<code>0</code>，则可以加上<code>stations[0][1]</code>。</p><p>之后我们遍历<code>i</code>，并<strong>从大到小</strong>遍历所有小于等于<code>i</code>的<code>j</code>，判断<code>dp[i-1][j]</code>能否到达第<code>i</code>站，如果可以，而且这样剩的油更多的话，则更新<code>dp[i][j + 1]</code>。这里注意到，由于<code>dp[i]</code>之和前<code>dp[i - 1]</code>有关，我们可以省略这一维度。而我们从大到小遍历<code>j</code>，可以防止在更新过程中用<code>dp[i][j + 1]</code>的值覆盖之前<code>dp[i - 1][j + 1]</code>的值。</p><p>最后在遍历结束后，我们找出最小的所剩油量足够行驶完剩余距离的次数即可。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度: $O(n^2)$：双层for循环，<code>n</code>为数组长度。</li><li>空间复杂度: $O(n)$：动态规划所用空间。</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minRefuelStops</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> startFuel, <span class="type">int</span>[][] stations)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> stations.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target &lt;= startFuel ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//到第i站，加油j次所剩的油。</span></span><br><span class="line">        <span class="type">int</span> dp[] = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = startFuel - stations[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (dp[<span class="number">0</span>] &gt;= <span class="number">0</span>) dp[<span class="number">1</span>] = dp[<span class="number">0</span>] + stations[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[j] = dp[j] + stations[i - <span class="number">1</span>][<span class="number">0</span>] - stations[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &gt;= <span class="number">0</span>) dp[j + <span class="number">1</span>] = Math.max(dp[j + <span class="number">1</span>], dp[j] + stations[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">remain</span> <span class="operator">=</span> target - stations[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt;= remain) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-贪心"><a href="#2-贪心" class="headerlink" title="2.贪心"></a>2.贪心</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>本题实际上有更好的做法。要知道，能够使用动态规划解决的题目就<strong>有可能</strong>能用贪心解决。</p><p>想象这样一个情景，车在行驶的过程中，如果身上的油足够它走过接下来若干个加油站，那么它如果要加油次数最少，肯定要在这些加油站中选一个能加最多油的站先加上。</p><p>这样做的情况下加油次数最少是保证了，但是能否确保不会因为少加油而无法到达终点？</p><p>这是可能存在的，但是实际上由于要到达终点我们会经过所有的加油站，如果后面发现油不够了，只要还记住没有加油的站里哪个油最多，一一再加上也是可以的（反悔）。</p><p>上面我们发现，我们需要维护的是已经到达的站按油量最多排序的优先队列，再加上贪心即可解决问题。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度: $O(n)$：<code>n</code>为数组长度。</li><li>空间复杂度: $O(n)$：最大堆所用空间。</li></ul><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minRefuelStops</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> startFuel, <span class="type">int</span>[][] stations)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> stations.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target &lt;= startFuel ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b[<span class="number">1</span>] - a[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">nowFuel</span> <span class="operator">=</span> startFuel;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nowPos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (nowFuel &lt; target - nowPos) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cnt &lt; n &amp;&amp; stations[cnt][<span class="number">0</span>] &lt;= nowFuel + nowPos) &#123;</span><br><span class="line">                q.add(stations[cnt++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (q.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] add = q.poll();</span><br><span class="line">            nowFuel += add[<span class="number">1</span>] + nowPos - add[<span class="number">0</span>];</span><br><span class="line">            nowPos = add[<span class="number">0</span>];</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>134. 加油站</title>
      <link href="/2024/10/06/134-%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
      <url>/2024/10/06/134-%E5%8A%A0%E6%B2%B9%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/gas-station/description/">134. 加油站</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先能想到的直观做法是，把<code>gas</code>和<code>cost</code>相减，求出一个每到一站的油量变化，然后我们尝试从某个油量变化为正的站开始，如果能走一圈则答案为该油站，否则从下一个正油站继续尝试遍历。</p><p>这样做也能以$O(n)$的复杂度完成，但是代码相对难写，而且还需要判断是否能够走完。</p><p>进一步考虑我们可以发现，如果把所有相减值求和，求得的结果为负，那么无论怎样都不能走完，显然是返回-1。</p><p>那么对于相减值大于等于零的情况呢？</p><p>实际上这样是一定可以走完的。我们利用大于零的性质进行以下推导：</p><p>假设到<code>i</code>位，当前的总油量变为了负数，由于所有站的相减值总和大于0，我们可以知道在<code>i+1</code>到<code>n - 1</code>中间的和加上当前累计值肯定大于0，因此我们选择下一个相减值大于0的点，从这个点出发，若能走到<code>n-1</code>，则该点即为答案；否则继续寻找下一个点，而这一直保持了之后的和加上当前累计值一定大于0的性质，所以一定可以找到一个满足要求的点。</p><p>在这个过程中我们可以发现，我们只需要找到一个点，从这个点开始能走到结尾即可。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$，n为数组长度。</li><li>空间复杂度: $O(1)$。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> gas.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            total += gas[i] - cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (total &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; sum &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                sum += gas[i] - cost[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= <span class="number">0</span>) <span class="keyword">return</span> start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yarn run serve无法运行</title>
      <link href="/2024/10/06/yarn-run-serve%E5%9C%A8vscode%E4%B8%AD%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C/"/>
      <url>/2024/10/06/yarn-run-serve%E5%9C%A8vscode%E4%B8%AD%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>这几天出现了一个bug，之前vscode可以运行的前端程序，在使用<code>yarn run serve</code>之后会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yarn run v1.22.22</span><br><span class="line">$ vue-cli-service serve</span><br><span class="line">&#x27;vue-cli-service&#x27; is not recognized as an internal or external command,</span><br><span class="line">operable program or batch file.</span><br><span class="line">error Command failed with exit code 1.</span><br><span class="line">info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.</span><br></pre></td></tr></table></figure><p>后来，我根据网上的提示，尝试了删除node_modules重新安装，删除node环境重新安装，都不行。甚至npm install都出现了问题。</p><p>后来，碰巧使用系统终端（而不是vscode里的）来云心npm install，发现竟然可以了。于是我也在该终端运行yarn run serve，发现果然也可以。</p><p>于是就可以知道问题出在vscode上。我查看了vscode的权限，并使用管理员打开，以及在vscode里打开pwsh，都不能成功运行，这样暂时只能用系统终端来运行了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>135. 分发糖果</title>
      <link href="/2024/10/06/135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/"/>
      <url>/2024/10/06/135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/candy/description/">135. 分发糖果</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>本题可以采用分块处理的做法，因为我们可以观察到这样一个性质：</p><p>对于第<code>i</code>位，其之后有若干个连续位评分递减，到第<code>j</code>位为第一个不满足下一位小于<code>j</code>，那么如果第<code>j</code>位只有<code>1</code>个糖果，并且前面递增<code>1</code>个糖果，所分发的糖果是最小的。</p><p>而如果<code>i</code>大于前一位的评分，我们只需要保证<code>i</code>能比前一位多一个糖果即可。</p><p>因为题目对于相同评分的孩子的糖果数没有要求，我们就不必考虑相等的情况。</p><p>这样遍历完一次数组，我们就可以求出所有位置的糖果，把他们加起来就得到了答案。</p><h2 id="空间复杂度O-1-做法"><a href="#空间复杂度O-1-做法" class="headerlink" title="空间复杂度O(1)做法"></a>空间复杂度O(1)做法</h2><p>我们可以发现上述过程并不需要保存所有位置的糖果数，如果是递减的情况，我们就可以直接求出需要加上的糖果数；如果是递增的情况，我们只需要记录上一次的糖果数，看情况是否需要增加糖果即可。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$：n为数组长度</li><li>空间复杂度: $O(n)$或$O(1)$。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ratings.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">int</span> values[] = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n - <span class="number">1</span> &amp;&amp; ratings[i + <span class="number">1</span>] &lt; ratings[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= start; j--) &#123;</span><br><span class="line">                values[j] = i - j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (start &gt; <span class="number">0</span> &amp;&amp; ratings[start - <span class="number">1</span>] &lt; ratings[start]) &#123;</span><br><span class="line">                values[start] = Math.max(values[start], values[start - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            total += values[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ratings.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n - <span class="number">1</span> &amp;&amp; ratings[i + <span class="number">1</span>] &lt; ratings[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= start; j--) &#123;</span><br><span class="line">                total += i - j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (start &gt; <span class="number">0</span> &amp;&amp; ratings[start - <span class="number">1</span>] &lt; ratings[start]) &#123;</span><br><span class="line">                total += Math.max(<span class="number">0</span>, pre + <span class="number">1</span> - i + start);</span><br><span class="line">                <span class="keyword">if</span> (i == start) pre++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    pre = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1227. 飞机座位分配概率</title>
      <link href="/2024/10/04/%E3%80%90%E6%95%B0%E5%AD%A6%E3%80%911227-%E9%A3%9E%E6%9C%BA%E5%BA%A7%E4%BD%8D%E5%88%86%E9%85%8D%E6%A6%82%E7%8E%87/"/>
      <url>/2024/10/04/%E3%80%90%E6%95%B0%E5%AD%A6%E3%80%911227-%E9%A3%9E%E6%9C%BA%E5%BA%A7%E4%BD%8D%E5%88%86%E9%85%8D%E6%A6%82%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/airplane-seat-assignment-probability/description/">1227. 飞机座位分配概率</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>由于这道题后面人的选择对前面人的选择没有影响，而且题目中隐约可以看出存在利用更小规模的最优子结构来求解的可能，这道题可以尝试用动态规划的思路来求解，设<code>f(n)</code>为截止到第<code>n</code>个人时，第<code>n</code>个人坐到自己位置的概率。</p><p>这样，当<code>n&gt;=3</code>时，就可以根据第一个人坐的情况分为三种情况：</p><ol><li>坐到自己的位置，$\frac 1n$的概率，此时<code>n</code>坐到自己位置的概率为<code>1</code>。</li><li>坐到n的位置，$\frac 1n$的概率，此时<code>n</code>坐到自己位置的概率为<code>0</code>。</li><li>坐到其他的位置，每个位置$\frac 1n$的概率，设该位置为<code>i</code>，则<code>1</code>之后、<code>i</code>之前的位置一定是正确的，<code>1</code>和<code>i</code>之后一共有<code>n - i + 1</code>个位置，同时还有同样多的人没有入场，而且第<code>i</code>号面临和1一样的情况，即他也要随机坐一个位置，并且他不是最后一个人，因此转换为规模为<code>n - i + 1</code>的子问题。</li></ol><p>这样，就可以得出递推式，将<code>n-1</code>带入递推式，再将两式相减即可求出解。</p><blockquote><p>详见<a href="https://leetcode.cn/problems/airplane-seat-assignment-probability/solutions/664495/fei-ji-zuo-wei-fen-pei-gai-lu-by-leetcod-gyw4/">官解</a>。</p></blockquote><h1 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h1><p>当时觉得动态规划难解，没有想出正确的最优子结构，就开始选择尝试模拟所有情况来暴力求解，但是这样时间复杂度非常高（阶乘）。在做题的时候一定不能蛮做，首先要排除时间复杂度不够的做法，如果全是不够的话需要看是否没有找出其中的数学关系。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(1)$</li><li>空间复杂度: $O(1)$</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">nthPersonGetsNthSeat</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3306. 元音辅音字符串计数 II</title>
      <link href="/2024/10/02/%E3%80%90%E6%81%B0%E5%A5%BD%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%913306-%E5%85%83%E9%9F%B3%E8%BE%85%E9%9F%B3%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%A1%E6%95%B0-II/"/>
      <url>/2024/10/02/%E3%80%90%E6%81%B0%E5%A5%BD%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%913306-%E5%85%83%E9%9F%B3%E8%BE%85%E9%9F%B3%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%A1%E6%95%B0-II/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/count-of-substrings-containing-every-vowel-and-k-consonants-ii/description/">3306. 元音辅音字符串计数 II</a><br>周赛时没做出来，思路见<a href="https://leetcode.cn/problems/count-of-substrings-containing-every-vowel-and-k-consonants-ii/solutions/2934309/liang-ci-hua-chuang-pythonjavacgo-by-end-2lpz/">灵茶山艾府</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这题初做没有做出来，因为没有理解双指针滑动窗口的特点：需要保证维护的子串满足一定的单调性，即长度变长，只可能更满足或者保持现状；变短反之。但是，如果任务是<code>恰好型</code>，并不能说越长越容易恰好，可能情况会变坏，所以是不能直接用双指针来做的。</p><p>但是，我们可以把问题进行转换，至少有五个元音字母的条件不变，<strong>恰好</strong>包含 k 个辅音字母的条件，可以转为以下两个<strong>至少型</strong>任务：</p><ol><li>每个元音字母至少出现一次，并且至少包含<code>k</code>个辅音字母的子串个数。</li><li>每个元音字母至少出现一次，并且至少包含<code>k+1</code>个辅音字母的子串个数。</li></ol><p>这样，只需要两个任务的答案相减，就可以求出恰好k个的答案。</p><h1 id="Java解题技巧"><a href="#Java解题技巧" class="headerlink" title="Java解题技巧"></a>Java解题技巧</h1><p>HashMap使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m.merge(key, <span class="number">1</span>, Integer::sum);</span><br><span class="line">m.merge(key, -<span class="number">1</span>, Integer::sum)</span><br></pre></td></tr></table></figure><p>可以不用判空地进行Map的值增减操作。</p><p>另外，要判断是否为元音，可以使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;aeiou&quot;</span>.indexOf(out) &gt;= <span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$，双指针两次遍历一遍数组。</li><li>空间复杂度: $O(1)$。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countOfSubstrings</span><span class="params">(String word, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = word.toCharArray();</span><br><span class="line">        <span class="keyword">return</span> f(s, k) - f(s, k + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">f</span><span class="params">(<span class="type">char</span>[] word, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 这里用哈希表实现，替换成数组会更快</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; cnt1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">// 每种元音的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt2</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 辅音个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> b : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;aeiou&quot;</span>.indexOf(b) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                cnt1.merge(b, <span class="number">1</span>, Integer::sum); <span class="comment">// ++cnt1[b]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cnt1.size() == <span class="number">5</span> &amp;&amp; cnt2 &gt;= k) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">out</span> <span class="operator">=</span> word[left];</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;aeiou&quot;</span>.indexOf(out) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cnt1.merge(out, -<span class="number">1</span>, Integer::sum) == <span class="number">0</span>) &#123; <span class="comment">// --cnt1[out] == 0</span></span><br><span class="line">                        cnt1.remove(out);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cnt2--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1870. 准时到达的列车最小时速</title>
      <link href="/2024/10/02/1870-%E5%87%86%E6%97%B6%E5%88%B0%E8%BE%BE%E7%9A%84%E5%88%97%E8%BD%A6%E6%9C%80%E5%B0%8F%E6%97%B6%E9%80%9F/"/>
      <url>/2024/10/02/1870-%E5%87%86%E6%97%B6%E5%88%B0%E8%BE%BE%E7%9A%84%E5%88%97%E8%BD%A6%E6%9C%80%E5%B0%8F%E6%97%B6%E9%80%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/minimum-speed-to-arrive-on-time/description/">1870. 准时到达的列车最小时速</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题目中，速度越大越能在要求的时间内到达，而我们要求最小时间，很自然地就联想到二分答案。</p><p>但是有一些小细节需要注意，例如，答案的右边界是<code>max(dist)</code>，因为<code>hour</code>是最大小数位为二位的小数，因此最小可能需要的时间是需要除以<code>0.01</code>的。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(nlogU)$，<code>U</code>为<code>max(dist)</code></li><li>空间复杂度: $O(1)$</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSpeedOnTime</span><span class="params">(<span class="type">int</span>[] dist, <span class="type">double</span> hour)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> dist.length;</span><br><span class="line">        <span class="keyword">if</span> (hour &lt;= n - <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[i] &gt; max) max = dist[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> max * <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">now</span> <span class="operator">=</span> cal(m, dist, hour);</span><br><span class="line">            <span class="keyword">if</span> (now &lt; hour) &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (now &gt; hour) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> speed, <span class="type">int</span> [] dist, <span class="type">double</span> hour)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> dist.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            now += Math.ceil(dist[i] / (<span class="type">double</span>) speed);</span><br><span class="line">        &#125;</span><br><span class="line">        now += dist[n - <span class="number">1</span>] / (<span class="type">double</span>) speed;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>做力扣的思考</title>
      <link href="/2024/09/30/%E5%81%9A%E5%8A%9B%E6%89%A3%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2024/09/30/%E5%81%9A%E5%8A%9B%E6%89%A3%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>到目前为止，做的题目大多是中等题，从没做出的题的经验中，略微感觉有些思路可循。</p><p>在我看来，要做出一道题目需要想到以下几点：</p><ol><li>读题目，观察是否符合某一数据结构或者算法模式。</li><li>如果第一步想到的方法效率不高或者找不到直接对应的模式，思考题目是否隐含了什么可推导出的条件。</li><li>尝试将题目的说法进行等价转换，以符合算法或者数据结构的模式。</li><li>尝试使用逆向思维、转换做法等方式，以优化。</li></ol><p>然后，对于算法和数据机构的掌握就是核心的基础了，需要多多做题磨练。也希望在练习的途中，能发现更多解题的新思路。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1845. 座位预约管理系统</title>
      <link href="/2024/09/30/1845-%E5%BA%A7%E4%BD%8D%E9%A2%84%E7%BA%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/09/30/1845-%E5%BA%A7%E4%BD%8D%E9%A2%84%E7%BA%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/seat-reservation-manager/description/">1845. 座位预约管理系统</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先想到的是使用最小堆来模拟，因为题目的<code>reserve</code>返回的是最小可预约座位，并把座位变为不可预约。如果用最小堆来维护<strong>可预约座位</strong>，那么<code>reserve</code>操作就是出堆操作；<code>unreserve</code>就是入堆操作。出入堆操作时间复杂度为$O(logn)$。</p><p>但是如果<code>n</code>太大，初始化操作就会消耗太多的时间。我们可以用逆向思维：如果我们维护<strong>曾经被预约过，又被释放的座位</strong>，就不需要初始化操作。当执行预约操作时，如果堆里有座位，就将执行出堆操作。否则返回<code>已被预约的座位数+1</code>；当执行取消预约时，将该座位入堆。</p><blockquote><p>优化的方法参考<a href="https://leetcode.cn/problems/seat-reservation-manager/solutions/2838121/liang-chong-fang-fa-wei-hu-ke-yu-yue-de-tmub8/">灵茶山艾府</a></p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: 初始化$O(1)$,<code>reserve</code>和<code>unreserve</code>为$O(log q)$，<code>q</code>为<code>reserve</code>的调用次数。</li><li>空间复杂度: $O(q)$。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeatManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;Integer&gt; available = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> seats;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SeatManager</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reserve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!available.isEmpty()) &#123; <span class="comment">// 有空出来的椅子</span></span><br><span class="line">            <span class="keyword">return</span> available.poll(); <span class="comment">// 坐编号最小的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ++seats; <span class="comment">// 添加一把新的椅子</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unreserve</span><span class="params">(<span class="type">int</span> seatNumber)</span> &#123;</span><br><span class="line">        available.add(seatNumber); <span class="comment">// 有人离开了椅子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>238. 除自身以外数组的乘积</title>
      <link href="/2024/09/29/238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/"/>
      <url>/2024/09/29/238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/product-of-array-except-self/description/">238. 除自身以外数组的乘积</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>在不能使用除法的情况下，考虑每个答案的组成方式：第<code>i</code>位的结果为其前缀乘积和后缀乘积之积。离线求解前后缀乘积时间复杂度为$O(n)$，符合题目要求。</p><p>题目中给了个提示，可以在$O(1)$（不考虑返回数组）的情况下完成。但是完全不存储前后缀是没法在$O(n)$的复杂度下完成的，应该想到可以暂时把数据存在返回数组里。</p><p>这样，我们只需先计算一遍后缀积，然后在计算结果时，保留当前前缀和即可。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$：遍历两次数组。</li><li>空间复杂度: $O(1)$：实际上是$O(n)$，如题目所说不考虑返回数组空间时$O(1)$。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> r[] = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        r[n - <span class="number">1</span>] = nums[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            r[i] = r[i + <span class="number">1</span>] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        r[<span class="number">0</span>] = r[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            r[i] = pre * r[i + <span class="number">1</span>];</span><br><span class="line">            pre *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        r[n - <span class="number">1</span>] = pre;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2073. 买票需要的时间</title>
      <link href="/2024/09/29/2073-%E4%B9%B0%E7%A5%A8%E9%9C%80%E8%A6%81%E7%9A%84%E6%97%B6%E9%97%B4/"/>
      <url>/2024/09/29/2073-%E4%B9%B0%E7%A5%A8%E9%9C%80%E8%A6%81%E7%9A%84%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/time-needed-to-buy-tickets/description/">2073. 买票需要的时间</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>先分两段来考虑：</p><ol><li>刚开始第k个人及之前的人买票，需要<code>k + 1</code>的时间，并且这些人需要的票减一。</li><li>接下来每轮，前方的人若是需要买的票少于第二段开始<code>k</code>的票，则他们一定会买完自己的票；反之，则购买第二段开始<code>k</code>的票数的票。</li></ol><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$：一次遍历数组。</li><li>空间复杂度: $O(n)$：若干变量。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">timeRequiredToBuy</span><span class="params">(<span class="type">int</span>[] tickets, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> k + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tickets.length;</span><br><span class="line">        tickets[k]--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; k) &#123;</span><br><span class="line">                tickets[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tickets[i] &gt; tickets[k]) &#123;</span><br><span class="line">                ret += tickets[k];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ret += tickets[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>380. O(1) 时间插入、删除和获取随机元素</title>
      <link href="/2024/09/28/380-O(1)%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/"/>
      <url>/2024/09/28/380-O(1)%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/insert-delete-getrandom-o1/description/">380. O(1) 时间插入、删除和获取随机元素</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>哈希表可以完成$O(1)$的插入和删除，但是无法用下标获得元素。考虑到<strong>变长数组</strong>可以在$O(1)$的时间完成获取元素，我们只需要再维护一个变长数组即可。用哈希表维护元素即它们在变长数组的位置。在添加元素时，把元素添加到变长数组的末端；在删除元素时，更新数组末端元素在哈下表的位置，用末端元素替换数组被删除元素。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(1)$，哈希表插入删除时间都是$O(1)$，删除数组最后一个元素也是$O(1)$。</li><li>空间复杂度: $O(n)$，哈希表和数组。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; s;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; a;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RandomizedSet</span><span class="params">()</span> &#123;</span><br><span class="line">        s = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        random = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.containsKey(val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        s.put(val, count);</span><br><span class="line">        a.add(val);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!s.containsKey(val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        count--;</span><br><span class="line">        s.put(a.get(count), s.get(val));</span><br><span class="line">        a.set(s.get(val), a.get(count));</span><br><span class="line">        a.remove(count);</span><br><span class="line">        s.remove(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.get(random.nextInt(count));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>274. H指数</title>
      <link href="/2024/09/28/274-H%20%E6%8C%87%E6%95%B0/"/>
      <url>/2024/09/28/274-H%20%E6%8C%87%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/h-index/description/">274. H 指数</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>看到题目中有<code>至少h篇大于等于h</code>这样的比大小字样，可以想到排序数组，这样可以使数组具有单调性。</p><p>将数组<strong>从大到小</strong>排序，用指针<code>i</code>遍历数组，如果有第<code>i</code>大的引用小于<code>i + 1</code>（个数），那么显然就不存在<code>i + 1</code>个大于等于<code>i + 1</code>的文章（之后的文章都比它小），这样所求的<code>i</code>就是H指数。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(nlogn)$，排序的时间消耗，在本题里数据范围较小，如果使用计数排序可以降到$O(n+k)$</li><li>空间复杂度: $O(1)$，只需若干常量。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] citations)</span> &#123;</span><br><span class="line">        Arrays.sort(citations);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> citations.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (citations[i] &lt; n - i) &#123;</span><br><span class="line">                <span class="keyword">return</span> n - i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2516. 每种字符至少取 K 个</title>
      <link href="/2024/09/27/2516-%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E8%87%B3%E5%B0%91%E5%8F%96K%E4%B8%AA/"/>
      <url>/2024/09/27/2516-%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E8%87%B3%E5%B0%91%E5%8F%96K%E4%B8%AA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/description/">2516. 每种字符至少取 K 个</a></p></blockquote><h1 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h1><p>看到从两边求解，我首先想到的是，先尝试贪心试试？每次如果某个字符未达到上限就取，在两边都没有时，哪边离得最近就取：但这样显然是不正确的。</p><p>接下来想到的是记忆化搜索或者说动态规划。但是这题又不大满足<strong>无后效性</strong>这一特点，前面的操作对于后面子字符串是有影响的。</p><p>于是我尝试了暴力搜索，但是效率太低，最后超时了。</p><h1 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h1><p>很多题目都不能直接从他本身的描述直接开始做，需要发掘其中的隐藏要点。本题中由于从两边考虑多种方法都难以求解，归根结底原因很大程度就是两边求解是不连续的，那么反过来想，中间的字符串不就是连续的吗？</p><p>而只要字符串是连续的，我们就可以自然而然想到双指针滑动窗口的解决方法。对于所给问题，实际上可以首先转为求解<strong>余下符合条件的最长中间子字符串</strong>，本质上也是对于每个要求的字符，要找出正好符合一定数量的字串。这样考虑双指针就很容易了，我们维护<code>i</code>到<code>j</code>为除去两端的中间子串，每次若<code>j</code>位置字符没有达到所需数量就自增<code>j</code>，否则自增<code>i</code>的位置，以减少<code>j</code>位置字符的计数，同时维护最长的中间字串长度，这样即可求解。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$，遍历两次数组。</li><li>空间复杂度: $O(1)$，若干常量，和常量大小map。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">takeCharacters</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span> [] cs = s.toCharArray();</span><br><span class="line">        Map&lt;Character, Integer&gt; m = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        m.put(<span class="string">&#x27;a&#x27;</span>, -k);</span><br><span class="line">        m.put(<span class="string">&#x27;b&#x27;</span>, -k);</span><br><span class="line">        m.put(<span class="string">&#x27;c&#x27;</span>, -k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            m.put(cs[i], m.get(cs[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer value : m.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            m.put(cs[j], m.get(cs[j]) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; m.get(cs[j]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                m.put(cs[i], m.get(cs[i]) + <span class="number">1</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            count = Math.max(count, j - i + <span class="number">1</span>);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>45. 跳跃游戏 II</title>
      <link href="/2024/09/21/45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II/"/>
      <url>/2024/09/21/45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/jump-game/description/">55. 跳跃游戏</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>和55-跳跃游戏一样，我们在不断往前跳的过程中，可跳到的范围会越来越大。本题要求解的是跳到最后的最短次数，可以想到使用贪心的思想：对于<code>i</code>之后可以跳到的所有点，我们选择跳到<strong>能够到达范围最远</strong>的点，显然这样的跳跃（相对于本次选择的其他点）对于减少步数是最优的。不断遍历这个过程，直到能够到达最后点即可。</p><p>这样，我们只需要遍历一遍数组就能找到最少的跳跃次数。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$：最多遍历一遍数组。</li><li>空间复杂度: $O(1)$：若干常量。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">now</span> <span class="operator">=</span> right;</span><br><span class="line">            <span class="keyword">if</span> (now &gt;= n - <span class="number">1</span>) <span class="keyword">return</span> ret;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= now) &#123;</span><br><span class="line">                right = Math.max(right, i + nums[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2376. 统计特殊整数</title>
      <link href="/2024/09/20/%E3%80%90%E6%95%B0%E4%BD%8Ddp%E3%80%912376-%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%AE%8A%E6%95%B4%E6%95%B0/"/>
      <url>/2024/09/20/%E3%80%90%E6%95%B0%E4%BD%8Ddp%E3%80%912376-%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%AE%8A%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/count-special-integers/description/">2376. 统计特殊整数</a><br>记录新学到的知识点，思路见<a href="https://leetcode.cn/problems/count-special-integers/solutions/1746956/shu-wei-dp-mo-ban-by-endlesscheng-xtgx/">灵茶山艾府</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="位运算和集合论"><a href="#位运算和集合论" class="headerlink" title="位运算和集合论"></a>位运算和集合论</h2><p>通过将位运算和集合论结合，可以用来表示<strong>数位状态</strong>，用来作为数位dp的一部分使用。</p><p>具体方法是，对于从右到左第<code>i</code>位数，如果为1就代表<code>i</code>这个数在集合中。对于要枚举的范围不大（例如数位D，范围为0-9）的数来说，可以很方便地用一个整数来存储数位的访问状态。</p><p>取出第<code>i</code>位数和加入第<code>i</code>位数都是$O(D)$的时间复杂度。设集合为x，则取出放入操作可以用位运算求解：</p><ol><li>取出：<code>x &gt;&gt; i &amp; 1</code></li><li>放入：<code>1 &lt;&lt; i | x</code></li></ol><h2 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h2><p>通过记忆化搜索来找出所有可能的状态，这样可以把需要遍历的情况压缩到状态数乘以单个状态计算时间的大小，状态数在本体中为位数（很小）乘以$O(2^D)$，后者是集合可能有的所有情况。同时单个状态的计算时间通常是很小的。这样就大大减小了计算的量，可以高效地找出所有符合条件的情况。</p><h2 id="对于数位问题的技巧"><a href="#对于数位问题的技巧" class="headerlink" title="对于数位问题的技巧"></a>对于数位问题的技巧</h2><h3 id="1-对于不能超过最大数n的解决方式"><a href="#1-对于不能超过最大数n的解决方式" class="headerlink" title="1.对于不能超过最大数n的解决方式"></a>1.对于不能超过最大数<code>n</code>的解决方式</h3><p>设置一个<code>isLimit</code>标志，表示当前位置是否受到约束，即如果超过<code>s[i]</code>则非法。若<code>isLimit</code>为true，则当前可以遍历的数就存在一个上限<code>s[i]</code>，否则为9。在记忆化搜索的过程中维护和更新这个标志。</p><h3 id="2-对于前置不能存在0，又可能为空的解决方式"><a href="#2-对于前置不能存在0，又可能为空的解决方式" class="headerlink" title="2.对于前置不能存在0，又可能为空的解决方式"></a>2.对于前置不能存在0，又可能为空的解决方式</h3><p>设置一个<code>isNum</code>标志，表示前一位是否有填数字。如果前一位空，则这一位可以空（直接遍历下一位），也可以填1-9；如果前一位不空，则这一位只能填0-9。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(mD2^D)$。其中<code>m</code>为<code>s</code>的长度，<code>D</code>为10。</li><li>空间复杂度: $O(m2^D)$。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSpecialNumbers</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = Integer.toString(n).toCharArray();</span><br><span class="line">        <span class="type">int</span>[][] memo = <span class="keyword">new</span> <span class="title class_">int</span>[s.length][<span class="number">1</span> &lt;&lt; <span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : memo) &#123;</span><br><span class="line">            Arrays.fill(row, -<span class="number">1</span>); <span class="comment">// -1 表示没有计算过</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span>, s, memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> mask, <span class="type">boolean</span> isLimit, <span class="type">boolean</span> isNum, <span class="type">char</span>[] s, <span class="type">int</span>[][] memo)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == s.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> isNum ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// isNum 为 true 表示得到了一个合法数字</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isLimit &amp;&amp; isNum &amp;&amp; memo[i][mask] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][mask]; <span class="comment">// 之前计算过</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!isNum) &#123; <span class="comment">// 可以跳过当前数位</span></span><br><span class="line">            res = dfs(i + <span class="number">1</span>, mask, <span class="literal">false</span>, <span class="literal">false</span>, s, memo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果前面填的数字都和 n 的一样，那么这一位至多填数字 s[i]（否则就超过 n 啦）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> isLimit ? s[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>;</span><br><span class="line">        <span class="comment">// 枚举要填入的数字 d</span></span><br><span class="line">        <span class="comment">// 如果前面没有填数字，则必须从 1 开始（因为不能有前导零）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> isNum ? <span class="number">0</span> : <span class="number">1</span>; d &lt;= up; d++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mask &gt;&gt; d &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123; <span class="comment">// d 不在 mask 中，说明之前没有填过 d</span></span><br><span class="line">                res += dfs(i + <span class="number">1</span>, mask | (<span class="number">1</span> &lt;&lt; d), isLimit &amp;&amp; d == up, <span class="literal">true</span>, s, memo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isLimit &amp;&amp; isNum) &#123;</span><br><span class="line">            memo[i][mask] = res; <span class="comment">// 记忆化</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring和MybatisPlus踩坑</title>
      <link href="/2024/09/16/Spring%E5%92%8CMybatisPlus%E8%B8%A9%E5%9D%91/"/>
      <url>/2024/09/16/Spring%E5%92%8CMybatisPlus%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1 id="发现build后还有原来的代码"><a href="#发现build后还有原来的代码" class="headerlink" title="发现build后还有原来的代码"></a>发现build后还有原来的代码</h1><p>build只会加缓存，不会减缓存，因此如果删除文件，需要rebuild。</p><h1 id="Bean冲突"><a href="#Bean冲突" class="headerlink" title="Bean冲突"></a>Bean冲突</h1><p>遇到了processBean冲突，排查后发现是框架文件里有这个名称的bean，因此换个名称就可以解决。不要把名称设的太宽泛。</p><h1 id="MybatisPlus学习"><a href="#MybatisPlus学习" class="headerlink" title="MybatisPlus学习"></a>MybatisPlus学习</h1><p>过于细化的框架损失自由度，并且会引起很多难以解决的bug，只有在组里有前人对框架非常熟悉，且框架经过检验时，使用框架才好。</p><p>所以采用适用性相对较广的MybatisPlus。</p><p>后端设置UUID：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableId(type = IdType.ASSIGN_UUID)</span>  </span><br><span class="line"><span class="keyword">private</span> String id;</span><br></pre></td></tr></table></figure><p>后端分页：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ProcessingMapper.java</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM &quot; + TABLE_NAME)</span>  </span><br><span class="line">IPage&lt;Processing&gt; <span class="title function_">selectPageVo</span><span class="params">(IPage&lt;?&gt; page)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ProcessingService.java</span></span><br><span class="line"><span class="keyword">public</span> IPage&lt;Processing&gt; <span class="title function_">getProcessingPage</span><span class="params">(<span class="type">int</span> currentPage, <span class="type">int</span> pageSize)</span>&#123;  </span><br><span class="line">    Page&lt;Processing&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(currentPage, pageSize);  </span><br><span class="line">    <span class="keyword">return</span> processingMapper.selectPageVo(page);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Post的时候后端一直报错"><a href="#Post的时候后端一直报错" class="headerlink" title="Post的时候后端一直报错"></a>Post的时候后端一直报错</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误: nested exception is org.apache.ibatis.reflection.ReflectionException: There is no getter <span class="keyword">for</span> property named <span class="string">&#x27;rawData&#x27;</span> in <span class="string">&#x27;class com.jeeplus.processmanage.domain.Processing&#x27;</span></span><br></pre></td></tr></table></figure><p>一直在前端找，都没找到哪里有rawData这个东西，后来发现是后端的<code>Mapper</code>当时复制了另一个文件，里面有insert这个东西，自己没有注意到。所以，出现莫名其妙的错误时，<strong>要回想一下自己所没有注意到，特别是复制黏贴的事物</strong>。<del>复制黏贴还是少用为好。</del></p><h2 id="报SQL语句错误"><a href="#报SQL语句错误" class="headerlink" title="报SQL语句错误"></a>报SQL语句错误</h2><p>procedure是一个保留关键字，不能作为列名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误: ### Error updating database. Cause: java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version <span class="keyword">for</span> the right syntax to use near <span class="string">&#x27;procedure, equipment_used, operator_info, material_id ) VALUES ( &#x27;</span><span class="number">183558877960</span><span class="string">&#x27; at line 4 ### The error may exist in com/jeeplus/processmanage/mapper/ProcessingMapper.java (best guess) ### The error may involve com.jeeplus.processmanage.mapper.ProcessingMapper.insert-Inline ### The error occurred while setting parameters ### SQL: INSERT INTO process_process ( id, technique, procedure, equipment_used, operator_info, material_id ) VALUES ( ?, ?, ?, ?, ?, ? ) ### Cause: java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;</span>procedure, equipment_used, operator_info, material_id ) VALUES ( <span class="string">&#x27;183558877960&#x27;</span> at line <span class="number">4</span> ; bad SQL grammar []; nested exception is java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version <span class="keyword">for</span> the right syntax to use near <span class="string">&#x27;procedure, equipment_used, operator_info, material_id ) VALUES ( &#x27;</span><span class="number">183558877960</span><span class="string">&#x27; at line 4</span></span><br></pre></td></tr></table></figure><blockquote><p>在 SQL 语言中，<code>PROCEDURE</code> 是一个保留字，用于定义存储过程。存储过程是一组为了完成特定功能的 SQL 语句集合，它可以在数据库中被保存和重用。</p></blockquote><p>可见sql和spring是要注意命名错误的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2390. 从字符串中移除星号</title>
      <link href="/2024/09/14/%E3%80%90%E6%A0%88%E3%80%912390-%E4%BB%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%A7%BB%E9%99%A4%E6%98%9F%E5%8F%B7/"/>
      <url>/2024/09/14/%E3%80%90%E6%A0%88%E3%80%912390-%E4%BB%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%A7%BB%E9%99%A4%E6%98%9F%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/removing-stars-from-a-string/description/">2390. 从字符串中移除星号</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>想到用栈维护，思路就很清晰了。</p><p>要想到使用栈，重点是注意到每次都是对<strong>最后一个元素</strong>进行操作的，正好符合栈的性质。</p><blockquote><p>这题我错误地想使用双指针的做法来做，结果写法挺复杂不说，还TLE了。。。这就是没有抓住关键性质的后果。</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$</li><li>空间复杂度: $O(n)$</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeStars</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                st.deleteCharAt(st.length() - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2576.求出最多标记的下标</title>
      <link href="/2024/09/13/%E3%80%90%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%E3%80%912576-%E6%B1%82%E5%87%BA%E6%9C%80%E5%A4%9A%E6%A0%87%E8%AE%B0%E4%B8%8B%E6%A0%87/"/>
      <url>/2024/09/13/%E3%80%90%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%E3%80%912576-%E6%B1%82%E5%87%BA%E6%9C%80%E5%A4%9A%E6%A0%87%E8%AE%B0%E4%B8%8B%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/description/">2576. 求出最多标记下标</a>&gt;<br>思考贪心方向错误，记录对于<a href="https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/solutions/2134078/er-fen-da-an-pythonjavacgo-by-endlessche-t9f5">灵茶山艾府解答</a>的理解。</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>首先还是思考题目中可能存在的隐藏性质，来把题目转为可计算机求解的另一种表达方式。可以发现，<strong>如果数组有k个匹配对，那么前k个元素和最后k个元素一定能一一匹配上</strong>。这一点其实用反证法很好想，<code>i</code>从<code>0</code>开始自增到<code>k</code>，如果第<code>i</code>个元素的两倍小于第<code>n-k+i</code>个元素，那么就只能往第<code>n-k+1</code>个以后去找，但是这样就没有k个配对了。</p><p>接下来就是如何利用这个性质。</p><p>我们可以利用<strong>k个匹配对</strong>这个关键点，尝试不同的<strong>最大匹配数k</strong>。为了尽可能少的遍历<code>k</code>值，自然想到二分答案的做法。显然<code>k</code>越大的情况下，<strong>可以匹配的对数</strong>越多，符合二分搜索的条件。二分搜索<code>k</code>，然后验证前述性质，如果满足就尝试取更大的<code>k</code>值，反之同理即可。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>起初想到的思路是首先将数组进行排序，然后使用贪心，每次将最大的和最接近其二分之一的数进行匹配，但是这样的做法可以举出反例<code>3,4,6,8,100,101</code>，是不正确的。</p><p>对于这一类题目，在一个性质不行的时候，要试着把<strong>答案</strong>也作为一个变量，来思考其他的性质，这样可以利用<strong>二分法</strong>，是非常高效的。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(nlogn)$，二分答案$O(logn)$复杂度，<code>n</code>为数组元素。</li><li>空间复杂度: $O(1)$，若干常量空间。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxNumOfMarkedIndices</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length / <span class="number">2</span>; <span class="comment">// 开区间</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(nums, mid)) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right * <span class="number">2</span>; <span class="comment">// 最多匹配 left 对，有 left * 2 个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] * <span class="number">2</span> &gt; nums[nums.length - k + i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对比方法HG-prediction代码调试</title>
      <link href="/2024/09/06/%E5%AF%B9%E6%AF%94%E6%96%B9%E6%B3%95HG-prediction%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/"/>
      <url>/2024/09/06/%E5%AF%B9%E6%AF%94%E6%96%B9%E6%B3%95HG-prediction%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>给定了xslx格式的血糖数据(列为病人编号，时间，血糖值，每个病人一个文件,有大量文件)，要在HG-predicition代码中运行该数据集。</p><h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><p>通过阅读代码，可知该方法使用的是pkl格式的数据，并提供了一个convert-data方法，来把字典格式的pkl数据转为代码处理所需的单维向量格式的pkl数据。</p><p>首先把xslx格式的数据统一合并到一个csv格式的文件中（因为超过了xlsx的行数上限）。</p><p>然后转为字典格式的pkl数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 读取CSV文件</span></span><br><span class="line">    csv_file = <span class="string">&#x27;data.csv&#x27;</span></span><br><span class="line">    data = pd.read_csv(csv_file)</span><br><span class="line">    <span class="comment"># 将CSV数据转换为函数所需的字典格式</span></span><br><span class="line">    pkl_data = &#123;&#125;</span><br><span class="line">    date_formats = [<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>, <span class="string">&#x27;%Y-%m-%d %H:%M&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> index, row <span class="keyword">in</span> data.iterrows():</span><br><span class="line">        patient_id = row[<span class="string">&#x27;住院号&#x27;</span>]</span><br><span class="line">        <span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line">        <span class="keyword">for</span> date_format <span class="keyword">in</span> date_formats:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                timestamp = <span class="built_in">int</span>(datetime.strptime(row[<span class="string">&#x27;测量时间&#x27;</span>], date_format).timestamp())</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> ValueError:</span><br><span class="line">                <span class="keyword">continue</span>      </span><br><span class="line">        value = row[<span class="string">&#x27;测量值&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> patient_id <span class="keyword">not</span> <span class="keyword">in</span> pkl_data:</span><br><span class="line">            pkl_data[patient_id] = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> timestamp <span class="keyword">not</span> <span class="keyword">in</span> pkl_data[patient_id]:</span><br><span class="line">            pkl_data[patient_id][timestamp] = &#123;&#125;</span><br><span class="line">        pkl_data[patient_id][timestamp][<span class="string">&#x27;glucose&#x27;</span>] = value</span><br><span class="line">        pkl_data[patient_id][timestamp][<span class="string">&#x27;Time&#x27;</span>] = timestamp</span><br><span class="line"></span><br><span class="line">    pkl_to_X_y(pkl_data, <span class="string">&#x27;.&#x27;</span>, blen=<span class="number">9</span>, flen=<span class="number">6</span>, ignore_NA=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>原始数据没有聚类标签，正好可以使用代码提供的<code>judge_label</code>函数判断，注意这里单位不同，要把<code>70</code>改为<code>7</code>。</p><h1 id="提示空数组错误"><a href="#提示空数组错误" class="headerlink" title="提示空数组错误"></a>提示空数组错误</h1><p>在更改了数据格式之后，发现<code>pkl_to_X_y</code>函数读不到数据，而这一段代码会跳过不符合要求的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> ignore_NA <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">any</span>([t <span class="keyword">not</span> <span class="keyword">in</span> feats_dict <span class="keyword">for</span> t <span class="keyword">in</span> b_time_steps]):</span><br><span class="line">                    <span class="comment"># some backward time steps not available</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">any</span>([t <span class="keyword">not</span> <span class="keyword">in</span> feats_dict <span class="keyword">for</span> t <span class="keyword">in</span> f_time_steps]):</span><br><span class="line">                    <span class="comment"># some forward time steps not available</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>因此考虑到是否是因为什么原因导致数据不符合要求，发现对于下面这段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">            b_time_steps = [sec - i * <span class="number">300</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">0</span>, blen))]</span><br><span class="line"></span><br><span class="line">            f_time_steps = [sec + j * <span class="number">300</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, flen + <span class="number">1</span>)]</span><br></pre></td></tr></table></figure><p>其数据间隔5分钟，而现在要使用的数据间隔为15分钟，更改为<code>900</code>就可以运行。</p><h1 id="概念学习"><a href="#概念学习" class="headerlink" title="概念学习"></a>概念学习</h1><p>之前没有了解过时序数列预测的深度学习算法，这里学到了几个概念：</p><h2 id="1-预测长度"><a href="#1-预测长度" class="headerlink" title="1.预测长度"></a>1.预测长度</h2><p>“forecast length”：预测长度<br>“backcast length”：回溯长度</p><ol><li><strong>Forecast Length</strong>：这是指模型需要预测未来的时间步长的数量。</li><li><strong>Backcast Length</strong>：这是指在训练模型时，用于估计模型参数的历史数据的时间步长的数量。Backcast length 用于确定模型在进行预测之前需要观察多少历史数据。</li></ol><h2 id="2-度量指标"><a href="#2-度量指标" class="headerlink" title="2.度量指标"></a>2.度量指标</h2><p>MSE：预测值与实际值之差的平方的平均值。<br>RMSE：是MSE的平方根，和原数据同一个指标。<br>MAE：预测值与实际值之差的绝对值的平均值。</p><h2 id="3-早停策略"><a href="#3-早停策略" class="headerlink" title="3.早停策略"></a>3.早停策略</h2><p><code>patience</code>为连续多少次loss不下降后，就终止学习。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迁移doccano到新服务器</title>
      <link href="/2024/09/06/%E8%BF%81%E7%A7%BBdoccano%E5%88%B0%E6%96%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2024/09/06/%E8%BF%81%E7%A7%BBdoccano%E5%88%B0%E6%96%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="迁移方式"><a href="#迁移方式" class="headerlink" title="迁移方式"></a>迁移方式</h1><p>首先配置好服务器的ssh连接。<br>然后使用scp迁移。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r -C 服务器名称:源地址 目标地址</span><br></pre></td></tr></table></figure><h1 id="环境冲突"><a href="#环境冲突" class="headerlink" title="环境冲突"></a>环境冲突</h1><p>老服务器上的requirements写得不正确，配到新环境冲突很多。<br>因此到doccano的官方仓库查看，找到了poerty文件。</p><p>但是poerty很卡，使用GPT把poetry转为pip对应的requirments之后，再对比源环境，即可运行。</p><h1 id="报django找不到client文件的错误"><a href="#报django找不到client文件的错误" class="headerlink" title="报django找不到client文件的错误"></a>报django找不到client文件的错误</h1><p>前后端分容器时，如果后端要用到前端的文件，可能会找不到，比如django的template文件。</p><p>通过对照原服务器，得知了doccano将前端的dist文件夹放在后端文件夹中，并以此作为django的template。</p><h1 id="网络连接错误"><a href="#网络连接错误" class="headerlink" title="网络连接错误"></a>网络连接错误</h1><p>docker-compose中NGINX服务器的网络模式可改成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    network_mode: host</span><br></pre></td></tr></table></figure><p>以连接后端8099端口。</p><h1 id="找不到表的问题："><a href="#找不到表的问题：" class="headerlink" title="找不到表的问题："></a>找不到表的问题：</h1><p>web_1            |   File “&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;django&#x2F;db&#x2F;backends&#x2F;sqlite3&#x2F;base.py”, line 357, in execute<br>web_1            |     return Database.Cursor.execute(self, query, params)<br>web_1            | django.db.utils.OperationalError: no such table: auth_user</p><p>要使用cli.py 的migrate建表，然后create user</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command: /bin/sh -c &quot;python3 cli.py migrate &amp;&amp; python3 cli.py createuser &amp;&amp; python3 cli.py webserver --port 8099 &gt;&gt; webserver.txt&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> doccano </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024. 考试的最大困扰度</title>
      <link href="/2024/09/03/2024-%E8%80%83%E8%AF%95%E7%9A%84%E6%9C%80%E5%A4%A7%E5%9B%B0%E6%89%B0%E5%BA%A6/"/>
      <url>/2024/09/03/2024-%E8%80%83%E8%AF%95%E7%9A%84%E6%9C%80%E5%A4%A7%E5%9B%B0%E6%89%B0%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/description/">2024. 考试的最大困扰度</a><br>尝试了滑动窗口没做出来，这里记录官解的理解</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>由于字符串中的字符只有<code>t</code>和<code>f</code>，我们可以遍历每种字符最长串的长度，然后取最大值即可。</p><blockquote><p>之前在用滑动窗口做的时候没有想到这个做法，然后就很难想。</p></blockquote><p>给定指定字符，我们可以使用滑动窗口的方法，维护<code>left</code>到<code>right</code>这个区间为更改数量范围内的连续字符串。当<code>right</code>位置的字符不同时，如果更改字符的次数小于<code>k</code>，使用次数加一，否则不断右移<code>left</code>位置，直到找到第一个更改的地方为止。在<code>right</code>不断右移的过程中，记录能够到达的最大长度。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$，n为字符串长度，遍历字符串两次。</li><li>空间复杂度: $O(1)$。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxConsecutiveAnswers</span><span class="params">(String answerKey, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxConsecutiveChar(answerKey, k, <span class="string">&#x27;T&#x27;</span>), maxConsecutiveChar(answerKey, k, <span class="string">&#x27;F&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxConsecutiveChar</span><span class="params">(String answerKey, <span class="type">int</span> k, <span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> answerKey.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, sum = <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            sum += answerKey.charAt(right) != ch ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (sum &gt; k) &#123;</span><br><span class="line">                sum -= answerKey.charAt(left++) != ch ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3142.判断矩阵是否满足条件</title>
      <link href="/2024/08/29/3142-%E5%88%A4%E6%96%AD%E7%9F%A9%E9%98%B5%E6%98%AF%E5%90%A6%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6/"/>
      <url>/2024/08/29/3142-%E5%88%A4%E6%96%AD%E7%9F%A9%E9%98%B5%E6%98%AF%E5%90%A6%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/check-if-grid-satisfies-conditions/description/">3142. 判断矩阵是否满足条件</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>遍历一遍数组，按照题目的要求进行条件判断。</p><blockquote><p>注意不能通过简单设置循环边界为<code>n-1</code>,<code>m-1</code>来满足下边和右边的格子存在，因为例如如果只有<code>i=n-1</code>而<code>j!=m-1</code>时，仍然是需要进行判断的。</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(mn)$，遍历一遍数组。</li><li>空间复杂度: $O(1)$，只需要开<code>i,j</code>两个变量。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">satisfiesConditions</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != grid.length - <span class="number">1</span> &amp;&amp; grid[i][j] != grid[i + <span class="number">1</span>][j] || j!=grid[<span class="number">0</span>].length-<span class="number">1</span> &amp;&amp;  grid[i][j] == grid[i][j+<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动态规划】3144.分割字符频率相等的最少子字符串</title>
      <link href="/2024/08/29/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%913144-%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E9%A2%91%E7%8E%87%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%91%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2024/08/29/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%913144-%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E9%A2%91%E7%8E%87%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%91%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/minimum-substring-partition-of-equal-character-frequency/description/">3144. 分割字符频率相等的最少子字符串</a><br>难度分1917，记录官解的理解</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>观察题目要求为最少平衡子字符串的划分方法，可以发现如果设子结构<code>dp[i]</code>为截止到<code>i</code>的子字符串的解，对于这个问题：</p><ol><li>没有后效性，即<em>已经求解的子问题不受后续决策的影响</em>。</li><li>存在最优子结构，即<em>原问题的最优解可以从子问题的最优解构建得来</em></li></ol><p>对于小于<code>i</code>的<code>j</code>，有<code>dp[i] = Math.min(dp[i], dp[j] + 1)</code>，即试图在<code>j+1</code>的位置进行一次划分，如果更优则更新<code>dp[i]</code>的值。</p><blockquote><p>在思考dp问题的时候，需要注意到这种通过<strong>尝试更新</strong>来求解dp值的方法，很多问题都无法直接断定地从一个子状态更新。这种尝试更新一般来说带着一次遍历的复杂度。</p></blockquote><p>这样，问题就转为了如何判断<code>j+1</code>到<code>i</code>的字符串是否为平衡字符串，若不是平衡字符串则不能更新。最直观的想法是我们维护一个哈希表，通过不断往哈希表里加入元素，并判断某个元素出现的次数是否等于其他所有元素出现的次数，满足即可，这样每次判断都要遍历一遍哈希表。</p><p>仔细观察哈希表，我们发现，只需要出现最多次数的元素乘以哈希表的长度等于<code>j+1</code>到<code>i</code>的字符串长度即可，因此可以将时间优化到常数级。</p><blockquote><p>要注意一个性质可能带来的另外其他性质。</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n^2)$，其中<code>n</code>为数组<code>s</code>长度。</li><li>空间复杂度: $O(n+C)$，其中<code>n</code>是数组<code>s</code>长度，C是<code>s</code>中的字符数。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><pre><code class="Java">class Solution &#123;    static final int INF = 0x3f3f3f3f;    public int minimumSubstringsInPartition(String s) &#123;        int n = s.length();        int[] d = new int[n + 1];        Arrays.fill(d, INF);        d[0] = 0;        for (int i = 1; i &lt;= n; i++) &#123;            Map&lt;Character, Integer&gt; occCnt = new HashMap&lt;Character, Integer&gt;();            int maxCnt = 0;            for (int j = i; j &gt;= 1; j--) &#123;                occCnt.put(s.charAt(j - 1), occCnt.getOrDefault(s.charAt(j - 1), 0) + 1);                maxCnt = Math.max(maxCnt, occCnt.get(s.charAt(j - 1)));                if (maxCnt * occCnt.size() == (i - j + 1) &amp;&amp; d[j - 1] != INF) &#123;                    d[i] = Math.min(d[i], d[j - 1] + 1);                &#125;            &#125;        &#125;        return d[n];    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【二分法，双指针】3134.找出唯一性数组的中位数</title>
      <link href="/2024/08/27/%E3%80%90%E4%BA%8C%E5%88%86%E6%B3%95%EF%BC%8C%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%913134-%E6%89%BE%E5%87%BA%E5%94%AF%E4%B8%80%E6%80%A7%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2024/08/27/%E3%80%90%E4%BA%8C%E5%88%86%E6%B3%95%EF%BC%8C%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%913134-%E6%89%BE%E5%87%BA%E5%94%AF%E4%B8%80%E6%80%A7%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/find-the-median-of-the-uniqueness-array/description/">3134. 找出唯一性数组的中位数</a><br>难度分2451，这里记录对于官解的理解。</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>观察提示中数组的长度，可知这题使用$O(n^2)$复杂度的解法都会超时，而所有非空子数组共有<code>n*(n+1)/2</code>个，显然是不可行的。因此需要考虑二分法。如果二分法可行，再加上数组的单遍遍历，复杂度为$O(nlogn)$，就不会超时。</p><p>要使用二分法，首先我们需要保证二分查找的数组是<strong>有序</strong>的。</p><blockquote><p>这里的有序是广义的有序，只需要保证在某个性质上是有序的即可。</p></blockquote><p>首先，我们观察到<code>t</code>越大，唯一性数组中t出现的次数不一定越多，这个性质可以排除。</p><p>因此另找一个性质。对于以答案为下标的数组，设<code>t</code>为答案的某个值（即数组下标），对于性质<strong>数组nums中不同元素个数不大于t的非空子数组个数ct</strong>，该数组是有序的。也就是说，<code>t</code>的值越大，<code>ct</code>的值也就越大。</p><blockquote><p>这里数组的元素是累加性质的，所以一定递增，可以作为一种二分的思考选择。</p></blockquote><p>同时我们可以注意到，对于不同元素个数为<code>t</code>的<code>nums</code>数组切片<code>nums[j...i]</code>，其子数组的不同元素个数也不大于<code>t</code>。如果我们使用下标<code>i</code>遍历<code>nums</code>数组，并且每一轮都把<code>j</code>到<code>i</code>之间的取值作为左端点，<code>i</code>作为右端点的所有<code>i-j+1</code>个数组累加到<code>ct</code>中，我们最后就可以得到<code>ct</code>的值。</p><p>而<code>j</code>和<code>i</code>的值都可以通过滑动窗口来找到，用一个哈希表来存储不同元素的个数，大于t时下把<code>j</code>右移并更新哈希表，直到哈希表的元素个数不大于<code>t</code>。</p><blockquote><p>使用滑动窗口才能达成$O(n)$复杂度，对于子数组的问题非常有用。</p></blockquote><p>对于二分答案，上界为<code>n</code>，下界为<code>1</code>，我们要寻找的中位数在数组的<code>(n*(n+1)/2+1)/2</code>的位置上，只要找到不小于该数的最小<code>ct</code>值，t就是要求的答案。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(nlogn)$：二分法$logn$，滑动窗口$n$。</li><li>空间复杂度: $O(n)$：哈希表的开销。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">medianOfUniquenessArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">long</span> <span class="variable">median</span> <span class="operator">=</span> ((<span class="type">long</span>) n * (n + <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">1</span>, hi = n;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(nums, mid, median)) &#123;</span><br><span class="line">                res = mid;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测数组中不同元素数目小于等于 t 的连续子数组数目是否大于等于 median</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> t, <span class="type">long</span> median)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">tot</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            cnt.put(nums[i], cnt.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (cnt.size() &gt; t) &#123;</span><br><span class="line">                cnt.put(nums[j], cnt.get(nums[j]) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (cnt.get(nums[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt.remove(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            tot += i - j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tot &gt;= median;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>690.员工的重要性</title>
      <link href="/2024/08/26/690-%E5%91%98%E5%B7%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/"/>
      <url>/2024/08/26/690-%E5%91%98%E5%B7%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/employee-importance/description/">690. 员工的重要性</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>使用哈希表在常数时间获取<code>id</code>对应的<code>employee</code>，使用dfs搜索即可。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$，所有操作都是线性时间，HashMap查找只需要常数时间。</li><li>空间复杂度: $O(n)$，HashMap的空间复杂度。</li></ul><h1 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h1><p>TreeMap的时间复杂度要比HashMap要高。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for Employee.</span></span><br><span class="line"><span class="comment">class Employee &#123;</span></span><br><span class="line"><span class="comment">    public int id;</span></span><br><span class="line"><span class="comment">    public int importance;</span></span><br><span class="line"><span class="comment">    public List&lt;Integer&gt; subordinates;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer, Employee&gt; m = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getImportance</span><span class="params">(List&lt;Employee&gt; employees, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> employees.size();</span><br><span class="line">        <span class="keyword">for</span> (Employee e: employees) &#123;</span><br><span class="line">            m.put(e.id, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">start</span> <span class="operator">=</span> m.get(id);</span><br><span class="line">        <span class="keyword">return</span> cal(start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(Employee e)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> e.importance;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : e.subordinates) &#123;</span><br><span class="line">            ans += cal(m.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【状压dp】698.划分为k个相等的子集</title>
      <link href="/2024/08/26/%E3%80%90%E7%8A%B6%E5%8E%8Bdp%E3%80%91698-%E5%88%92%E5%88%86%E4%B8%BAk%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86/"/>
      <url>/2024/08/26/%E3%80%90%E7%8A%B6%E5%8E%8Bdp%E3%80%91698-%E5%88%92%E5%88%86%E4%B8%BAk%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/description/">698. 划分为k个相等的子集</a></p></blockquote><blockquote><p>这题没有成功做出来，这里记录对于官解的理解。</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>第一个重要的点是把题目的要求进行转换。将数组里的元素分为<code>k</code>个和相同的集合，那么对于整个数组的和<code>all</code>这<code>k</code>个集合每一个的和都为<code>all/k</code>，记为<code>per</code>。</p><blockquote><p>起初没有注意到这一点，因此想不出什么思路。</p></blockquote><p>因此，题目就转化为了我们可以逐渐选择元素，在这过程中计算当前累计和<code>curSum</code>，当累计和可以整除<code>per</code>时，证明我们成功选好了一个集合。如果加上当前元素后累计和大于<code>per</code>，证明这个选择是不成立的。</p><p>于是，我们需要枚举所有可能的组合情况，以查明数组是否可分。由于每个元素都有选择和不选择两种状态，我们可以使用<strong>状压dp</strong>来进行记忆化搜索。</p><blockquote><p>状压 DP 是动态规划的一种，通过将状态压缩为整数来达到优化转移的目的。</p></blockquote><p>状压dp的思想有点类似于哈希，同样把一种状态压缩成了一个整数，并存储在数组中。</p><p>在本题中，<code>dp[i]</code>若为<code>true</code>，则表示对于<code>i</code>这种状态，分好的集合中每个集合的内部和都小于等于<code>per</code>。若<code>dp[(i&lt;&lt;n)-1]</code>为<code>true</code>，则表示全部选好时每个集合的内部和都小于等于<code>per</code>，那么这样就分好了集合。</p><p>在状态转化时，我们对每个为<code>true</code>的<code>dp[i]</code>逐渐加上若干个元素，记为状态<code>next</code>。若<code>next</code>仍然满足定义，则把<code>dp[next]</code>的值置为true。</p><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>最重要的一步就是把题目的要求进行转化，往便于算法处理的方向靠。状压dp对于要遍历若干元素选或不选的情况时很有用。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n×2^n)$，其中 n 为数组 nums 的长度，共有 2n 个状态，每一个状态进行了 n 次尝试。</li><li>空间复杂度: $O(2^n)$，其中 n 为数组 nums 的长度，主要为状态数组的空间开销。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartitionKSubsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">all</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span> (all % k != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">per</span> <span class="operator">=</span> all / k;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums[n - <span class="number">1</span>] &gt; per) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">1</span> &lt;&lt; n];</span><br><span class="line">        <span class="type">int</span>[] curSum = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span> &lt;&lt; n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dp[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curSum[i] + nums[j] &gt; per) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (((i &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> i | (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                    <span class="keyword">if</span> (!dp[next]) &#123;</span><br><span class="line">                        curSum[next] = (curSum[i] + nums[j]) % per;</span><br><span class="line">                        dp[next] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>55.跳跃游戏</title>
      <link href="/2024/08/24/55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
      <url>/2024/08/24/55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/jump-game/description/">55. 跳跃游戏</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>在遍历数组的过程中，易知可跳到的范围会随着遍历的深入越来越远，因此只需在遍历过程中维护可跳到的最远距离，看是否能遍历完整个数组即可。</p><h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><p>设<code>max</code>为从数组起点能到达的最远距离，在遍历到某一点时，若该点可及，也就是说<code>max</code>&lt;<code>i</code>，则尝试更新在加入这一点后的所能到达的最远距离<code>i + nums[i]</code>。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$：最多遍历一遍数组。</li><li>空间复杂度: $O(1)$：若干常量。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            max = Math.max(max, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>121 &amp;&amp; 122. 买卖股票的最佳时机</title>
      <link href="/2024/08/23/121%20&amp;&amp;%20122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
      <url>/2024/08/23/121%20&amp;&amp;%20122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="第一题："><a href="#第一题：" class="headerlink" title="第一题："></a>第一题：</h1><blockquote><p>Problem: <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121. 买卖股票的最佳时机</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求只能在某一天买入股票，在另一天卖出，把股票的价格看成一个<strong>高度图</strong>，只要求出只能从前向后走的情况下最大下降量即可。</p><p>因此，在第一题中，我们从后向前遍历数组，保存到目前为止<strong>价格的最小值</strong>和<strong>结果的预估值</strong>。然后尝试在当前位置购入股票，并更新价格最小值。从前向后做的话方法类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curMax</span> <span class="operator">=</span> prices[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ans = Math.max(ans, curMax - prices[i]);</span><br><span class="line">            curMax = Math.max(prices[i], curMax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>起初使用过动态规划的思想来做，多开了一个最小值数组。后面发现<code>dp[i]</code>只和<code>dp[i + 1]</code>有关，注意到这个数组是不必要的。</p><h1 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h1><blockquote><p>Problem: <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122. 买卖股票的最佳时机 II</a></p></blockquote><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>本题和上一题的区别是可以选择多次购入卖出股票。和上一题一样，思考一个下山的过程，只要下山就可以获得奖励，上山也<strong>没有</strong>惩罚。</p><p>因此使用贪心的思想，对于某一天的股票，只要价格比上一天低就可以售出，用反证法就可以证明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                ans += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用LLM和doccano进行关系抽取和验证</title>
      <link href="/2023/11/29/RE/"/>
      <url>/2023/11/29/RE/</url>
      
        <content type="html"><![CDATA[<h1 id="关系抽取"><a href="#关系抽取" class="headerlink" title="关系抽取"></a><strong>关系抽取</strong></h1><p>在企业项目中，需要对制冷这一冷门领域的操作指南和说明文档进行关系抽取。为此笔者尝试了许多传统方法的模型，但效果都欠佳。受到当下在NLP（Natural Language Processing，自然语言处理）中流行且功能强大的LLM（Large Language Model，大语言模型）的启发，笔者尝试了使用本地和API的大模型进行关系抽取，取得了相对于传统方法较好的效果。</p><h2 id="使用传统深度学习方法的关系抽取的不足"><a href="#使用传统深度学习方法的关系抽取的不足" class="headerlink" title="使用传统深度学习方法的关系抽取的不足"></a><strong>使用传统深度学习方法的关系抽取的不足</strong></h2><p>起初，笔者尝试了使用传统深度学习方法进行关系抽取。基本思路是使用IDCNN&#x2F;biLSTM和CRF进行实体检测，然后使用biGRU和attention机制进行特征提取。但是传统深度学习方法有两个基本的问题：</p><ul><li>在冷门领域不具备zero-shot能力。训练这些模型的训练集（如DUIE）相对于LLM来说还是太少，而且预训练数据显然没有覆盖到制冷领域相关的知识。于是这些模型在制冷领域中都不能够提取出关系。</li><li>可用的训练数据较少。制冷领域可用的有标签训练数据太少，不足以训练出可用的模型。</li></ul><p>笔者测试了<a href="https://github.com/PaddlePaddle/PaddleNLP/tree/develop/examples/information_extraction/DuIE">DuIE</a>，<a href="https://www.modelscope.cn/models/damo/nlp_structbert_siamese-uninlu_chinese-base/summary">SiameseUniNLU</a>等主流模型，都无法在企业项目的文档中提取出任何的关系。</p><h2 id="使用-LLM进行关系抽取"><a href="#使用-LLM进行关系抽取" class="headerlink" title="使用 LLM进行关系抽取"></a><strong>使用 LLM进行关系抽取</strong></h2><p>当下，大语言模型得到了越来越多的使用，同时开源大语言模型的效果也在逐步提高。论文<a href="https://arxiv.org/pdf/2302.10205.pdf">Zero-Shot Information Extraction via Chatting with ChatGPT</a> 中的研究表明：在两个语言的6个数据集上的实验结果表明，使用ChatGPT等LLM的关系抽取取得了非常好的效果，甚至在几个数据集上（例如NYT11-HRL）上超过了全监督模型的表现。出于这篇论文的启发，笔者使用LLM进行关系抽取。</p><h3 id="LLM模型大小的影响"><a href="#LLM模型大小的影响" class="headerlink" title="LLM模型大小的影响"></a><strong>LLM模型大小的影响</strong></h3><p>首先，笔者在文心一言的网页对话上进行了初步尝试，发现了这个思路是可行的。</p><p><img src="/./2023/11/29/RE/AsposeWords2f6cad52-b522-451f-bc0b-541f2ef53fa0001.png"><img src="/./2023/11/29/RE/AsposeWords2f6cad52-b522-451f-bc0b-541f2ef53fa0002.png"></p><p>但是，商用大模型由于参数量更大、使用的计算资源更多、训练数据也更大，本地的开源大模型效果肯定比不上商用API。因此笔者在本地部署了一些主流的开源大模型，以测试是否可行。</p><p>笔者在ChatGLM3-6B-Chat，Baichuan2-13B-Chat和Baichuan2-13B-Chat-4bits量化版上都进行了实验，发现模型参数量的大小会显著地影响得出的效果。在企业项目的文档中，对于笔者准备好的相同的prompt，ChatGLM3-6B-Chat的关系抽取效果一般，难以提取出完整实体。Baichuan2-13B-Chat-4bits量化版本表现则更优，已经可以提取出较为准确的实体和关系，精度更高的Baichuan2-13B-Chat模型效果也符合预期地达到了更佳的表现。同时，商用大模型文心一言网页版得到了最理想的效果。通过实验可以发现，基本上关系抽取的效果是与LLM本身的能力（通常和参数大小正相关）是成正相关的。</p><p><img src="/./2023/11/29/RE/AsposeWords2f6cad52-b522-451f-bc0b-541f2ef53fa0003.png"><img src="/./2023/11/29/RE/AsposeWords2f6cad52-b522-451f-bc0b-541f2ef53fa0004.png"></p><p><img src="/./2023/11/29/RE/AsposeWords2f6cad52-b522-451f-bc0b-541f2ef53fa0005.png"><img src="/./2023/11/29/RE/AsposeWords2f6cad52-b522-451f-bc0b-541f2ef53fa0006.png"></p><p><img src="/./2023/11/29/RE/AsposeWords2f6cad52-b522-451f-bc0b-541f2ef53fa0007.png"><img src="/./2023/11/29/RE/AsposeWords2f6cad52-b522-451f-bc0b-541f2ef53fa0008.png"></p><h3 id="Prompt编写"><a href="#Prompt编写" class="headerlink" title="Prompt编写"></a><strong>Prompt编写</strong></h3><p>参考了论文<a href="https://arxiv.org/pdf/2302.10205.pdf">Zero-Shot Information Extraction via Chatting with ChatGPT</a>中prompt的编写方式，以及在Baichuan2上的实验，最终对于无schema的关系提取，笔者得出这个模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假设你是一个实体关系抽取模型，你需要抽取出接下来用三重反引号限定的句子中成对的关系实体。该句子来源于&#123;context&#125;中。抽取出的每个关系需要完全符合&#123;&#123;<span class="string">&quot;subject&quot;</span>:主体, <span class="string">&quot;subject_type&quot;</span>:<span class="string">&quot;主体类型&quot;</span>, <span class="string">&quot;relation&quot;</span>:<span class="string">&quot;联系&quot;</span>, <span class="string">&quot;object&quot;</span>:<span class="string">&quot;客体&quot;</span>, <span class="string">&quot;object_type&quot;</span>:<span class="string">&quot;客体类型&quot;</span>&#125;&#125;的JSON格式，主体类型、联系和客体类型的值都必须是中文，主体和客体必须完整摘自句子中，主体和客体越长、越完整越好。最后只输出符合JSON格式的结果。</span><br><span class="line">```&#123;line&#125;```</span><br></pre></td></tr></table></figure><p>这里对该prompt进行说明：</p><p>Prompt中的{context}可以是文档名字，或者这个文档的主体内容。经过实验，笔者发现给定文档名称可以让LLM更好地理解文档中的句子。</p><p>接下来笔者指定了LLM输出JSON格式的结果。通过指定找出的关系所需的格式，LLM可以给出一个较为标准的回答，便于后续的处理。而且经过实验笔者发现，在有了给定的回答格式之后，LLM的关系抽取表现也会变好。</p><p>同时笔者在实验过程中发现，LLM在遇到文档中的英文部分时，回答可能会以英文形式给出，因此笔者在prompt中限定了输出需要是中文。需要注意的是，较小的模型即使给定了这个限定，也可能不会得到像预期一样的输出。</p><p>笔者在这里加上主体和客体必须完整摘自句子中的指令，这是因为笔者之后需要把输出内容上传到doccano标注工具上，笔者需要保证实体和客体出自原句，以便找出其在原句中的位置。</p><p>Prompt中还强调了主体和客体越长、越完整越好，这个是可选的选项，经过实验笔者发现，如果加上这句话，LLM会从一个更大局的角度来找出句子中的关系，这更符合企业项目中说明文档关系提取的需求。如果去掉这句话，找出来的关系会偏向于局部的关系。需要注意的是，对于Baichuan2-13B这类较小的LLM，由于模型理解能力有限，它可能还是无法提取出符合句子中心思想的关系。但是文心一言等商用大模型就可以做到。</p><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a><strong>数据处理</strong></h3><p>由于LLM可以直接以自然语言作为输入，数据预处理工作稍微简化了一些。笔者需要考虑的问题是，对于较长的输入文本，是应该以<strong>段落</strong>还是<strong>句子</strong>为标准作为关系抽取的输入。以段落为标准进行关系抽取可以让LLM更全面地了解一个句子的意思，而且可以降低LLM的指示prompt和输入prompt的比值，提高推理效率。但是，这种方法需要占用较大的显存，一些机器可能不能满足这样高的显存要求。另外，如果是要提取文本段的核心关系，考虑是以段落还是以句子为标准，可以从不同粒度提取想要的结果。经过测试，两种标准都能有较好的关系抽取效果。因此，在机器显存足够的情况下，使用段落作为标准进行关系抽取效果更好。</p><p>读取文档后，再去除空行，以避免计算资源的浪费。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data_file = <span class="built_in">open</span>(<span class="string">&quot;./2023/11/29/RE/data/data_0.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">data = data_file.readlines()</span><br><span class="line">data = [line <span class="keyword">for</span> line <span class="keyword">in</span> data <span class="keyword">if</span> line != <span class="string">&quot;\n&quot;</span>]</span><br></pre></td></tr></table></figure><p>笔者让LLM输出符合JSON格式的结果，以便下游任务使用。</p><p>但是对于LLM，尤其是本地部署的参数较小的LLM，即使在prompt中明确给出了任务要求的输出格式，仍然会出现输出不符合要求的情况，如果不进行处理会对下游工作造成一定的麻烦。</p><p>经过实验，笔者发现LLM可能会出现以下形式的非法输出：在开始或结尾输出类似“好的，接下来我将进行关系抽取任务”的冗余信息；在最后一个JSON对象后加上逗号；输出的[]号不匹配；输出的JSON对象之间没有逗号；输出不符合要求的键值对；由于提取不出关系，输出的内容中不包含JSON。</p><p>起初笔者尝试了使用python的字符串删减，替换方式来处理，但是通过实验发现，对于LLM输出的不稳定结果，这种操作方法的鲁棒性太差。后来笔者发现，既然笔者的核心目标是LLM输出的JSON语句，那么笔者实际上可以直接提取符合JSON格式的语句段。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">relations = re.findall(<span class="string">r&#x27;(&#123;\s*?\n\s*?&quot;subject&quot;:.*?,\s*?&quot;subject_type&quot;:.*?,\s*?&quot;relation&quot;:.*?,\s*?&quot;object&quot;:.*?,\s*?&quot;object_type&quot;:.*?\s*?&#125;)&#x27;</span>, response)</span><br></pre></td></tr></table></figure><p>这个正则表达式会匹配（几乎）符合要求的JSON对象，由于输出的内容中可能不包含JSON，需要再加上控制判断。</p><p>然后用replace来解决最后一个JSON对象后加上逗号的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = re.sub(<span class="string">r&quot;,\s*?\n?\s*?&#125;&quot;</span>, <span class="string">&quot;\n&#125;&quot;</span>, response)</span><br></pre></td></tr></table></figure><p>找到符合条件的JSON对象后，只需要再用python的字符串方法把它们拼接起来，最终就可以形成一个可用的JSON。</p><h3 id="基于schema和无schema的关系抽取"><a href="#基于schema和无schema的关系抽取" class="headerlink" title="基于schema和无schema的关系抽取"></a><strong>基于schema和无schema的关系抽取</strong></h3><p>在关系抽取任务中，schema，也就是诸如(人名-编写-小说)这样的关系模式，可以用来限制和指导关系抽取模型抽取关系。而LLM相对于传统深度学习的关系抽取模型来说，还拥有无schema进行关系抽取的能力；也就是说，LLM会自动地根据任务需要和上下文提取出合适地关系，而不限定是什么模式。基于schema进行关系抽取可以让LLM抽取出笔者想要的特定模式，适合笔者有明确的抽取目标的场景；而无schema的关系抽取可以节省相关人员的工作量，也可以更好地发挥大模型的理解能力，缺点是抽取出的关系和实体标签可能比较繁杂。</p><p>通过实验笔者发现，对于企业项目中说明文档性质的内容，在使用Baichuan2-13B模型的情况下，如果使用基于schema的关系抽取，LLM回答的内容的置信度会下降很多，经常出现强行匹配schema的情况，而且即使是符合schema的关系，效果也只是一般。而如果不使用schema则不会有这种情况发生，因此笔者默认使用无schema的模式，如果要使用基于schema的模式，可以参考<a href="https://github.com/cocacola-lab/ChatIE">ChatIE</a>中的Prompt。</p><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a><strong>其他问题</strong></h3><p>如果使用Baichuan2-13B等本地开源模型，且机器性能一般，只能勉强运行的话，对于较长的句子，LLM可能会卡死，即使过了十几二十分钟也不会输出结果。因此，笔者使用了timeout_decorator库来为推理设置超时时间（只在Linux平台上有效）。同时在JSON文件记录了输出对应于原始文本的位置index。</p><p>因为长文本处理随时都有可能因为各种异常原因暂停，笔者把程序断开时所在的index记录为check_point，以使得程序在断开后能从断开的句子处继续写入。</p><p>由于大模型输出结果的不稳定性，最后的文档可能还不是标准的JSON格式，需要再进行JSON校验。</p><h1 id="doccano标注"><a href="#doccano标注" class="headerlink" title="doccano标注"></a><strong>doccano标注</strong></h1><p>由于不管是传统深度学习模型还是大语言模型，都无法完美地提取出期望的结果，笔者使用了开源的文档标注工具<a href="https://github.com/doccano/doccano">doccano</a>，以实现人在回路进行关系的校验和增删。由于要将LLM的不稳定输出提交到需要稳定输入的doccano标注工具上，笔者编写相关转换和处理的Python代码。</p><h2 id="doccano客户端"><a href="#doccano客户端" class="headerlink" title="doccano客户端"></a><strong>doccano客户端</strong></h2><p>连接doccano需要token鉴权，因此首先需要知道doccano部署的ip和端口，以及username和password。笔者使用下面的代码来进行客户端的初始化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, entrypoint, password</span>):</span><br><span class="line">    <span class="variable language_">self</span>.entrypoint = entrypoint</span><br><span class="line">    <span class="variable language_">self</span>.client = requests.Session()</span><br><span class="line">    <span class="variable language_">self</span>.client.auth = (username, password)</span><br><span class="line">    token = <span class="variable language_">self</span>.client.request(<span class="string">&quot;POST&quot;</span>,<span class="string">f&#x27;<span class="subst">&#123;self.entrypoint&#125;</span>/v1/auth/login/&#x27;</span>, json=&#123;<span class="string">&#x27;username&#x27;</span>: username, <span class="string">&#x27;password&#x27;</span>: password&#125;).cookies[<span class="string">&#x27;csrftoken&#x27;</span>]</span><br><span class="line">    <span class="variable language_">self</span>.client.headers.update(&#123;<span class="string">&#x27;X-CSRFToken&#x27;</span>: token&#125;)</span><br></pre></td></tr></table></figure><p>Client类中定义的其他方法用于对doccano客户端的增删改查操作。</p><p>在Doccano中，一个项目（project）是拥有共同标签集的文本集的概念，一个文档（document）是一个用于标注的文本。标签（labels）包括实体标签和联系标签，实体标签和关系标签分别用span-type和relation-type表示。一个标注实体用（span）表示，记录相关实体的起始和结束偏移量，以及实体标签；一个标注关系用（relation）表示，记录头实体，尾实体和关系标签。</p><h2 id="数据处理-1"><a href="#数据处理-1" class="headerlink" title="数据处理"></a><strong>数据处理</strong></h2><p>首先，笔者需要对<a href="#_%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86">数据处理</a>中得到的JSON格式输出进行人工确认，确保符合JSON格式，一般只需要修改几处异常即可（其中，重复的键值对无需处理，Python的json库自动取最后一个值）。</p><p>笔者还需要读取原始文本，然后指定文章的划分方法，这里一般是换行符或者句号。</p><p>接下来是读取JSON格式的输出文本，然后需要删除不符合条件的关系。笔者删除掉缺少由prompt指定的必要的JSON关键字的响应，因为这通常隐含了这个提取效果不够好，才会缺少某一个关键字。同样的，当键值对的值不为字符串、键值对的值为空时，笔者也删除掉这个关系。笔者不关注多余的键值对（例如，LLM会提取出“evidence”，“object_part”这样不符合要求的键），因为笔者直接忽视这部分即可（也提供了像上述一样删除的选项）。</p><h2 id="上传标签"><a href="#上传标签" class="headerlink" title="上传标签"></a><strong>上传标签</strong></h2><p>如果之前没有上传过标签，笔者就把JSON输出的所有实体类型、关系、联系类型都上传到doccano服务器上。Doccano会自动屏蔽掉重复的标签，所以无需额外处理。如果要删除标签，可以调用client的响应函数。</p><h2 id="获取标签id"><a href="#获取标签id" class="headerlink" title="获取标签id"></a><strong>获取标签id</strong></h2><p>在doccano中，笔者是通过标签的id来操作标签的，而不是用标签的名称。而id又是doccano指定的，所以笔者需要事先从doccano获得标签，并把标签和对应文本的键值对保存到内存里，以便后续上传实体和关系时使用。</p><h2 id="上传实体和关系"><a href="#上传实体和关系" class="headerlink" title="上传实体和关系"></a><strong>上传实体和关系</strong></h2><h3 id="实体位置的计算"><a href="#实体位置的计算" class="headerlink" title="实体位置的计算"></a><strong>实体位置的计算</strong></h3><p>上传实体时最主要的问题就是实体位置的计算。因为doccano记录实体在文章中的位置，以便于进行检验和修改，所以笔者需要上传正确的实体位置。</p><p>这一部分工作（还有之前相当一部分的工作）笔者没有交给LLM来做，因为这类有确切结果，且容易编写算法求解的工作，编写对应的Python脚本来解决，可以既保证结果的准确性又减少算力的浪费。</p><p>笔者使用一个变量global_offset来记录实体在文章中的实际偏移量。对于LLM输出的JSON文档中对于每一个文本段给出的所有回复，笔者都尝试找出这个回复中的实体和客体第一次出现在这个文本段的位置（因为同样名称的实体在一个文本段中几乎可以肯定是相同含义的），如果找不到这个实体（通常是因为LLM的模型较小，而忽视了笔者的要求），笔者通过匹配前若干个相同的字符来找到文本段的位置（同样是因为文本段较小，几乎不会找错专有实体）。如果确实找不到这个实体（几乎不会出现），笔者也就只能跳过这个句子。最终，这个实体的实际起始偏移量和实际结束偏移量结合global_offset和实体的长度就都可以计算出来了</p><p>在每个句子处理完后，笔者把global_offset加上这个句子的长度。需要注意的一个细节是，由于LLM可能对于某些文段没有输出，笔者需要把跳过对应的句子的长度也都加起来。</p><h3 id="重复实体的处理"><a href="#重复实体的处理" class="headerlink" title="重复实体的处理"></a><strong>重复实体的处理</strong></h3><p>对于每个句子，一个实体可能会在多个关系中出现，而doccano不会对重复的实体进行过滤（这是因为一个实体可能有多个类型，但是实际上doccano对于相同的类型也不会过滤），因此笔者需要判断是否已经上传过了这个实体，否则标注的结果会很混乱。这里判断相同的依据是：起始偏移量、结束偏移量和标签都相同。</p><p>这样做还有一个额外的好处。当程序因为各种原因断开时，笔者可以简单地从头执行这个程序，因为重复的实体不会被重复上传。</p><h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a><strong>上传</strong></h3><p>所有的上述工作做完后，笔者就可以上传实体和关系了。上传实体时只需要上传初始、结束偏移量和实体标签id，上传关系时只需要上传头尾实体id和标签id。对于重复的关系，doccano会自动过滤掉。</p><p><img src="/./2023/11/29/RE/AsposeWords2f6cad52-b522-451f-bc0b-541f2ef53fa0009.png"><img src="/./2023/11/29/RE/AsposeWords2f6cad52-b522-451f-bc0b-541f2ef53fa0010.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
            <tag> LLM </tag>
            
            <tag> doccano </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Multimodal Machine Learning: A Survey and Taxonomy</title>
      <link href="/2023/10/15/Multimodal-Machine-Learning-A-Survey-and-Taxonomy/"/>
      <url>/2023/10/15/Multimodal-Machine-Learning-A-Survey-and-Taxonomy/</url>
      
        <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><p>一般来说，模态就是指，一种事情发生或者被经历的方法。</p><p>当一个研究的问题或者说数据集包含了多个模态时，就是多模态问题或者多模态数据集。</p><p>多模态数据主要有：自然语言；视觉信号；音频信号等。<br>我认为多模态主要包括这些，是因为这些信息是日常生活红数据量最丰富、最有价值和最容易获取的信息，在当下最具有研究价值；而一些其他的信息，像是红外、超声、嗅觉、触觉、加速度信号等，可能只会在机器人等限定的领域有用处，相对来说应用范围没有那么广泛，信号的局限性较大。</p><p>多模态的五大挑战：表示，转换，对齐，融合，协同学习<br>这几大方面的挑战是：<br>表示：怎样表示、总结不同模态的信息。不同模态的数据经常是异质的，比如语言是符号性的，音频和视频是用信号表示的。<br>转换：不同模态之间的联系可能是开放的，比如一个图片可以有多种语言解释。<br>对齐：把不同的模态直接联系起来，比如把做菜的步骤关联到对应的视频。<br>融合：把不同模态的数据综合起来做预测。<br>协同学习：把一种模态的学习模型迁移到另一个模态的模型中</p><p>我认为这几个问题中，表示主要是数据处理层面的，涉及到模型如何设计、数据怎样表示；翻译和对齐可以是模型的一部分能力，也可以是这个多模态模型的功能；融合主要是涉及到模型的输出部分；而协同学习则是和迁移学习相似，主要是对模型开发人员有用。我认为这几个问题中最有挑战性的可能是协同学习，因为不同模态之间的模型差异实在太大，感觉这样的机制很难实现。</p><h1 id="2-多模态的应用："><a href="#2-多模态的应用：" class="headerlink" title="2 多模态的应用："></a>2 多模态的应用：</h1><p>1.视听结合的言语识别，图像注解等 V-A<br>多模态可以增强模型的鲁棒性<br>2.多媒体内容的索引和检索 V-A<br>3.人类社交时的多模态行为的理解 V-A<br>4.媒体解释 V-L<br>5.事件检测 V-L<br>6.多媒体生成 V-L</p><p>跨模态检索会用到除了融合以外的所有技术</p><h1 id="3-表示"><a href="#3-表示" class="headerlink" title="3 表示"></a>3 表示</h1><p>把多模态的数据用计算模型可以识别的格式表示出来，可以是向量&#x2F;张量表示。<br>困难  </p><ol><li>结合异质数据  </li><li>处理不同的噪音  </li><li>处理丢失的数据<br>现在很多的多模态数据的表示都是单模态数据的简单拼接。</li></ol><p>好的表示的特点：平滑、保留时空顺序、稀疏、自然聚类</p><h3 id="联合表示："><a href="#联合表示：" class="headerlink" title="联合表示："></a>联合表示：</h3><p>联合表示把多个单模态数据结合到相同的表示空间 。<br>通常用在多模态数据要结合起来使用的时候<br>AVSR，情感分析，多模态手势识别等</p><p>神经网络<br>通常把最后一层或者倒数第二层拿来用<br>1.先分别用独立层训练，然后通过一个隐藏层来把这些模态投影到一个联合的空间中<br>2.对于没有标签的数据，可以用自编码器<br>基于联合表示的神经网络的一大好处是：<br>可以学习无标签数据，而且可以微调来适应特殊的任务</p><p>概率图模型<br>使用DBM等<br>优点：泛化性好，可以更好地处理缺失模态的数据<br>缺点：难以训练，计算代价高</p><p>序列表示<br>使用RNN</p><h3 id="协同表示："><a href="#协同表示：" class="headerlink" title="协同表示："></a>协同表示：</h3><p>协同表示分别处理单模态信号，同时保留有相似的约束。<br>通常用在一次只使用一种模态数据的时候<br>比如多模态检索、翻译、结合、零次学习</p><p>相似模型：<br>最小化不同模态间在坐标空间的距离<br>可以使用神经网络，可以端到端学习协同表示(RNN\LSTM等)</p><p>结构化坐标空间：<br>添加了额外的限制<br>主要形式有跨模态哈希、图像和语言的顺序嵌入、典型关联分析：<br>把高纬度数据压缩到低纬度，相似的对象有相似的码<br>可以使用神经网络</p><h1 id="4-翻译"><a href="#4-翻译" class="headerlink" title="4.翻译"></a>4.翻译</h1><p>给出一个模态的实体，生成在另一个模态的相同的实体<br>例子：语音合成，视觉语音生成，视频描述，跨模态检索<br>两种类型：基于样例的，生成式的</p><h2 id="4-1-基于样例的：使用字典"><a href="#4-1-基于样例的：使用字典" class="headerlink" title="4.1 基于样例的：使用字典"></a>4.1 基于样例的：使用字典</h2><p>使用两类算法：基于检索的，基于结合的<br>基于检索的：直接使用检索，可用单模态空间或者跨媒体语义空间，后者更好，可以双向翻译<br>基于结合的：使用更复杂的规则，把多个结果结合起来生成一个更好的翻译<br>缺点：模型大、查询慢、字典要求大、不一定有对应结果</p><h2 id="4-2-生成式的：生成模型"><a href="#4-2-生成式的：生成模型" class="headerlink" title="4.2 生成式的：生成模型"></a>4.2 生成式的：生成模型</h2><p>类型：基于语法的，编码解码器（最常用），持续生成模型</p><p>基于语法的：用语法限制目标域<br>优势：更可能生成语法和逻辑正确的结果<br>局限：智能产生公式化的结果，难以创新；训练过程要分段、复杂</p><p>编码解码器：先编码到一个隐表示，然后再用解码器解码<br>使用端到端的神经网络，编码通常和模态本身有关，解码通常用RNN和LSTM。缺点是需要大量数据，而且神经网络可能是再记忆训练数据</p><p>持续生成模型：基于源模态数据流持续生成目标模态，最适合时序序列，例如文字转语音</p><h2 id="4-3-模型评估"><a href="#4-3-模型评估" class="headerlink" title="4.3 模型评估"></a>4.3 模型评估</h2><p>一种评估方法是人工判断：<br>语音合成：自然度，平均观点分数<br>VSS：真实度<br>媒体描述：语法语义正确，相关度，顺序，细节<br>自动评估效果一般</p><p>也可以用检索来作为描述的评估方法</p><h1 id="5-对齐"><a href="#5-对齐" class="headerlink" title="5 对齐"></a>5 对齐</h1><p>找到不同模态之间的子模块实体之间的联系和对应关系<br>两种对齐：显式和隐式</p><h2 id="5-1-显式对齐"><a href="#5-1-显式对齐" class="headerlink" title="5.1 显式对齐"></a>5.1 显式对齐</h2><p>最重要的方式是用相似矩阵来评价</p><p>无监督：不需要对齐的标签<br>假设对齐有限制，例如时间顺序，或者相似矩阵存在<br>DTW用于对齐多视角时间序列，CCA。可以同时学习相似矩阵和对齐<br>图模型，需要专家知识。</p><p>有监督：需要有标签的对齐实例<br>方法和无监督的比较像</p><p>深度学习也在显式对齐里面很好用，LSTM，CNN</p><h2 id="5-2-隐式对齐"><a href="#5-2-隐式对齐" class="headerlink" title="5.2 隐式对齐"></a>5.2 隐式对齐</h2><p>是其他任务中间的步骤，通常是隐式的<br>不依赖于有监督的样本</p><p>图模型：需要人工设定对齐方式，比较不常用</p><p>神经网络：最常用的方法，尤其是在翻译的中间步骤，可以给翻译带来很大的提升，加入注意力机制效果更好</p><h2 id="5-3-难点"><a href="#5-3-难点" class="headerlink" title="5.3 难点"></a>5.3 难点</h2><p>标签数据少，相似矩阵难设计，对齐关系可能是多对多，或者不存在</p><h1 id="6-融合"><a href="#6-融合" class="headerlink" title="6 融合"></a>6 融合</h1><p>集成多个模态的信息来做预测，一般认为是在预测的后部阶段</p><ol><li>更健壮的预测结果</li><li>可以捕捉到补充的信息</li><li>缺失一个维度的信息时仍可以起作用</li></ol><h2 id="6-1-模型无关的方法"><a href="#6-1-模型无关的方法" class="headerlink" title="6.1 模型无关的方法"></a>6.1 模型无关的方法</h2><p>可以分为早期，晚期和杂交融合<br>比较简单，但是不能充分利用多模态的特点</p><h2 id="6-2-基于模型的方法"><a href="#6-2-基于模型的方法" class="headerlink" title="6.2 基于模型的方法"></a>6.2 基于模型的方法</h2><p>基于核的方法：<br>不同的模态使用不同的核，核可以看成数据点的相似函数<br>优点是损失函数是凸的，好优化；<br>缺点是测试时也要用训练数据，查询慢，内存消耗大</p><p>图模型：<br>生成式的：建模联合概率<br>判别式的：建模条件概率<br>优点：容易利用数据的时间和空间结构，所以在AVSR和情感检测常用；可以加入专家知识</p><p>神经网络：最常用<br>优势：可以从大量的数据中学习；端到端训练；效果好<br>缺点：可解释性差，需要大量数据</p><p>融合的困难：<br>数据可能没有在时间上对齐<br>难以捕捉互补的信息<br>每个模态都可能会有噪音</p><h1 id="7-共同学习"><a href="#7-共同学习" class="headerlink" title="7 共同学习"></a>7 共同学习</h1><p>用另一个模态的模型知识来辅助一个模态的模型学习<br>这是与任务无关的，因此可以在多模态融合、翻译、对齐模型中使用</p><h2 id="7-1-平行数据"><a href="#7-1-平行数据" class="headerlink" title="7.1 平行数据"></a>7.1 平行数据</h2><p>不同模态使用一个数据集，对应关系已经确定<br>共同训练：创建更多有标签数据<br>迁移学习：可以多模态表示，单模态的时候也更好</p><h2 id="7-2-不平行数据"><a href="#7-2-不平行数据" class="headerlink" title="7.2 不平行数据"></a>7.2 不平行数据</h2><p>不需要有共享的实例，只需要有共享的概念或类别<br>迁移学习<br>概念建构：通过不仅仅是语言，也包含其他模态的数据来学习语义<br>零次学习：不需要之前见过任何相关的有标签的数据，就识别出一个概念<br>单模态：通过部分特征来推出实体<br>多模态：使用另一个模态来推出没有认识的模态</p><h2 id="7-3-混合数据"><a href="#7-3-混合数据" class="headerlink" title="7.3 混合数据"></a>7.3 混合数据</h2><p>两个模态用一个共享的模态或者数据集来桥接</p>]]></content>
      
      
      
        <tags>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
