<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>17. 电话号码的字母组合</title>
      <link href="/2025/04/17/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
      <url>/2025/04/17/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这题我一开始使用的是BFS的思想，如下面的第一个代码所示。然而这样做存在不足，因为需要频繁构建StringBuilder来存储当前层的字符串。</p><p>对于字符串的频繁操作，如果使用DFS+回溯的思想，就可以减少这个反复创建的开销，效率更高。因为这个时候我们已经预先定好了将要插入字符的长度，并且可以重复利用之前的子字符串，只需要在到达叶子节点时把答案加入答案数组即可。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Queue&lt;StringBuilder&gt; ans = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span>[][] MAP = &#123;</span><br><span class="line">        &#123;&#125;, &#123;&#125;, &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;, &#123;<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;, &#123;<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>&#125;, </span><br><span class="line">        &#123;<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>&#125;, &#123;<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;, &#123;<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>&#125;, </span><br><span class="line">        &#123;<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>&#125;, &#123;<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits.isEmpty()) <span class="keyword">return</span> ret;</span><br><span class="line">        ans.offer(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; digits.length(); i++) &#123;</span><br><span class="line">            bfs(digits.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!ans.isEmpty()) &#123;</span><br><span class="line">            ret.add(ans.poll().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> ans.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> ans.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; MAP[num].length; j++) &#123;</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(sb);</span><br><span class="line">                ans.offer(temp.append(MAP[num][j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] MAPPING = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] digits;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> digits.length();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> List.of();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.digits = digits.toCharArray();</span><br><span class="line">        path = <span class="keyword">new</span> <span class="title class_">char</span>[n]; <span class="comment">// 注意 path 长度一开始就是 n，不是空数组</span></span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == digits.length) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">String</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : MAPPING[digits[i] - <span class="string">&#x27;0&#x27;</span>].toCharArray()) &#123;</span><br><span class="line">            path[i] = c; <span class="comment">// 直接覆盖</span></span><br><span class="line">            dfs(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>224. 基本计算器</title>
      <link href="/2025/04/16/224-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
      <url>/2025/04/16/224-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>做这题的时候，我想起了当时上编译原理的词法分析。于是想到是否可以使用栈来模拟，其中一个栈用来模拟括号的处理，另一个栈用来模拟单个括号内的计算处理。如第一个代码所示。但是我这个做法比官解的做法慢了很多。因为需要频繁地构建字符串，并且把字符串从一个栈转到另一个栈，时间复杂度的常数较大。</p><p>为了解决上述的问题，我们分别用<strong>数字栈</strong>和<strong>运算符栈</strong>来模拟操作。其余思路接近。</p><h1 id="小tips"><a href="#小tips" class="headerlink" title="小tips"></a>小tips</h1><h2 id="单目负号运算符的处理"><a href="#单目负号运算符的处理" class="headerlink" title="单目负号运算符的处理"></a>单目负号运算符的处理</h2><p>单目负号运算符当且仅当负号前没有数字时出现，为了统一运算，我们可以把其视为0-x，因此，我们在其前方加入0即可。</p><p>同时，为了防止第一个数为负数，我们往数字栈里第一个数插入0。这类似于<strong>哨兵</strong>的思想。</p><h2 id="Java判断字符是否为数字"><a href="#Java判断字符是否为数字" class="headerlink" title="Java判断字符是否为数字"></a>Java判断字符是否为数字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Character.isDigit(c);</span><br></pre></td></tr></table></figure><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Deque&lt;String&gt; parentheses  = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;String&gt; cal = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cs.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cs[i] == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (cs[i] == <span class="string">&#x27;)&#x27;</span>) util();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;(+-&quot;</span>.indexOf(cs[i]) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                parentheses.push(String.valueOf(cs[i]));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n &amp;&amp; <span class="string">&quot;0123456789&quot;</span>.indexOf(cs[i]) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    sb.append(cs[i++]);</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">                parentheses.push(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parentheses.size() &gt; <span class="number">1</span>) util();</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(parentheses.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">util</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(!parentheses.isEmpty()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">top</span> <span class="operator">=</span> parentheses.pop();</span><br><span class="line">            <span class="keyword">if</span> (top.equals(<span class="string">&quot;(&quot;</span>)) <span class="keyword">break</span>;</span><br><span class="line">            cal.push(top);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cal里无括号，只有计算</span></span><br><span class="line">        <span class="keyword">while</span> (cal.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cal.peek().equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                cal.pop();</span><br><span class="line">                cal.push(String.valueOf(-Integer.valueOf(cal.pop())));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Integer.valueOf(cal.pop());</span><br><span class="line">            <span class="type">String</span> <span class="variable">op</span> <span class="operator">=</span> cal.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Integer.valueOf(cal.pop());</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (op.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                next = left + right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next = left - right;</span><br><span class="line">            &#125;</span><br><span class="line">            cal.push(String.valueOf(next));</span><br><span class="line">        &#125;</span><br><span class="line">        parentheses.push(cal.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 存放所有的数字</span></span><br><span class="line">        Deque&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 为了防止第一个数为负数，先往 nums 加个 0</span></span><br><span class="line">        nums.push(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 将所有的空格去掉</span></span><br><span class="line">        s = s.replaceAll(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 存放所有的操作，包括 +/-</span></span><br><span class="line">        Deque&lt;Character&gt; ops = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> cs[i];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ops.push(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ops.peek() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    calc(nums, ops);</span><br><span class="line">                &#125;</span><br><span class="line">                ops.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isNum(c)) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">                    <span class="comment">// 将从 i 位置开始后面的连续数字整体取出，加入 nums</span></span><br><span class="line">                    <span class="keyword">while</span> (j &lt; n &amp;&amp; isNum(cs[j])) u = u * <span class="number">10</span> + (<span class="type">int</span>)(cs[j++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    nums.push(u);</span><br><span class="line">                    i = j - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (cs[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> || cs[i - <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span> || cs[i - <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">                        nums.push(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 有一个新操作要入栈时，先把栈内可以算的都算了（以解决没有括号的情况）</span></span><br><span class="line">                    <span class="keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peek() != <span class="string">&#x27;(&#x27;</span>) calc(nums, ops);</span><br><span class="line">                    ops.push(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ops.isEmpty()) calc(nums, ops);</span><br><span class="line">        <span class="keyword">return</span> nums.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">calc</span><span class="params">(Deque&lt;Integer&gt; nums, Deque&lt;Character&gt; ops)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ops.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> nums.pop(), a = nums.pop();</span><br><span class="line">        <span class="type">char</span> <span class="variable">op</span> <span class="operator">=</span> ops.pop();</span><br><span class="line">        nums.push(op == <span class="string">&#x27;+&#x27;</span> ? a + b : a - b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNum</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Character.isDigit(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>103. 二叉树的锯齿形层次遍历</title>
      <link href="/2025/04/14/103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
      <url>/2025/04/14/103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这题也是按层遍历，因此我们自然想到也用队列来处理。</p><p>那么如何在隔层反向输出呢？其实我们无需更改BFS的遍历顺序，而是不断插入临时链表的头部， 这样我们自然就得到了反向。</p><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>Java的List接口有多种实现，在只需要频繁插入头尾节点时，使用LinkedList会快一点。反之，在需要随机读取时，使用ArrayList会快非常多。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><pre><code class="java">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();        Deque&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        if (root == null) return ans;        queue.offer(root);        while (!queue.isEmpty()) &#123;            //List也可以是linkedList            List&lt;Integer&gt; curLevel = new LinkedList&lt;&gt;();            int size = queue.size();            for (int i = 0; i &lt; size; i++) &#123;                TreeNode node = queue.poll();                if (ans.size() % 2 == 0) curLevel.add(node.val);                else curLevel.addFirst(node.val);                if (node.left != null) queue.offer(node.left);                if (node.right != null) queue.offer(node.right);            &#125;            ans.add(curLevel);        &#125;        return ans;    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>219. 存在重复元素 II</title>
      <link href="/2025/04/14/219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II/"/>
      <url>/2025/04/14/219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II/</url>
      
        <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>本题思路很明显是使用双指针+哈希表，具体实现上有几个点可以学习。</p><p>首先是在时间几乎无差别（即多一个if语句）的情况下，代码的简洁易懂有时候更为重要。像这题前几个元素的特判，可以不用单独拎一个for循环出来，而是加一个if语句在for循环中，这样便于维护循环不变式。</p><p>本题的循环不变式是，i代表右端点，如果i比k大，那么i - k - 1就是将要移除的左端点。如果右端点的值在<code>[i - k, i - 1]</code>内出现过，那么循环结束，返回true。在循环中，我们每次都把右端点的值加入进集合中，并在每个循环开头移除左端点的值。</p><p>另外这题可以学到的另一个点是，set的add方法有返回值，如果插入的元素已有则会返回false，这样我们就可以少写一个判断语句。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsNearbyDuplicate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; k) &#123;</span><br><span class="line">                set.remove(nums[i - k - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>909. 蛇梯棋</title>
      <link href="/2025/03/28/%E3%80%90BFS%E3%80%91909-%E8%9B%87%E6%A2%AF%E6%A3%8B/"/>
      <url>/2025/03/28/%E3%80%90BFS%E3%80%91909-%E8%9B%87%E6%A2%AF%E6%A3%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/snakes-and-ladders/description/">909. 蛇梯棋</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这题本来我想用dp来解，但是后来发现，本题具有<code>后效性</code>，不符合dp的基本要求。因为本题中的蛇可能会往回走，而往回走又可能反而更快，因此不能使用dp。</p><p>出于本题的一般性，这题更适合抽象成BFS的做法。首先我们知道，BFS是最适合用来求无权有向图的最短路径的，正好本题就可以抽象成这样的图，按照BFS来求解即可。</p><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><p>本题用转行交替的形式编号，观察board数组，首先行被倒序了，因此我们用<code>n - 1 - row</code>来表示行。列编号每个一行转一个方向，因此对于偶数行，列号为<code>n - 1 - ((next - 1) % n)</code>，即总列数减去当前编号所”应该在“的列。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">snakesAndLadders</span><span class="params">(<span class="type">int</span>[][] board)</span> &#123;</span><br><span class="line">        n = board.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> n * n;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[end + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        q.offer(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt; size; c++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">now</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="keyword">if</span> (now == end) <span class="keyword">return</span> ans;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span> &amp;&amp; now + i &lt;= end; i++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> now + i;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> (next - <span class="number">1</span>) / n;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> row % <span class="number">2</span> == <span class="number">1</span> ? n - <span class="number">1</span> - ((next - <span class="number">1</span>) % n) : (next - <span class="number">1</span>) % n;</span><br><span class="line">                    row = n - <span class="number">1</span> - row;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">teleport</span> <span class="operator">=</span> board[row][col];</span><br><span class="line">                    <span class="keyword">if</span> (teleport != - <span class="number">1</span>) next = teleport;</span><br><span class="line">                    <span class="keyword">if</span> (!vis[next])&#123;</span><br><span class="line">                        q.offer(next);</span><br><span class="line">                        vis[next] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>222. 完全二叉树的节点个数</title>
      <link href="/2025/03/26/222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/"/>
      <url>/2025/03/26/222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//如何比O(n)更快？不是剪枝，而是二分</span></span><br><span class="line">    <span class="comment">//剪枝只能带来小幅度的优化，不能改变最坏时间复杂度</span></span><br><span class="line">    <span class="comment">//为了跳出遍历所有节点的限制，我们转而计算高度：因为计算满二叉树的高度是logn的操作。</span></span><br><span class="line">    <span class="comment">//位运算的优先级很低</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> calHeight(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> calHeight(root.right);</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            ans += (<span class="number">1</span> &lt;&lt; l) - <span class="number">1</span>;</span><br><span class="line">            ans += countNodes(root.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += (<span class="number">1</span> &lt;&lt; r) - <span class="number">1</span>;</span><br><span class="line">            ans += countNodes(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calHeight</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> calHeight(node.left) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>173. 二叉搜索树迭代器</title>
      <link href="/2025/03/26/%E3%80%90%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%80%92%E5%BD%92%E3%80%91173-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2025/03/26/%E3%80%90%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%80%92%E5%BD%92%E3%80%91173-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/binary-search-tree-iterator/description/">173. 二叉搜索树迭代器</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>本题的核心关键就是用栈来实现递归。只要用栈模拟了二叉搜素树的中序遍历，就可以迭代返回需要的节点值。</p><p>我们考察递归的过程，在中序遍历时，会不断调用左节点的递归函数，直到左子树完成递归。因此，我们需要用一个栈来保存这个递归过程。即我们用栈来存储<code>正在访问左子树，但是本身以及右子树还未访问</code>的节点。</p><p>当左子树完成递归后，栈顶元素就是当前节点，我们弹出该节点，并获得当前位置的值。</p><p>接下来考虑，我们要如何模拟调用右递归函数呢？</p><p>可能我们会直观地猜想需要再用一个栈来存储，但实际上并不需要。</p><p>因为当我们调用右递归函数时，递归函数会继续调用左递归函数，也就意味着并没有连续递归调用的过程，因此我们也就不需要一个栈来存储。</p><p>我们模拟右递归调用，关键是要能使得当前节点在有无右子树的情况下都能正确处理，即：</p><ol><li>在无右子树的情况下，返回到父节点。</li><li>在有右子树的情况下，返回到当前节点的右节点。</li></ol><p>如果直接用栈顶元素，能否达到这个效果？显然是不行的，因为当无右子树时，我们显然不做操作，这时栈顶元素是其父节点，下一次操作会访问其父节点的左子树，造成循环访问。</p><p>因此我们需要设置一个变量<code>current</code>，以表示<strong>当前访问的节点</strong>。我们以<code>current</code>为核心，先“递归”访问左子树，然后弹出并输出栈顶元素，最后在<code>next()</code>结束时把<code>curren</code>设为其右节点，这样就把”递归”引向了其右子树，完整地模拟了一次递归。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="comment">// 模拟中序遍历，存储当前子树递归中未返回的左调用</span></span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>();</span><br><span class="line">    <span class="comment">// 中序遍历的右调用</span></span><br><span class="line">    TreeNode current;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        val = -<span class="number">1</span>;</span><br><span class="line">        current = root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(current);</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">ret</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        current = ret.right;</span><br><span class="line">        <span class="keyword">return</span> ret.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> current != <span class="literal">null</span> || !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BSTIterator obj = new BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.next();</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>98. 验证二叉搜索树</title>
      <link href="/2025/03/22/%E3%80%90%E9%80%92%E5%BD%92%E3%80%9198-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2025/03/22/%E3%80%90%E9%80%92%E5%BD%92%E3%80%9198-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/validate-binary-search-tree/description/">98. 验证二叉搜索树</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>最近做二叉树的题目比较多，这里面涉及到的主要是各种各样的递归问题。以这题为例复习和总结一下二叉树的递归问题。</p><p>本题的目标是验证二叉树是否为二叉搜索树。</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>朴素来看，要验证是二叉搜索树，我们需要保证左子树、右子树都是二叉搜索树，以及当前节点的值大于左子树的最大值，小于右子树的最小值。</p><p>这样，我们定义一个函数，其返回值是<strong>当前子树的最小值和最大值</strong>，用作比较目的。我们定义空子树的最小值为正无穷大，最大值为负无穷大，这样一定能够使得其父节点满足二叉搜索树性质，而且也为二叉搜索树。</p><p>然后，对于非空子树，我们先判断其是否满足二叉搜索树性质，如果不满足，则问题的答案就是<code>false</code>。如果满足，我们把更新当前子树的最大最小值。最小值设为左子树的最小值（和当前节点值对比，防止左节点为空），最大值设为右子树的最大值（同理对比当前节点）。</p><p>当递归完成时，我们就可以找到是否有子树不满足二叉搜索树性质，若全部满足则为二叉搜索树。</p><h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><p>可以看到，前一个方法需要经常创建最大最小值对，造成了一定的空间开销。</p><p>注意到二叉搜索树还有一个性质，也就是其中序遍历是单调序列。</p><p>如果我们利用二叉搜索树的性质，把函数的返回值设为<strong>当前子树是否为二叉搜索树</strong>，并记录前一个节点的值，通过中序遍历，我们就能判断是否为二叉搜索树。</p><p>具体过程见代码。</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归的题目我认为本质是这样的：<br>递归终止条件时是正确的，然后前一层在假设子问题正确后运用算法能保持正确性。类似于数学归纳法。</p><p>换一种说法就是：</p><ol><li><strong>递归终止条件的正确性</strong>：当问题规模缩小到最简单的情况时，递归能够直接给出正确的结果。</li><li><strong>递归关系的正确性</strong>：假设对更小规模的子问题的求解是正确的，通过递归关系能够正确地求解原问题。</li></ol><p>递归问题除了关注终止条件、子问题和当前问题的关系以外，我认为还需要关注递归函数<strong>返回了什么</strong>，<strong>参数是什么</strong>，维持了什么<strong>性质</strong>。从这些切入点入手，递归问题就更容易思考。</p><p>递归时的数据传递可以用<strong>返回值</strong>，<strong>参数</strong>或者<strong>全局变量</strong>。我认为能够利用递归性质时最好使用<strong>返回值</strong>。难以观察递归性质时可以用<strong>全局变量</strong>，但是全局变量会影响可读性和可维护性。参数更适合作为对函数外<strong>无影响</strong>的条件。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回：当前子树的最小、最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span>[] dfs(TreeNode node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">long</span>[]&#123;Long.MAX_VALUE, -Long.MAX_VALUE&#125;;</span><br><span class="line">        <span class="type">long</span>[] left = dfs(node.left);</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">1</span>] &gt;= node.val) ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">long</span>[] right = dfs(node.right); </span><br><span class="line">        <span class="keyword">if</span> (right[<span class="number">0</span>] &lt;= node.val) ans = <span class="literal">false</span>;</span><br><span class="line">        right[<span class="number">0</span>] = Math.min(left[<span class="number">0</span>], node.val);</span><br><span class="line">        right[<span class="number">1</span>] = Math.max(right[<span class="number">1</span>], node.val);</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">//中序遍历过程的前一个值，实际上就是小于当前值的第一个值。</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">pre</span> <span class="operator">=</span> -Long.MAX_VALUE;</span><br><span class="line">    <span class="comment">//能够判断该子树是否为二叉搜索树，最后pre为最右下节点的值（如果为二叉搜索树，则为该子树最大值）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"><span class="comment">//递归返回情况</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 保证左子树为二叉搜索树</span></span><br><span class="line">        <span class="keyword">if</span> (!isValidBST(root.left)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 保证左子树小</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt;= pre) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre = root.val;</span><br><span class="line">        <span class="comment">// 第一次比较值时，节点为右子树的最左下节点，会比较是否比当前节点值大</span></span><br><span class="line">        <span class="comment">// 保证右子树为二叉搜索树</span></span><br><span class="line">        <span class="keyword">if</span> (!isValidBST(root.right)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>399. 除法求值</title>
      <link href="/2025/03/21/399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/"/>
      <url>/2025/03/21/399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/evaluate-division/description/">399. 除法求值</a></p></blockquote><p>题目思路比较清晰，用BFS或者Floyd算法即可，但是有一些实现的小细节需要注意。</p><h1 id="浮点数精度问题"><a href="#浮点数精度问题" class="headerlink" title="浮点数精度问题"></a>浮点数精度问题</h1><p>Java存储浮点数由于使用的是二进制，在运算的时候可能会出现精度的累计误差。一个值可能应该等于0，但是因为浮点数的误差使得其值大于0，而被判定为路径存在。因此，我们设置一个阈值<code>1e-6</code>，把小于该与阈值的数都视为0，以防止误差的累积。</p><h1 id="图信息存储的细节"><a href="#图信息存储的细节" class="headerlink" title="图信息存储的细节"></a>图信息存储的细节</h1><p>一般情况下，图论相关的题目都会给定节点从1或者0开始，这样存储图不论用邻接矩阵或者邻接列表都很方便（用下标表示节点）。那如果节点的key值不是数字怎么办？</p><p>我们第一反应应该是建立key值和数字的映射，实际上这样处理就是可以的。使用一个HashMap来存储即可。</p><p>另外，图如果还要存储边权重信息，可以使用<code>pair</code>来作为图的属性。s</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="type">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="comment">//图不是用123来表示节点，如何存储？用哈希表映射。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> values.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nvars</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;String, Integer&gt; variables = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; equation: equations) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> equation.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> equation.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!variables.containsKey(a)) &#123;</span><br><span class="line">                variables.put(a, nvars++); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!variables.containsKey(b)) &#123;</span><br><span class="line">                variables.put(b, nvars++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Pair&lt;Integer, Double&gt;&gt;[] graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[nvars];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nvars; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> variables.get(equations.get(i).get(<span class="number">0</span>));</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> variables.get(equations.get(i).get(<span class="number">1</span>));</span><br><span class="line">            graph[a].add(<span class="keyword">new</span> <span class="title class_">Pair</span>(b, values[i]));</span><br><span class="line">            graph[b].add(<span class="keyword">new</span> <span class="title class_">Pair</span>(a, <span class="number">1.0</span> / values[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span>[][] dist = <span class="keyword">new</span> <span class="title class_">double</span>[nvars][nvars];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nvars; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nvars; j++) &#123;</span><br><span class="line">                dist[i][j] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nvars; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; graph[i].size(); j++) &#123;</span><br><span class="line">                dist[i][graph[i].get(j).getKey()] = graph[i].get(j).getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nvars; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nvars; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nvars; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dist[i][k] &gt; <span class="number">1e-6</span> &amp;&amp; dist[k][j] &gt; <span class="number">1e-6</span>) dist[i][j] = dist[i][k] * dist[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span>[] ans = <span class="keyword">new</span> <span class="title class_">double</span>[queries.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; queries.size(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> variables.getOrDefault(queries.get(i).get(<span class="number">0</span>), -<span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> variables.getOrDefault(queries.get(i).get(<span class="number">1</span>), -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (a == -<span class="number">1</span> ||b == -<span class="number">1</span> || dist[a][b] == -<span class="number">1</span>) &#123;</span><br><span class="line">                ans[i] = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                ans[i] = dist[a][b];</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>452. 用最少数量的箭引爆气球</title>
      <link href="/2025/03/10/%E3%80%90%E5%8C%BA%E9%97%B4%E3%80%91452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/"/>
      <url>/2025/03/10/%E3%80%90%E5%8C%BA%E9%97%B4%E3%80%91452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/">452. 用最少数量的箭引爆气球</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题目可以利用贪心来建模为区间交集问题，假设分别将所有相交区间取交集，得到若干个交集，我们只需要往交集处射箭即可。这样问题就转为了求这样的交集数量。</p><blockquote><p>求区间交并集可以采用双指针的思路。</p></blockquote><p>我们可以用排序+双指针的方法来求解区间的交集。维护这样的循环不变量：<code>points的[p,q]区间内的点有共同的交集，其最大的交集的数值区间为[l, r]。</code></p><p>起初，<code>p</code>和<code>q</code>都设为<code>0</code>，并将<code>l</code>和<code>r</code>设置为该点的左右端点。这样循环不变量满足了初始化条件。</p><p>接下来是不变量的保持。因为我们把数组按区间左端点进行了排序，我们可以知道后面的点的左端点一定比前面的点大。这样判断是否有交集只需要判断后面点的左端点是否大于<code>p + 1</code>点的右端点。如果有交集，我们就尝试更新交集区间的左右端点，并尝试<code>q + 1</code>这个点。当没有交集时，我们就找到了所有与<code>p + 1</code>点有交集的点，将<code>ans</code>的值加一。</p><p>这样在循环结束时，我们就找到了所有点的交集个数，得到答案。</p><h1 id="线段树？"><a href="#线段树？" class="headerlink" title="线段树？"></a>线段树？</h1><p>为什么这题与区间相关，但是不用线段树呢？</p><p>首先，线段树是用来维护 <strong>区间信息</strong> 的数据结构。他能够在$O(logN)$的时间复杂度内实现<strong>单点</strong>修改、<strong>区间</strong>修改、<strong>区间</strong>查询（区间<strong>求和</strong>，求区间<strong>最大值</strong>，求区间最小值）等操作。</p><p>而本题需要更改区间附带的信息，因此不用线段树。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findMinArrowShots(int[][] points) &#123;</span><br><span class="line">        //直接用减法可能会溢出</span><br><span class="line">        Arrays.sort(points, (int[] a, int[] b) -&gt; Integer.compare(a[0], b[0]));</span><br><span class="line">        int n = points.length;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        //[p, q]内的点有共同交集,最大交集为[l, r]</span><br><span class="line">        for (int p = 0, q = 0; p &lt; n; q++, p = q) &#123;</span><br><span class="line">            int l = points[p][0];</span><br><span class="line">            int r = points[p][1];</span><br><span class="line">            while (q + 1 &lt; n &amp;&amp; points[q + 1][0] &lt;= r) &#123;</span><br><span class="line">                l = points[q + 1][0];</span><br><span class="line">                r = Math.min(points[q + 1][1], r);</span><br><span class="line">                q++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>25. K 个一组反转链表</title>
      <link href="/2025/03/05/25-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2025/03/05/25-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/">25. K 个一组翻转链表</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>本题的主要思想和反转链表相同，但是多了很多细节处理。</p><p>首先，最后剩余的节点无需反转（起初我写成剩余节点也反转的了）。</p><p>然后，由于是一组一组的反转链表，不要忘了在每一组反转完链表后，把上一组的尾节点连接到这一组链表的头节点上。</p><p>以及，最后返回的头节点也不再是起初的头节点，因此我们可以用一个哑节点来辅助，最后返回哑节点的下一个节点即可。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">lastq</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> p;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; (n / k); j++) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">q</span> <span class="operator">=</span> p;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">h</span> <span class="operator">=</span> p;</span><br><span class="line">            p = p.next;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                q.next = p.next;</span><br><span class="line">                p.next = h;</span><br><span class="line">                h = p;</span><br><span class="line">                p = q.next;</span><br><span class="line">            &#125;</span><br><span class="line">            lastq.next = h;</span><br><span class="line">            lastq = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>206. 反转链表</title>
      <link href="/2025/03/03/%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2025/03/03/%E3%80%90%E9%93%BE%E8%A1%A8%E3%80%91206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/reverse-linked-list/description/">206. 反转链表</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这是一道非常经典的链表题。如果对链表的使用不熟悉，第一印象可能是开一个数组来存反转后的链表，然后再拼接起来。但是这样需要多开$O(n)$的内存。实际上，利用链表的性质，可以只用$O(1)$的内存，并且在不增加时间复杂度的情况下反转链表。</p><p>为了完成这个操作，我们需要多利用一个指针，即使用双指针。其中左指针指向已经翻转的链表的最后一个元素，右指针指向未被反转的第一个元素。</p><p>这样，我们每次只需要把右指针移向头，并相应地更改他们的next指针，然后把左指针指向右指针的下一个元素即可。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">q</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            q.next = p.next;</span><br><span class="line">            p.next = head;</span><br><span class="line">            head = p;</span><br><span class="line">            p = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bfs和dfs的使用场景</title>
      <link href="/2025/02/28/bfs%E5%92%8Cdfs%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2025/02/28/bfs%E5%92%8Cdfs%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>在做力扣<a href="https://leetcode.cn/problems/word-ladder/description/">127. 单词接龙</a>的时候，起初我尝试了使用DFS搜索，但是会超时，于是想到使用记忆化DFS搜索，但是总会有几个用例错误，思考后发现，记忆化DFS只能找到当前<strong>某些点已经访问过的前提</strong>下当前点的最短路径，而不是全局最短路径，因此难以进行记忆化搜索。 </p><p>这时才想到，在算法课上，除了DFS，实际上常常用<strong>BFS</strong>来求解图中的最短距离。换完BFS后果然代码简单了很多。</p><p>DFS和BFS的使用场景有以下不同：</p><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><ol><li>适合于需要<strong>遍历所有解空间</strong>的情况。</li><li>使用<strong>回溯</strong>，适合于解<strong>递归</strong>的题目。</li><li>可以用记忆化搜索剪枝。</li><li>空间复杂度较小（树高）</li></ol><h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><ol><li>适合于求解<strong>最短路径</strong>问题。</li><li>适合于求解<strong>分层处理</strong>的问题。</li><li>空间复杂度较大（树宽度）。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>289. 生命游戏</title>
      <link href="/2025/02/28/289-%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/"/>
      <url>/2025/02/28/289-%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/game-of-life/description/">289. 生命游戏</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>用<code>O(1)</code>的额外空间来解决这个问题，关键是利用现有的空间，使用额外的<strong>状态标志</strong>来标记现在、以前的状态。</p><p>如何利用现有的空间？有的题目可以压缩数组状态，本题有点类似于脑筋急转弯，给定的类型是<code>int</code>而原状态只有两个，因此我们可以利用int的空间来额外存储更多的状态。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gameOfLife</span><span class="params">(<span class="type">int</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="comment">// 题目提供的是int类型，而原状态只有01，因此可以多定义几个状态。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> -<span class="number">1</span>; p &lt; <span class="number">2</span>; p++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> -<span class="number">1</span>; q &lt; <span class="number">2</span>; q++) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> i + p;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> j + q;</span><br><span class="line">                        <span class="keyword">if</span> (row &gt;= <span class="number">0</span> &amp;&amp; row &lt; n &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; m &amp;&amp; !(p == <span class="number">0</span> &amp;&amp; q == <span class="number">0</span>) &amp;&amp; Math.abs(board[row][col]) == <span class="number">1</span>) &#123;</span><br><span class="line">                            count++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((count &lt; <span class="number">2</span> || count &gt; <span class="number">3</span>) &amp;&amp; board[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    board[i][j] = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">3</span> &amp;&amp; board[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;        </span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == -<span class="number">1</span>) board[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="number">2</span>) board[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>71. 简化路径</title>
      <link href="/2025/02/27/71-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/"/>
      <url>/2025/02/27/71-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/simplify-path/description/">71. 简化路径</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>本题应该要想到用<strong>栈</strong>来解决。因为问题的关键在于<code>..</code>上一级目录的处理，需要取消掉上一个保存的元素，这样自然可以想到<strong>后到先出</strong>的栈结构。</p><p>另外一点是分词的处理。对于路径，我们需要提取路径中按<code>/</code>分隔的所有字符组。实际上Java的String类有split的操作，我们只需要按照<code>/</code>分词即可。如果不用split，那么我们遇到<code>/</code>时跳过，并用Stringbuilder也可以达到相同的效果。</p><p>同样，Java也有<code>join</code>操作，可以简化拼接的代码量。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simplifyPath</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> path.length();</span><br><span class="line">        <span class="type">char</span>[] cs = path.toCharArray();</span><br><span class="line">        <span class="comment">//Java String有Split操作和join操作</span></span><br><span class="line">        Deque&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (q &lt; n) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">if</span> (cs[q] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                q++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (q &lt; n &amp;&amp; cs[q] != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                sb.append(cs[q]);</span><br><span class="line">                q++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">            <span class="keyword">if</span> (s.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;..&quot;</span>.equals(s)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty()) stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="string">&quot;.&quot;</span>.equals(s)) &#123;</span><br><span class="line">                stack.push(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            sb.append(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            sb.append(stack.pollLast());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        <span class="keyword">if</span> (ans.isEmpty()) &#123;</span><br><span class="line">            ans = <span class="string">&quot;/&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript对返回的http包数据类型的判断</title>
      <link href="/2025/02/18/JavaScript%E5%AF%B9%E8%BF%94%E5%9B%9E%E7%9A%84http%E5%8C%85%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%A4%E6%96%AD/"/>
      <url>/2025/02/18/JavaScript%E5%AF%B9%E8%BF%94%E5%9B%9E%E7%9A%84http%E5%8C%85%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<p>遇到一个后端使用雪花ID，返回ID给前端时，前端解析的ID与Http包的内容不一致的问题。</p><p>经过排查，可以看到结果的类型被Javascript解析成了number。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两条log记录</span></span><br><span class="line"><span class="title class_">Save</span> <span class="title class_">Response</span>: </span><br><span class="line"><span class="title class_">Object</span> &#123; <span class="attr">data</span>: <span class="number">1891767091295240200</span>, <span class="attr">status</span>: <span class="number">200</span>, <span class="attr">statusText</span>: <span class="string">&quot;OK&quot;</span>, <span class="attr">headers</span>: &#123;…&#125;, <span class="attr">config</span>: &#123;…&#125;, <span class="attr">request</span>: <span class="title class_">XMLHttpRequest</span> &#125;</span><br><span class="line"><span class="attr">config</span>: <span class="title class_">Object</span> &#123; <span class="attr">url</span>: <span class="string">&quot;/api/books&quot;</span>, <span class="attr">method</span>: <span class="string">&quot;post&quot;</span>, <span class="attr">data</span>: <span class="string">&#x27;&#123;&quot;name&quot;:&quot;sdassssss&quot;,&quot;author&quot;:&quot;&quot;,&quot;isbn&quot;:&quot;&quot;,&quot;publishDate&quot;:&quot;2025-02-18 16:29:46&quot;,&quot;category&quot;:&quot;&quot;,&quot;introduction&quot;:&quot;&quot;,&quot;total&quot;:&quot;&quot;,&quot;stock&quot;:&quot;&quot;,&quot;imageUrl&quot;:&quot;&quot;,&quot;id&quot;:&quot;&quot;&#125;&#x27;</span>, … &#125;</span><br><span class="line"><span class="attr">data</span>: <span class="number">1891767091295240200</span></span><br><span class="line"><span class="attr">headers</span>: <span class="title class_">Object</span> &#123; <span class="string">&quot;cache-control&quot;</span>: <span class="string">&quot;no-cache, no-store, max-age=0, must-revalidate&quot;</span>, <span class="attr">connection</span>: <span class="string">&quot;close&quot;</span>, <span class="string">&quot;content-length&quot;</span>: <span class="string">&quot;19&quot;</span>, … &#125;</span><br><span class="line"><span class="attr">request</span>: <span class="title class_">XMLHttpRequest</span> &#123; <span class="attr">readyState</span>: <span class="number">4</span>, <span class="attr">timeout</span>: <span class="number">100000</span>, <span class="attr">withCredentials</span>: <span class="literal">true</span>, … &#125;</span><br><span class="line"><span class="attr">status</span>: <span class="number">200</span></span><br><span class="line"><span class="attr">statusText</span>: <span class="string">&quot;OK&quot;</span></span><br><span class="line">&lt;prototype&gt;: <span class="title class_">Object</span> &#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Data</span> <span class="title class_">Type</span>: <span class="title class_">Number</span></span><br></pre></td></tr></table></figure><p>原因是，因为data里只有数字字符，使用Json.parse解析会自动解析成Number类型。而雪花ID是64位的长整数，超出了Javascript的安全整数范围（其安全整数范围是<code>-2^53 + 1</code>到<code>2^53 - 1</code>），解析成Number类型时就可能会出错。</p><p>将整个对象返回，而不仅仅是返回一串数字字符就可以初步解决这个问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前后端系统图片处理</title>
      <link href="/2025/02/18/%E5%89%8D%E5%90%8E%E7%AB%AF%E7%B3%BB%E7%BB%9F%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/"/>
      <url>/2025/02/18/%E5%89%8D%E5%90%8E%E7%AB%AF%E7%B3%BB%E7%BB%9F%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>项目需求要保存图书封面到系统中。我们把这个问题Divide and Conquer。</p><p>首先是图片如何在后端存储？一个朴素的想法是直接把上传的图片以<strong>二进制的形式</strong>直接保存到MySql数据库中。但是这样做的话数据库的体积会大幅增大，可能会影响数据库性能，而且图片的管理不够灵活。因此一个更优解是只在数据库中存储图片文件在本地的<strong>路径</strong>，然后把上传的图片存储在本地的文件管理系统中。这样不仅数据库轻量化易于维护，而且图片管理灵活，可以自由切换位置，实现了解耦。</p><p>接着是后端如何接收图片？以Spring Boot为例，我们在Controller中撰写以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;upload&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">uploadImage</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file, String id)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (file.isEmpty()) &#123;  </span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;上传失败，请选择文件&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.randomUUID().toString() + <span class="string">&quot;_&quot;</span> + file.getOriginalFilename();  </span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> localPath + fileName;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        file.transferTo(<span class="keyword">new</span> <span class="title class_">java</span>.io.File(filePath));  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">        e.printStackTrace();  </span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;上传失败&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> bookService.getById(id);  </span><br><span class="line">    book.setImageUrl(<span class="string">&quot;http://localhost:8082/images/&quot;</span> + fileName);  </span><br><span class="line">    bookService.updateById(book);  </span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;上传成功&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是前端上传图片。在Vue前端需要一个<code>el-upload</code>组件。其中http-request会屏蔽掉action，可以实现点击确认后和图书属性一起上传。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-upload v-else-if=&quot;item.prop === &#x27;imageUrl&#x27;&quot; :http-request=&quot;upload&quot; action=&quot;#&quot; drag accept=&quot;image/*&quot; :auto-upload=&quot;true&quot; :limit=&quot;1&quot;&gt;</span><br><span class="line">&lt;i class=&quot;el-icon-upload&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;div class=&quot;el-upload__text&quot;&gt;将文件拖到此处，或&lt;em&gt;点击上传&lt;/em&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;el-upload__tip&quot; slot=&quot;tip&quot;&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt;</span><br><span class="line">&lt;/el-upload&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">upload</span> (options)&#123;</span><br><span class="line">    <span class="comment">// 上传图片，把图片保存到cover成员中</span></span><br><span class="line"><span class="keyword">const</span> formdata = <span class="keyword">new</span> <span class="title class_">FormData</span>()</span><br><span class="line">formdata.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>, options.<span class="property">file</span>)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">cover</span> = formdata</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doSubmit</span> () &#123;</span><br><span class="line"><span class="comment">// 上传图片</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">BookService</span>.<span class="title function_">upload</span>(<span class="variable language_">this</span>.<span class="property">cover</span>, <span class="variable language_">this</span>.<span class="property">inputForm</span>.<span class="property">id</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">inputForm</span>.<span class="property">imageUrl</span> = data</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&#x27;上传成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"><span class="title function_">upload</span> (formData, id) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/books/upload&#x27;</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: formData,</span><br><span class="line">  <span class="attr">params</span>: &#123;<span class="attr">id</span>: id&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是前端显示保存的图片。由于浏览器后端<strong>不能</strong>直接从文件系统访问图片，我们需要使用Springboot后端静态代理图片。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置静态资源路径</span></span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/images/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;file:D:/images/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样只需要在前端使用<code>img</code>指定<code>src</code>来访问图片即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis-plus字段大小写的小坑</title>
      <link href="/2025/02/17/Mybatis-plus%E5%AD%97%E6%AE%B5%E5%A4%A7%E5%B0%8F%E5%86%99%E7%9A%84%E5%B0%8F%E5%9D%91/"/>
      <url>/2025/02/17/Mybatis-plus%E5%AD%97%E6%AE%B5%E5%A4%A7%E5%B0%8F%E5%86%99%E7%9A%84%E5%B0%8F%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>今天在写图书类后端时，发现<code>ISBN</code>这个字段一直报空，但是前端发出的请求中<code>ISBN</code>字段是存在的，后来看到报错信息，Mybatis-plus把<code>ISBN</code>这个类成员解析成了<code>i_s_b_n</code>这个数据库字段。</p><p>MyBatis-plus对于Java对象字段到数据库列名的解析，是把大写解析成<code>_</code>加上对应的小写字符，所以用Mybatis-plus在Java后端写字段时不能随意使用大写。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL初始化数据库</title>
      <link href="/2025/02/16/MySQL%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2025/02/16/MySQL%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>项目需求，给定一个SQL脚本，要使用这个脚本初始化项目数据库。</p><p>首先，MySQL的初始账号和密码都是<code>root</code>。</p><p>起初，我使用DBeaver来执行SQL语句，但是执行的时候会出现语法错误的warning，后面甚至出现了error。</p><p>于是我尝试直接使用MySQL终端来执行脚本，以排除DBeaver错误的可能性。</p><p>在Windows下使用MySQL终端，要用到以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#首先打开mysql console</span><br><span class="line"></span><br><span class="line">USE &#x27;数据库名&#x27;</span><br><span class="line">SOURCE &#x27;.sql脚本地址&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用MySQL终端后就没有报错。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.盛最多水的容器</title>
      <link href="/2025/02/14/%E3%80%90%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%9111-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
      <url>/2025/02/14/%E3%80%90%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%9111-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/container-with-most-water/description/">11. 盛最多水的容器</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>本题采用双指针的思路。</p><p>一开始我尝试了动态规划，但是发现难以构建最优子结构。<br>然后我也试着用双指针，但是对于双指针的理解还不够，所以没有想到双指针也可以从<strong>数组的两端</strong>开始，相向移动。</p><p>双指针最重要的是要维护一个<strong>区间信息</strong>。当我们把指针从数组的两边移动时，可以维护一个什么信息？</p><p><strong>这个区间里的的所有的点都可以作为容器的边界</strong>。换言之，区间外的点就不值得作为容器边界尝试了。</p><p>我们每次都移动高度较小的指针，因此我们这里需要证明，这个高度较小的指针不再可能作为容器的边界，产生一个更高的答案值了。</p><p>如果我们不移动这个高度较小的指针，而把它作为左边界，从而右指针可以取小于等于右边界的任何值。首先横轴的距离在不断减小，其次由于左指针的值小于等于右指针的最初的值，以为着容器的盛水高度在右指针最初时就已经达到了理论最大值（左指针的值），移动右指针已经无用。因此，我们证明了左指针的位置已经不再可能产生更高的盛水量，左指针可以向右移动。</p><h1 id="双指针理解"><a href="#双指针理解" class="headerlink" title="双指针理解"></a>双指针理解</h1><p>从这题我们可以看出，双指针，尤其是相向双指针，其很大一个作用是进行<strong>搜索的剪枝</strong>。我们利用题目性质排除了不可能的点，因此可以把时间复杂度从$O(N^2)$降低到$O(N)$。接着做双指针的题目，再来继续强化理解。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            ans = Math.max((r - l) * Math.min(height[l], height[r]),ans);</span><br><span class="line">            <span class="keyword">if</span> (height[l] &lt; height[r]) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4. 寻找两个正序数组的中位数</title>
      <link href="/2025/01/27/%E3%80%90%E5%88%86%E6%B2%BB%E3%80%914-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2025/01/27/%E3%80%90%E5%88%86%E6%B2%BB%E3%80%914-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/description/">4. 寻找两个正序数组的中位数</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>一开始看到这道题，我想到的是利用快速排序的分区操作来找出数组第<code>k</code>大元素这个操作，但是使用朴素算法实际上需要$O(N)$的时间复杂度，而且没有利用到数组已经正序这个信息。</p><p>要利用数组已经正序的信息，我们可以想到中位数一定是合并起来数组的第<code>n/2</code> 个元素或第<code>n/2</code>和第<code>n/2 + 1</code>个元素的平均值。我们的任务转为了求出求出这两个有序数组中的第<code>k</code>大的元素，即第<code>k</code>个元素。</p><p>考虑到需要$O(N)$的时间复杂度，自然而然需要用到分治或者二分的思想。我们可以参考分区操作找出第<code>k</code>大元素的思想，逐渐排除一部分元素，直到问题规模小到可以直接解决为止。</p><p>这里就需要用一点小trick了。我们的目标是要找到第<code>k</code>个元素，出于分治考虑，我们考察两个数组各自的第<code>k/2</code>个元素（不足则取最大的那个），比较它们的大小，较小的记为<code>a</code>，另一个记为<code>b</code>。显然，这两个元素加上之前的元素总的元素个数小于等于<code>k</code>个，那么就可以分几种情况考虑：</p><ol><li>如果<code>k</code>较大（不在边界情况），那么我们知道<code>a</code>左边的数都小于它本身，又小于<code>b</code>，所以<code>a</code>左边的数都不可能是第<code>k</code>大的数。所以我们去掉这个范围，并修改现在的<code>k</code>值。至于<code>b</code>左边的数，我们仍无法直接判断，因为还要考虑到<code>a</code>右边的数。</li><li>如果一个数组已经空了，那么另一个数组的第<code>k</code>个数就是我们要找的数。</li><li>如果<code>k</code>已经等于<code>1</code>了，那么我们<code>a</code>就是我们要找的数。</li></ol><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> nums1.length, length2 = nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> length1 + length2;</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midIndex</span> <span class="operator">=</span> totalLength / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>) getKthElement(nums1, nums2, midIndex + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midIndex1</span> <span class="operator">=</span> totalLength / <span class="number">2</span> - <span class="number">1</span>, midIndex2 = totalLength / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>)(getKthElement(nums1, nums2, midIndex1 + <span class="number">1</span>) + getKthElement(nums1, nums2, midIndex2 + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getKthElement</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> nums1.length, length2 = nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">kthElement</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index1 == length1) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == length2) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.min(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> k / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newIndex1</span> <span class="operator">=</span> Math.min(index1 + half, length1) - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newIndex2</span> <span class="operator">=</span> Math.min(index2 + half, length2) - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot1</span> <span class="operator">=</span> nums1[newIndex1], pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= (newIndex1 - index1 + <span class="number">1</span>);</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= (newIndex2 - index2 + <span class="number">1</span>);</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>202. 快乐数</title>
      <link href="/2025/01/26/%E3%80%90%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E3%80%91202-%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
      <url>/2025/01/26/%E3%80%90%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E3%80%91202-%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/happy-number/description/">202. 快乐数</a></p></blockquote><h1 id="数学规律"><a href="#数学规律" class="headerlink" title="数学规律"></a>数学规律</h1><p>本题中，虽然可以很容易想到要检测是否出现环，但是实际上还应该考虑到，会不会出现<strong>无限发散</strong>的情况。</p><p>由于每个位置上都填9是给定位数下的最大值，我们从少位到多位依次检验，可以发现到了999之后，会回到243这个值，意味着如果从1开始，数不可能大于999。</p><p>而给定的数据范围是十的九次方数量级，当有10个9时，其位数平方和可得不会大于810。因此在题目给定的输入内，我们可以知道除了给定数，其他得到的数不会超过999。</p><p>知道了这个，我们就可以开辟一个固定空间的数组来作为哈希表，比使用动态哈希表时间要少。</p><h1 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h1><p>前面我们使用哈希表是为了检验有没有重复出现的数，而本题的数据结构类似于一个没有空间存储的链表，需要检测有没有环。用到<strong>快慢指针</strong>的思想，我们可以用来检测链表是否有环出现。</p><p>具体来说，我们设定一个快跑者和一个慢跑者，快跑者每次跑两步，慢跑者每次跑一步，已知他们会沿着同样的赛道奔跑（用同一个函数求得链表的下一个值），如果跑道有环，那么他们肯定会在某一时刻相遇，否则快跑者会先完成。我们在快跑者到达1或者他们相遇时结束循环。</p><p>这样我们最后只需要检测快跑者是否到达1即可。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!s.contains(n)) &#123;</span><br><span class="line">            s.add(n);</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">                next += v * v;</span><br><span class="line">                n /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n = next;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>73.矩阵置0</title>
      <link href="/2025/01/25/73-%E7%9F%A9%E9%98%B5%E7%BD%AE0/"/>
      <url>/2025/01/25/73-%E7%9F%A9%E9%98%B5%E7%BD%AE0/</url>
      
        <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>遇到需要O(1)的解法，要考虑到能不能用上给定数组的空间。<br>不要一口吃成胖子，慢慢从O(m + n)考虑到O(1)</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rowZero</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">colZero</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                colZero = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                rowZero = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">0</span> || matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rowZero) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (colZero) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程常见数</title>
      <link href="/2025/01/25/%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E6%95%B0/"/>
      <url>/2025/01/25/%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>因为在做力扣的时候经常遇到需要考虑数据最大范围的情况，这里把这些数据记录下来，加以记忆。</p><p>$2^{32}&#x3D;4,294,967,296&#x3D;4.29*10^9$：无符号int。<br>$2,147,483,647$：有符号int取一半。</p><p>$2^{64}&#x3D;18,446,744,073,709,551,616&#x3D;1.844×10^{19}$，无符号long。<br>$9,223,372,036,854,775,807&#x3D;9.223×10^{18}$，有符号long。</p><p>$2^{16}&#x3D;65536&#x3D;6.5*10^4$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>149. 直线上最多的点数</title>
      <link href="/2025/01/22/149-%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/"/>
      <url>/2025/01/22/149-%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/max-points-on-a-line/description/">149. 直线上最多的点数</a></p></blockquote><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>不要有<code>HashMap</code>全局只能有一个的惯性思维，例如本题就需要把哈希表定义为从某一点出发的每个斜率个数。</p><p>浮点数除法可能会有精度问题，例如0除以不同的数不一定都得0，至少需要在分母0也做一个特判，亦或使用分数表示或者叉积表示，叉积等于0两个直线共线。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">INF</span> <span class="operator">=</span> <span class="number">1000000.0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> points.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="type">double</span> rate1;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>] == <span class="number">0</span>) rate1 = INF;</span><br><span class="line">                <span class="keyword">else</span> rate1 = (<span class="type">double</span>)(points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]) / (points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k != j &amp;&amp; k != i) &#123;</span><br><span class="line">                        <span class="type">double</span> rate2;</span><br><span class="line">                        <span class="keyword">if</span> (points[i][<span class="number">1</span>] - points[k][<span class="number">1</span>] == <span class="number">0</span>) rate2 = INF;</span><br><span class="line">                        <span class="keyword">else</span> rate2 = (<span class="type">double</span>)(points[i][<span class="number">1</span>] - points[k][<span class="number">1</span>])/ (points[i][<span class="number">0</span>] - points[k][<span class="number">0</span>]);</span><br><span class="line">                        <span class="keyword">if</span> (rate1 == rate2) sum++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = Math.max(sum, ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>48.旋转图像</title>
      <link href="/2025/01/22/%E3%80%90%E6%95%B0%E5%AD%A6%E3%80%9148-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
      <url>/2025/01/22/%E3%80%90%E6%95%B0%E5%AD%A6%E3%80%9148-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/rotate-image/description/">48. 旋转图像</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>遇到矩阵的题目，就可以联想到数学上的矩阵性质，以及<code>转置</code>操作等。<br>矩阵的题目要想到可以一列一列看，或者一行一行看，而不只是看着一个局部点。</p><p>本题中，可以观察到第<code>i</code>行的第<code>j</code>个元素在旋转后会在第<code>j</code>行第<code>n - 1 - i</code>列。因此我们可以通过先把矩阵转置，然后反向输出的方法来完成。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><pre><code class="Java">class Solution &#123;    public void rotate(int[][] matrix) &#123;        int n = matrix.length;        int m = matrix[0].length;        for (int i = 0 ; i &lt; n; i++) &#123;            for (int j = i + 1; j &lt; m; j++) &#123;                int temp = matrix[i][j];                matrix[i][j] = matrix[j][i];                matrix[j][i] = temp;            &#125;        &#125;        for (int i = 0; i &lt; n; i++) &#123;            for (int j = 0; j &lt; m / 2; j++) &#123;                int temp = matrix[i][j];                matrix[i][j] = matrix[i][m - j - 1];                matrix[i][m - j - 1] = temp;            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法分析与设计课程</title>
      <link href="/2025/01/05/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B/"/>
      <url>/2025/01/05/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>这一段时间都没有更新力扣，因为在复习算法分析与实践课程。教材是算法导论，和本科课程的区别在于，这次的研究生课程多加入了对算法复杂度的分析内容。</p><p>比如，课程讲解了时间复杂度的三种表示方式，以及如何用主方法、递归树法和替换法来求解递归函数时间表达式。另外，指示随机变量也是一种很好的用来分析随机化函数的时间期望的方法。</p><p>课程对基于比较和非比较的排序算法都进行了详细的讲解，包括其复杂度分析和为什么基于比较的算法有O(nlogn)的下界。</p><p>对于某个数据结构多种操作在多个操作下的时间复杂度，课程讲解了摊还分析的方法。可以使用聚合法、核算法和势能法来进行求解。</p><p>课程也详细讲解了红黑树，尤其是红黑树的性质和插入方法。</p><p>课程也讲解了最大流问题，包括最大流最小割，残差网络和增广路径。</p><p>最后，课程以NP问题结尾，为我们讲解了经典的3sat问题，以及NP问题的规约。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>3138-同位字符串连接的最小长度</title>
      <link href="/2024/12/20/3138-%E5%90%8C%E4%BD%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%9C%80%E5%B0%8F%E9%95%BF%E5%BA%A6/"/>
      <url>/2024/12/20/3138-%E5%90%8C%E4%BD%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%9C%80%E5%B0%8F%E9%95%BF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这题看似暴力求解会超时，实际上只要我们遍历长度的<strong>因子</strong>，就可以把数量级缩小到不会超时的程度。</p><blockquote><p>因子个数为$O(logn)$个</p></blockquote><h1 id="Java语法"><a href="#Java语法" class="headerlink" title="Java语法"></a>Java语法</h1><blockquote><p>快速复制数组，比较数组</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.copyOf(a, n);</span><br><span class="line">Arrays.equals(a, b);</span><br></pre></td></tr></table></figure><blockquote><p>力扣字符串命名技巧</p></blockquote><p>可以把参数的<code>s</code>改为大写的<code>S</code>，然后再把字符串数组的设为s，这样使用代码补全时更方便。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minAnagramLength</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> set[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">char</span> cs[] = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            set[cs[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span> (n % (i + <span class="number">1</span>) != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j += (i + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="type">int</span>[] temp = Arrays.copyOf(set, <span class="number">26</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j; k &lt; j + i + <span class="number">1</span>; k++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> cs[k] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                    temp[pos]--;</span><br><span class="line">                    <span class="keyword">if</span> (temp[pos] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        success = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (success == <span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (success) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3291.形成目标字符串需要的最少字符串数 I</title>
      <link href="/2024/12/19/%E3%80%90Trie%E6%A0%91%EF%BC%8Cdp%E3%80%913291-%E5%BD%A2%E6%88%90%E7%9B%AE%E6%A0%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0-I/"/>
      <url>/2024/12/19/%E3%80%90Trie%E6%A0%91%EF%BC%8Cdp%E3%80%913291-%E5%BD%A2%E6%88%90%E7%9B%AE%E6%A0%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0-I/</url>
      
        <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>第一点的做题的总体方向，起初想到的是搜索，实际上可以用dp。</p><blockquote><p>当想到用（记忆化）搜索时，就要想想能否使用dp。尤其是字符串的题目。</p></blockquote><p>想到用dp后，首先要构建dp数组。这题dp数组的含义是：前<code>i</code>个字符的子字符串中需要连接的最小字符串数量。这样求出<code>dp[n]</code>即可。</p><blockquote><p>字符串的最优子结构，通常可以考虑前i个字符的子串。</p></blockquote><p>然后是状态转移方程，我们知道了<code>dp[i]</code>，如果接下来到<code>j</code>为止的若干个字符可以构成某个前缀，则<code>dp[j] = min(dp[j], dp[i] + 1)</code>。</p><blockquote><p>dp中不一定是用<code>dp[i]</code>推出<code>dp[i + 1]</code>，其下标的变化可以很广泛。反之同理。</p></blockquote><p>为什么我们不需要考虑当前字符要连接前面字符形成一个更长前缀的情况呢？因为如果当前字符可以连接，那么这个位置的<code>dp</code>值一定在之前就已经求出来，无需更新；反之，则用我们的算法就可以更新这个值。</p><blockquote><p>这里的思想是我没有想到的，非常重要的一个思想。印象中在很多字符串的问题都适用。<strong>dp只向前看</strong>。</p></blockquote><p>接下来我们要解决的问题就剩下如何快速判断一个字符串是不是已知字符串集合中的某个前缀了。正好，这个需求和我们之前学过的前缀树完全一致。</p><p>使用前缀树时有个小细节，由于前缀树查询有<code>O(n)</code>的时间复杂度，我们尽量不多次查询前缀树，因此我们可以<strong>通过前缀树找出能匹配的最长前缀长度</strong>，这样就只需要一次<code>O(n)</code>的查询，有了这个小优化才能通过。这样也省去了构建String的复杂度。</p><blockquote><p>将逐步构建String改为求出匹配的最长前缀。</p></blockquote><h1 id="Java语言知识点"><a href="#Java语言知识点" class="headerlink" title="Java语言知识点"></a>Java语言知识点</h1><blockquote><p>Java数组快速赋值：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.fill(a, <span class="number">0</span>);</span><br><span class="line">Arrays.setAll(a, i -&gt; i);</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Trie[] children;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(String prefix, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - start;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix.length() - start;</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minValidStrings</span><span class="params">(String[] words, String target)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs = target.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cs.length;</span><br><span class="line">        <span class="type">int</span> dp[] = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span> (String s : words) &#123;</span><br><span class="line">            t.insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> t.search(target, i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">0</span> &amp;&amp; dp[i] == Integer.MAX_VALUE) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; i + len; j++) &#123;</span><br><span class="line">                dp[j] = Math.min(dp[j], dp[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1837.最近的房间</title>
      <link href="/2024/12/16/%E3%80%90%E7%A6%BB%E7%BA%BF%E3%80%911847-%E6%9C%80%E8%BF%91%E7%9A%84%E6%88%BF%E9%97%B4/"/>
      <url>/2024/12/16/%E3%80%90%E7%A6%BB%E7%BA%BF%E3%80%911847-%E6%9C%80%E8%BF%91%E7%9A%84%E6%88%BF%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这题一开始我只想到了把<code>rooms</code>数组排序，但是没有想到实际上还可以对<strong>查询数组</strong>进行排序。这是一种<strong>离线</strong>的做法，因为我们已经<strong>知道了所有的输入数据</strong>，就不用像数据是在线的那样受到限制，可以自由地处理输入数据。</p><p>看到这一点后，我也想到了将查询数组和<code>rooms</code>数组都按<code>minSize</code>排序，我们就可以在查询时维护这样一个性质：后面的查询范围<strong>包括了</strong>前面的查询范围，并且查询范围是从<code>0</code>逐步递增到<code>rooms</code>长度的。也就是我们可以对两个数组分别用一个指针来表示这个子范围。</p><p>当时想到这里就卡住了，没有想到如何在<code>logn</code>的时间内对无序的子范围内<code>roomID</code>进行查询。</p><p>其实，在数组中这的确是无序的，但是我们可以把它提取到一个有序的数据结构中！我们可以把子范围中的<code>roomId</code>再提出来到一个<code>TreeSet</code>中（红黑树），这样就可以用树维护<code>logn</code>时间的查询，这样问题就迎刃而解了。</p><blockquote><p>关键点：离线，将子规模数据放入另一个数据结构中，TreeSet</p></blockquote><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><blockquote><ol><li>Java中如何自定义数组排序？</li></ol></blockquote><p>在Arrays.sort中传入lambda表达式比较函数，其接收两个待比较元素，返回一个整数，大于0则前者大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(rooms, (a, b) -&gt; (a[<span class="number">1</span>] - b[<span class="number">1</span>]));</span><br></pre></td></tr></table></figure><blockquote><p>2.离线处理时遇到需要按序返回怎么办？</p></blockquote><p>朴素的想法是再开一个相同的数据结构，并补上序号这个标签，但是这样空间复杂度过高。</p><p>实际上我们只需要再开一个标签数组，并对这个标签数组排序即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer qs[] = <span class="keyword">new</span> <span class="title class_">Integer</span> [m];<span class="comment">//sort的lambda表达式需要一个对象类型</span></span><br><span class="line">Arrays.setAll(qs, i -&gt; i);<span class="comment">//快速初始化</span></span><br><span class="line">Arrays.sort(qs, (a, b) -&gt; (queries[b][<span class="number">1</span>] - queries[a][<span class="number">1</span>]));</span><br></pre></td></tr></table></figure><p>这题收获满满，是非常好的一道题。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] closestRoom(<span class="type">int</span>[][] rooms, <span class="type">int</span>[][] queries) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> rooms.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> queries.length;</span><br><span class="line">        Integer qs[] = <span class="keyword">new</span> <span class="title class_">Integer</span> [m];</span><br><span class="line">        Arrays.setAll(qs, i -&gt; i);</span><br><span class="line">        Arrays.sort(rooms, (a, b) -&gt; (a[<span class="number">1</span>] - b[<span class="number">1</span>]));</span><br><span class="line">        Arrays.sort(qs, (a, b) -&gt; (queries[b][<span class="number">1</span>] - queries[a][<span class="number">1</span>]));</span><br><span class="line">        TreeSet&lt;Integer&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minv</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> ans[] = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : qs) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pref</span> <span class="operator">=</span> queries[j][<span class="number">0</span>]; </span><br><span class="line">            <span class="type">int</span> <span class="variable">ms</span> <span class="operator">=</span> queries[j][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; rooms[i][<span class="number">1</span>] &gt;= ms) &#123;</span><br><span class="line">                ts.add(rooms[i][<span class="number">0</span>]);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> ts.ceiling(pref);</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">f</span> <span class="operator">=</span> ts.floor(pref);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span> &amp;&amp; f == <span class="literal">null</span>) ans[j] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (f == <span class="literal">null</span>) ans[j] = c;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="literal">null</span>) ans[j] = f;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c - pref &gt;= pref - f) ans[j] = f;</span><br><span class="line">                <span class="keyword">else</span> ans[j] = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.两数之和</title>
      <link href="/2024/12/12/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2024/12/12/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>这题我一开始的做法是使用排序+双指针，但是这样需要花费O(nlogn)的时间。使用哈希表就能达到O(n)的时间。</p><p>因为本质上遍历数组时，我们需要的是数组里的哪一个数和它的和是某个值，换言之需要的是一个特定的数：<code>target - nums[i]</code>是否在数组中出现过。而又因为和有对称性，我们记录所有出现过的数到哈希表中，在之后遇到匹配的数时就可以以O(1)的时间找到。</p><p>哈希表的用处：存储键值对，并且能够以O(1)时间取出键值对，能够判断某个键是否存在。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; m = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, m.get(target - nums[i])&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            m.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2931.购买物品的最大开销</title>
      <link href="/2024/12/12/2931-%E8%B4%AD%E4%B9%B0%E7%89%A9%E5%93%81%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%80%E9%94%80/"/>
      <url>/2024/12/12/2931-%E8%B4%AD%E4%B9%B0%E7%89%A9%E5%93%81%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%80%E9%94%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Java实现”Pair”"><a href="#Java实现”Pair”" class="headerlink" title="Java实现”Pair”"></a>Java实现”Pair”</h1><p>首先我之前对Java泛型可用的类型理解比较模糊。Java泛型可以接受所有<strong>引用类型</strong>作为类型参数，也就以为着它仅仅不支持原始数据类型。于是，要实现<strong>Pair</strong>，只需要使用<strong>数组</strong>即可。</p><p>顺带学习一个知识点，由于<strong>类型擦除</strong>，Java泛型在实际运行时是不知道实际参数类型的，会被擦除成其他们的上界（默认为<strong>Object</strong>）。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxSpending</span><span class="params">(<span class="type">int</span>[][] values)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> values.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> values[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            q.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;values[i][n - <span class="number">1</span>], i , n - <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">all</span> <span class="operator">=</span> m * n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= all; i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] e = q.poll();</span><br><span class="line">            ans += (<span class="type">long</span>)e[<span class="number">0</span>] * i;</span><br><span class="line">            e[<span class="number">2</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (e[<span class="number">2</span>] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            e[<span class="number">0</span>] = values[e[<span class="number">1</span>]][e[<span class="number">2</span>]];</span><br><span class="line">            q.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>34. 在排序数组中查找元素的第一个和最后一个位置</title>
      <link href="/2024/12/11/%E3%80%90%E4%BA%8C%E5%88%86%E3%80%9134-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
      <url>/2024/12/11/%E3%80%90%E4%BA%8C%E5%88%86%E3%80%9134-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><p>在这题再加深二分法的理解：<br>首先，<strong>闭区间</strong>的二分法标志是：判定条件为<code>l &lt;= r</code>。在本题因为要求<code>lowerbound</code>，在循环时，维持循环不变量：<code>nums[l - 1] &lt; target</code>和<code>nums[r + 1] &gt;= target</code>。最后的下标为<code>left</code>。如果是求<code>upperbound</code>则最后的下标为<code>right</code>，并且循环不变量也跟着改变。</p><p>需要注意的点有几个。首先，在最后如果没有找到大于等于<code>target</code>的值，<code>l</code>会超过数组的右边界。而且，我们可以注意到循环不变量在一开始时似乎会越界，对此我们只需要想象成数组的左边界-1的值是负无穷大，右边界+1是正无穷大即可。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> []ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        ans[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        ans[<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> bs(nums, target);</span><br><span class="line">        <span class="keyword">if</span> (start &lt; nums.length &amp;&amp; nums[start] == target) ans[<span class="number">0</span>] = start;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> bs(nums, target + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        ans[<span class="number">1</span>] = end;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">bs</span><span class="params">(<span class="type">int</span> []nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>208. 实现 Trie (前缀树)</title>
      <link href="/2024/12/09/%E3%80%90Trie%E6%A0%91%E3%80%91208-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91/"/>
      <url>/2024/12/09/%E3%80%90Trie%E6%A0%91%E3%80%91208-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/implement-trie-prefix-tree/description/">208. 实现 Trie (前缀树)</a></p></blockquote><h1 id="字典树概念"><a href="#字典树概念" class="headerlink" title="字典树概念"></a>字典树概念</h1><p>首先，Trie树，也叫字典树或者前缀树，基础的应用就是可以用来检索字符串或者字符串前缀。为了实现这个功能，树上从根节点到叶子节点的<strong>路径</strong>定义为一个存储的字符串。这也提供了树状存储的一个新思路，除了用来维护<strong>子节点和父节点</strong>的关系，运用分治思想外，树状存储也可以利用<strong>路径</strong>信息。</p><h1 id="原先做法"><a href="#原先做法" class="headerlink" title="原先做法"></a>原先做法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node root;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">char</span> cs[] = word.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; word.length()) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">find</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node n: p.sub) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n.val == cs[index]) &#123;</span><br><span class="line">                    p = n;</span><br><span class="line">                    index++;</span><br><span class="line">                    find = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (index == word.length()) p.end = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (find) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span>(index &lt; cs.length) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(cs[index]);</span><br><span class="line">                p.sub.add(next);</span><br><span class="line">                p = next;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">if</span> (index == word.length()) p.end = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">find</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node n : p.sub) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n.val == word.charAt(i)) &#123;</span><br><span class="line">                    find = <span class="literal">true</span>;</span><br><span class="line">                    p = n;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!find) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.end == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">find</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node n : p.sub) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n.val == prefix.charAt(i)) &#123;</span><br><span class="line">                    find = <span class="literal">true</span>;</span><br><span class="line">                    p = n;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!find) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="做法改进"><a href="#做法改进" class="headerlink" title="做法改进"></a>做法改进</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Trie[] children;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">null</span> &amp;&amp; node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchPrefix(prefix) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Trie <span class="title function_">searchPrefix</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这个写法有时空效率上的改进。因为题目<strong>限定了</strong>给定词汇只由小写字母构成，而小写字母是连续的，我们可以直接用一个定长数组来表示26个字母，而不必开一个子列表。通过列表哈希可以减少查询时的一层for循环遍历。</p><p>另外，我的插入写法也存在问题，其实并不需要一个flag来标志，只需要每次在不存在该字符的时候插入即可，不需要分两段进行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19. 删除链表的倒数第 N 个结点</title>
      <link href="/2024/12/06/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
      <url>/2024/12/06/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="链表题的哨兵（dummy）"><a href="#链表题的哨兵（dummy）" class="headerlink" title="链表题的哨兵（dummy）"></a>链表题的哨兵（dummy）</h1><p>在单向链表题中，很容易遇到需要删除<strong>第一个</strong>元素的情况，这就要求了必须要特殊处理，因为第一个元素没有前置元素。</p><p>而设置了一个dummy之后，我们让第一个元素也获得了前置的元素，可以通过dummy来删除第一个元素。而dummy不参与链表，不会被删除，这就方便了代码的编写。</p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>77. 组合</title>
      <link href="/2024/12/03/77-%E7%BB%84%E5%90%88/"/>
      <url>/2024/12/03/77-%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/combinations/description/">77. 组合</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>回溯法，这里记录几个做回溯法的优化小tips。回溯时如果使用正向遍历，需要多传一个参数n；但是如果逆向遍历，并且数组从固定的数（如1）开始，n可以一开始就当作当前位置传过去，然后在回溯时遍历到0，减少一个参数。</p><p>另一个是，分析回溯问题的时间复杂度，有一个通用公式：<strong>路径长度</strong>×<strong>搜索树的叶子数</strong>。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(k⋅C(n,k))。</li><li>空间复杂度: $O(k)$</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(a, n, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;Integer&gt; now, <span class="type">int</span> index, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (now.size() == k) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(now));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            now.add(i);</span><br><span class="line">            dfs(now, i - <span class="number">1</span>, k);</span><br><span class="line">            now.remove(now.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>172. 阶乘后的零</title>
      <link href="/2024/12/03/%E3%80%90%E6%95%B0%E5%AD%A6%E3%80%91172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/"/>
      <url>/2024/12/03/%E3%80%90%E6%95%B0%E5%AD%A6%E3%80%91172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/factorial-trailing-zeroes/description/">172. 阶乘后的零</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>要求阶乘中0的个数，就是求其因子10的个数。因子10的个数又等于质因子2和质因子5个数的最小值，并且由接下来的证明可以知道，质因子2的个数一定大于等于质因子5的个数，因此我们只需求出质因子5的个数即可。</p><p>如何证明呢？我们考察1-n中所有整数的质因子p的个数和。</p><p>我们先从p的1次方开始， 可以算出1-n所有数中一次方的个数和为<strong>n除以p的下取整</strong>，把这些因子加上。同理二次方为<strong>n除以p的平方的下取整</strong>，而在计算平方时，其中一次方的因子我们前面已经计算过了，因此只加上一个因子。接下来的次方同理。</p><p>把这些个数加起来，我们就可以算出质因子p的总个数。由于每次都除以p的若干次方，p越小其质因子个数就越多，因此质因子2的个数一定大于等于质因子5的个数。</p><p>而且算出了这个总个数后，我们就可以通过每次都把n除以5，并把结果加上来模拟上述计算过程。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(logn)$</li><li>空间复杂度: $O(1)$</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">            ans += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Large Language Models Enable Few-Shot Clustering</title>
      <link href="/2024/12/02/Large-Language-Models-Enable-Few-Shot-Clustering/"/>
      <url>/2024/12/02/Large-Language-Models-Enable-Few-Shot-Clustering/</url>
      
        <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>文章探讨了大模型在半监督聚类中的应用。半监督聚类和无监督聚类不同，它允许用户提供<strong>数据的有意义结构</strong>来辅助聚类。传统的半监督聚类存在的问题是需要大量的<strong>专家反馈</strong>，所需的人力较多。LLM可以辅助few-shot的半监督文本聚类，并且非常有效。在聚类前、聚类中、聚类后三个阶段，LLM都可以辅助，其中前两个阶段效果最好。聚类前通过增强输入特征，聚类中通过提供聚类限制，聚类后通过矫正信息。而且，LLM还可以让用户在花费和准确度中进行权衡。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="聚类前-关键词展开"><a href="#聚类前-关键词展开" class="headerlink" title="聚类前-关键词展开"></a>聚类前-关键词展开</h2><p>对于数据集的每个文档，都传给LLM生成关键词，然后把关键词传给嵌入模型生成嵌入向量，再和原文档的嵌入向量拼接。</p><p><strong>效果最好</strong>，但是LLM需要对每个文档都进行处理，开销大。</p><h2 id="聚类中-提供伪专家知识"><a href="#聚类中-提供伪专家知识" class="headerlink" title="聚类中-提供伪专家知识"></a>聚类中-提供伪专家知识</h2><p>领域的通用方法是，由专家指出哪些点必须被连接，哪些点一定不能被连接。</p><p>使用大模型后，可以只提供少数的专家知识对作为few-shot提示词，由大模型找出更多必须被连接和不能被连接的点。</p><p>可以先用其他模型找出比较相近的点，然后再有大模型确认是否连接。</p><p>该方法效果也好，而且因为提前用其他模型筛选出了候选点，LLM的调用次数少。<strong>是最有性价比的方法</strong>。</p><h2 id="聚类后-纠正聚类"><a href="#聚类后-纠正聚类" class="headerlink" title="聚类后-纠正聚类"></a>聚类后-纠正聚类</h2><p>该方法的思想是，对于处在多个聚类簇边界的点，这些点的聚类情况最容易出问题。这些点用大模型来进行判断，应该属于哪个最近的簇。</p><p>该方法效果不好。</p>]]></content>
      
      
      
        <tags>
            
            <tag> paper </tag>
            
            <tag> LLM </tag>
            
            <tag> Clustering </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Docker中运行Java后端服务器</title>
      <link href="/2024/11/15/%E5%9C%A8Docker%E4%B8%AD%E8%BF%90%E8%A1%8CJava%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2024/11/15/%E5%9C%A8Docker%E4%B8%AD%E8%BF%90%E8%A1%8CJava%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>项目中遇到了要接手师兄的Java代码，并迁移到新服务器启动服务。考虑到方便日后可能的迁移，打算使用Docker容器化部署。</p><h1 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h1><p>首先撰写需要的dockerfile文件。目前代码运行稳定而且没有修改需求，因此我直接使用了之前的Jar包，而不考虑区分调试环境和构建环境，并且直接使用Jar包部署。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用官方的OpenJDK镜像作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11</span>-jre-slim as kgmaker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将生成的jar包复制到工作目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> target/kgmaker-0.0.1-SNAPSHOT.jar /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露应用运行的端口（假设应用运行在8090端口）</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8090</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行Java应用</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;kgmaker-0.0.1-SNAPSHOT.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>这里只复制了jar包，减少了部署时间和镜像大小；<code>EXPOSE</code>指令声明了监听端口，用作文档化目的（实际还需要在部署时指定端口）；<code>ENTRYPOINT</code>指令定义了容器运行后执行的命令，与<code>CMD</code>的区别是，<code>CMD</code>提供的参数会被传递给 <code>ENTRYPOINT</code> 指定的程序，简单使用直接用<code>ENTRYPOINT</code>即可。</p><h1 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h1><p><code>docker-compose</code>提供了简洁高效的多Docker容器运行编排功能，这里定义的docker-copose.yml如下。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">kgmaker:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">target:</span> <span class="string">&#x27;kgmaker&#x27;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8090:8090&#x27;</span></span><br></pre></td></tr></table></figure><p>这里的<code>build</code>指定了通过当前文件夹下的<code>kgmaker</code>镜像进行构建，<code>ports</code>指定了容器和主机的端口映射。</p><p>运行时，只需要简单的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><p>即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> doccano </tag>
            
            <tag> 后端 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github项目分支管理</title>
      <link href="/2024/11/13/github%E9%A1%B9%E7%9B%AE%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
      <url>/2024/11/13/github%E9%A1%B9%E7%9B%AE%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><blockquote><p>合并一个无人维护的旧代码的部分有用功能到现有项目中。</p></blockquote><p>因为规模较大，且可能影响到原有代码的稳定性，为了不干扰原有代码的可用性，我们选择新建一个分支来开展工作，并复制一份数据库。</p><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="Github网页的分支管理"><a href="#Github网页的分支管理" class="headerlink" title="Github网页的分支管理"></a>Github网页的分支管理</h2><p>在Github网页可以进行：查看分支，新建分支，删除分支，合并分支等功能，提供了可视化的解决方案，便于不熟悉命令行的用户操作。</p><h2 id="命令行的分支管理"><a href="#命令行的分支管理" class="headerlink" title="命令行的分支管理"></a>命令行的分支管理</h2><h3 id="origin的概念"><a href="#origin的概念" class="headerlink" title="origin的概念"></a>origin的概念</h3><p>分支管理中有许多地方可以见到origin。</p><p>在Git中，<code>origin</code> 是一个默认的远程仓库的名称。当你克隆一个远程仓库到本地时，Git会自动将其命名为 <code>origin</code>。这个名称是一个远程引用，指向你克隆的远程仓库的地址。</p><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p>在当前分支上新建一个分支。</p><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h3 id="查看所有分支"><a href="#查看所有分支" class="headerlink" title="查看所有分支"></a>查看所有分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>查看本地分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure><p>查看远程分支。</p><p>注意，需要使用git pull或者git fetch获取远程仓库最新信息，才能看到远程仓库的新分支。</p><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p>将目标分支合并到当前分支。</p><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h3 id="推送分支到远程仓库："><a href="#推送分支到远程仓库：" class="headerlink" title="推送分支到远程仓库："></a>推送分支到远程仓库：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h3 id="从远程仓库拉取分支："><a href="#从远程仓库拉取分支：" class="headerlink" title="从远程仓库拉取分支："></a><strong>从远程仓库拉取分支</strong>：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt; origin/&lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p>从远程仓库拉取名为<code>&lt;branch-name&gt;</code>的分支，并创建同名的本地分支。实际上使用git pull或者git fetch之后就已经自动创建了分支，这个操作并无必要。</p><h3 id="设置跟踪远程分支"><a href="#设置跟踪远程分支" class="headerlink" title="设置跟踪远程分支"></a>设置跟踪远程分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/&lt;branch-name&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>125. 验证回文串</title>
      <link href="/2024/11/05/%E3%80%90Java%E8%AF%AD%E6%B3%95%E3%80%91125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
      <url>/2024/11/05/%E3%80%90Java%E8%AF%AD%E6%B3%95%E3%80%91125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/valid-palindrome/description/">125. 验证回文串</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>看到题目要求移除非字母数字字符后<strong>正反读一样</strong>，显然可以想到可以用相向双指针来做。对于不符合要求的字符，我们跳过即可，无需删除。</p><h1 id="Java语法相关"><a href="#Java语法相关" class="headerlink" title="Java语法相关"></a>Java语法相关</h1><p>Java里把字符转为小写有两种方法：</p><ol><li>将字符串中所有字符转为小写：<code>string.toLowerCase()</code></li><li>将一个字符转为小写：<code>Character.toLowerCase(ch)</code></li></ol><p>另外Java里还有判断字符是否为<strong>数字</strong>或者<strong>字符</strong>的方法：<br><code>Character.isLetterOrDigit(ch)</code><br>Java的Character类功能是很丰富的。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$。</li><li>空间复杂度: $O(n)$，n为字符串长度。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span> [] cs = s.toLowerCase().toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> cs.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; !Character.isLetterOrDigit(cs[i])) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; !Character.isLetterOrDigit(cs[j])) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (cs[i] == cs[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于力扣记录</title>
      <link href="/2024/11/05/%E5%85%B3%E4%BA%8E%E5%8A%9B%E6%89%A3%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/11/05/%E5%85%B3%E4%BA%8E%E5%8A%9B%E6%89%A3%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>力扣有些题目难度较低，或者与之前做过的题目的思想有很大重复，因此之后在博客中不记录解答<strong>没有遇到困难的题目</strong>，这种题目只记录在力扣题解中。</p><p>博客记录的将会是</p><ol><li>完全不会做的题目</li><li>有关键细节需要记录的题目</li><li>有新知识点的题目</li><li>有新思路的题目</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3165. 不包含相邻元素的子序列的最大和</title>
      <link href="/2024/11/05/%E3%80%90%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%8Cdp%E3%80%913165-%E4%B8%8D%E5%8C%85%E5%90%AB%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
      <url>/2024/11/05/%E3%80%90%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%8Cdp%E3%80%913165-%E4%B8%8D%E5%8C%85%E5%90%AB%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/maximum-sum-of-subsequence-with-non-adjacent-elements/description/">3165. 不包含相邻元素的子序列的最大和</a></p></blockquote><h1 id="做题历程"><a href="#做题历程" class="headerlink" title="做题历程"></a>做题历程</h1><p>起初，我直接想到的也是dp做法，但是这需要$O(n^2)$的时间复杂度，最后做出来也的确超时了。</p><p>我便想，这个dp数组能否在不同查询中共用？</p><p>可是维护这个dp数组也需要$O(n)$的时间复杂度，这样做是白白浪费空间。我们需要的是一个至少能够以$O(logn)$的时间维护和查询<strong>不包含相邻元素的子序列的最大和</strong>的数据结构。</p><p>而看到$O(logn)$这个数量级，不出意料的话应该需要不断将<strong>输入</strong>（这里就是数组）二分成不同区间了。</p><p>除了时间复杂度，我们需要这个数据结构有什么样的性质呢？</p><p>这个时间通过dp思想的启发，我们可以想到，如果这个数据结构能够维护数组的<strong>区间信息</strong>，利用dp思想来求得组合这些区间后，我们就能够求出<strong>不包含相邻元素的子序列的最大和</strong>。</p><p>而这就是<strong>线段树</strong>。</p><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p>线段树是算法竞赛中常用的用来维护 <strong>区间信息</strong> 的数据结构。</p><p>线段树可以在$O(logn)$的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。<a href="https://oi-wiki.org/ds/seg/">OI Wiki</a>。</p><p>我们递归地把数组二分成更小的区间，每一个节点代表一个区间，而其子节点代表其更小的两个子区间。可见线段树也是一个<strong>完全二叉树</strong>。</p><p>我们可以使用数组像存储<strong>堆</strong>一样来存储线段树。如果存储下标从<code>1</code>开始，那么一个节点的左子节点为<code>2*i</code>，右子节点为<code>2*i+1</code>。</p><p>假设线段树有<code>n</code>个<strong>叶子</strong>节点，即数组有n个元素，那么树的高度为$\lceil logn \rceil$，总的节点数量为$2^{\lceil logn \rceil + 1} - 1$，可以证明这个值是小于<code>4n</code>的，在编程中可以直接用<code>4n</code>代替。</p><p>线段树我们先关注其构建、维护、查询三个操作。</p><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>我们采用递归的方式构建。给定区间左右端点，我们递归地构建左右子树，如果左右端点相等则停止递归；然后计算所需的区间信息，在本题中就是<strong>不包含相邻元素的子序列的最大和</strong>。在计算时我们可以利用到子节点的信息，因为我们可以以$O(1)$的时间访问左右子节点。建树的时间复杂度取决于计算区间信息的时间复杂度，由主方法可知，如果可以以$O(1)$的时间完成该操作，即$O(f) &#x3D; O(1)$ ，那么为$O(logn)$；否则为$O(f)$。</p><h2 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h2><p>在更改了一个单点信息后，我们需要维护线段树性质。由于这个点的修改只会影响到其祖先节点，我们以二分的思想递归查找到这个点，然后再维护区间信息即可。时间复杂度同上。</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>本题只查询最大区间，因此$O(1)$时间即可。</p><p>推广到更大的范围，如果我们要查找任意一个区间，那么这个区间有可能不是完全和线段树节点的范围一样。我们只需递归地计算其左右区间的值，并相加起来。最后当区间范围完全被查询范围覆盖时，递归结束，直接返回该节点的信息即可。时间复杂度为$O(logn)$。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>知道了线段树的数据结构，我们就只差一步之遥，即维护什么样的区间信息。我们发现如果需要用子区间的信息计算出父区间的信息，我们需要左右两个区间分别左右两个端点是否<strong>取值</strong>时的区间值，运用dp的思想求解。详见代码。其中0表示这个端点不能取到，1表示这个端点可取可不取。可见11可以涵盖所有情况。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n + qlogn)$。</li><li>空间复杂度: $O(n)$，<code>n</code>为数组长度。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//左右端点四种组合00, 01, 10, 11</span></span><br><span class="line">    <span class="type">int</span> [][]tree;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumSumSubsequence</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[][] queries)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * n][<span class="number">4</span>];</span><br><span class="line">        <span class="comment">//从1开始</span></span><br><span class="line">        build(nums, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; queries.length; i++) &#123;</span><br><span class="line">            maintain(<span class="number">0</span>, n - <span class="number">1</span>, queries[i][<span class="number">0</span>], <span class="number">1</span>, queries[i][<span class="number">1</span>]);</span><br><span class="line">            ret = (ret + tree[<span class="number">1</span>][<span class="number">3</span>]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            tree[index][<span class="number">3</span>] = Math.max(nums[l], <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意中点位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">        build(nums, l, mid, index * <span class="number">2</span>);</span><br><span class="line">        build(nums, mid + <span class="number">1</span>, r, index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        calc(index);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">maintain</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pos, <span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == pos &amp;&amp; r == pos) &#123;</span><br><span class="line">            tree[index][<span class="number">3</span>] = Math.max(val, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= mid) maintain(l, mid, pos, index * <span class="number">2</span>, val);</span><br><span class="line">        <span class="keyword">else</span> maintain(mid + <span class="number">1</span>, r, pos, index * <span class="number">2</span> + <span class="number">1</span>, val);</span><br><span class="line">        calc(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">2</span> * i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        tree[i][<span class="number">0</span>] = Math.max(tree[l][<span class="number">0</span>] + tree[r][<span class="number">2</span>],tree[l][<span class="number">1</span>] + tree[r][<span class="number">0</span>]) % mod;</span><br><span class="line">        tree[i][<span class="number">1</span>] = Math.max(tree[l][<span class="number">1</span>] + tree[r][<span class="number">1</span>],tree[l][<span class="number">0</span>] + tree[r][<span class="number">3</span>]) % mod;</span><br><span class="line">        tree[i][<span class="number">2</span>] = Math.max(tree[l][<span class="number">3</span>] + tree[r][<span class="number">0</span>],tree[l][<span class="number">2</span>] + tree[r][<span class="number">2</span>]) % mod;</span><br><span class="line">        tree[i][<span class="number">3</span>] = Math.max(tree[l][<span class="number">3</span>] + tree[r][<span class="number">1</span>],tree[l][<span class="number">2</span>] + tree[r][<span class="number">3</span>]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>685. 冗余连接 II</title>
      <link href="/2024/10/28/%E3%80%90%E5%B9%B6%E6%9F%A5%E9%9B%86%E3%80%91685-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5-II/"/>
      <url>/2024/10/28/%E3%80%90%E5%B9%B6%E6%9F%A5%E9%9B%86%E3%80%91685-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5-II/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/redundant-connection-ii/description/">685. 冗余连接 II</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>和上一题不同的是，这题把无向图换成了有向图，树的要求也更严格了。</p><p>同过观察用例，可以发现加上一条边后有两种情况使得树不再成立：</p><ol><li>一个节点有两个入度。</li><li>形成了有向环。</li></ol><p>这两种情况是相互交叉的，可能会同时发生。但是删掉最后的导致成环的边不一定能够消除两个入度的边，所以我们优先找出有两个入度的边。</p><p>找到有两个入度的边后，我们从后往前进行判断，如果删去这条边能够构成树，那么我们就找到了答案。而要判断删去一个边能否构成树，我们也可以用到<strong>并查集</strong>：先用其他边构建一个节点的并查集，然后判断这条边的两个节点是否在同一个并查集中，如果是的话删掉这条边就是可行的。</p><p>如果没有两个入度的边，我们就寻找最后导致成环的边即可。参考上一题的思路，可以很自然地想到用并查集解决。</p><blockquote><p>一开始想到了这个思路但是没有去实现，因为觉得这样代码太复杂不够简洁。看了题解发现代码确实多，说明图论的题目有时候代码量是会很大。</p></blockquote><h1 id="树的图性质"><a href="#树的图性质" class="headerlink" title="树的图性质"></a>树的图性质</h1><p>通过这两道题我们可以发现，树在图论里可以很自然地和并查集联系在一起。并查集本身就是树形结构，和<strong>树一样都只有一个根节点</strong>。以后遇到相关的题目可以优先考虑是否可以使用并查集。</p><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>图论的题目，从入度、出度、增减边、边的性质来考虑看起来是很有效的。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(nlogn)$</li><li>空间复杂度: $O(n)$</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findRedundantDirectedConnection(<span class="type">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> edges.length;</span><br><span class="line">        <span class="type">int</span>[] in = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            in[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[edges[i][<span class="number">1</span>]] != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isTree(edges, i)) <span class="keyword">return</span> edges[i];</span><br><span class="line">                <span class="keyword">return</span> edges[in[edges[i][<span class="number">1</span>]]];</span><br><span class="line">            &#125;</span><br><span class="line">            in[edges[i][<span class="number">1</span>]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] parent = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (find(parent, edges[i][<span class="number">1</span>]) == find(parent, edges[i][<span class="number">0</span>])) <span class="keyword">return</span> edges[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                union(parent, edges[i][<span class="number">1</span>], edges[i][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTree</span><span class="params">(<span class="type">int</span>[][] edges, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> edges.length;</span><br><span class="line">        <span class="type">int</span>[] parent = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != index ) union(parent, edges[i][<span class="number">1</span>], edges[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> find(parent, edges[index][<span class="number">0</span>]) == find(parent, edges[index][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span>[] parent, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        parent[find(parent, a)] = find(parent, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] parent, <span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[a] == a) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">return</span> find(parent, parent[a]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3180. 执行操作可获得的最大总奖励 I</title>
      <link href="/2024/10/27/%E3%80%90%E5%B8%83%E5%B0%94%E5%80%BCdp%E3%80%913180-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E6%80%BB%E5%A5%96%E5%8A%B1-I/"/>
      <url>/2024/10/27/%E3%80%90%E5%B8%83%E5%B0%94%E5%80%BCdp%E3%80%913180-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E6%80%BB%E5%A5%96%E5%8A%B1-I/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/maximum-total-reward-using-operations-i/description/">3180. 执行操作可获得的最大总奖励 I</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>起初我想用$O(n)$时间复杂度的动态规划，但是这样做对于有些用例会得到错误答案。后面看到提示，动态规划可以用来表示<strong>某一个值能否取到</strong>，学习到了新的解法。</p></blockquote><p>首先我们将数组排序，以保证后面的元素总比前面的元素大。用一个一维动态数组表示<strong>当前</strong>数组长度下，<strong>某一个当前总奖励</strong>是否能够取到。同时我们保存一个当前最大值，在小于<code>rewardValues[i]</code>的总奖励中，如果某个值可以取到，就更新<code>dp[rewardValues[i] + j]</code>为可以取到，并可以尝试更新最大值。最后返回最大值即可。</p><h1 id="布尔值dp"><a href="#布尔值dp" class="headerlink" title="布尔值dp"></a>布尔值dp</h1><p>当dp的值设为数值类型时难以求解时，我们可以考虑把<strong>数值类型</strong>作为数组的下标，转而把是否选取的状态设为dp的值，这样我们就可以方便地遍历所有值。</p><p>也就是说遍历状态难以求解时，可以尝试遍历值，这也是一种新思路。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(nm)$</li><li>空间复杂度: $O(n)$</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxTotalReward</span><span class="params">(<span class="type">int</span>[] rewardValues)</span> &#123;</span><br><span class="line">        Arrays.sort(rewardValues);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> rewardValues.length;</span><br><span class="line">        <span class="type">boolean</span> dp[] = <span class="keyword">new</span> <span class="title class_">boolean</span> [rewardValues[n - <span class="number">1</span>] * <span class="number">2</span>];</span><br><span class="line">        dp[rewardValues[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> rewardValues[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[rewardValues[i]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; rewardValues[i]; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] == <span class="literal">true</span>) &#123;</span><br><span class="line">                    dp[rewardValues[i] + j] = <span class="literal">true</span>;</span><br><span class="line">                    max = rewardValues[i] + j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>684. 冗余连接</title>
      <link href="/2024/10/27/%E3%80%90%E5%B9%B6%E6%9F%A5%E9%9B%86%E3%80%91684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/"/>
      <url>/2024/10/27/%E3%80%90%E5%B9%B6%E6%9F%A5%E9%9B%86%E3%80%91684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/redundant-connection/description/">684. 冗余连接</a>，记录官解题解。</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>这题一开始尝试的时候，我就想到的也是用<strong>集合</strong>的方法来做，尝试了用集合列表，每个节点赋值一个集合。但是提交时有一些用例过不了，排查后发现，这些节点可能共同属于一个集合，但是却被赋予了不同的集合，调试了许久也没有调试出来。后来看题解才恍然大悟，用的正是<strong>并查集</strong>（记得刚接触算法就对这个数据结构特别有印象，但是确实很久没有遇到了）。</p></blockquote><p>使用并查集即可完成，遍历数组，先查看边上的两个节点是否属于同一个集合，如果是的话，则把答案设为当前边。否则，将边上的两个节点都加入同一个集合。</p><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>这里顺便复习一下并查集的知识，以防再次遗忘。</p><p>首先在数据结构方面，并查集是一个<strong>树形</strong>结构，有两个操作：<code>union</code>和<code>find</code>。分别是合并两个集合，查找一个集合的<strong>根节点</strong>，即判断所属的最大集合。</p><p>一般情况下，可以用<strong>parent数组</strong>来存储所有节点的直接父亲节点。节点之间构成树形结构。</p><p>初始化并查集时，把每个结点的<code>parent</code>都设为自己，即用自己来标记集合。</p><p>合并两个并查集时，将一个节点的根节点的<code>parent</code>设为另一个节点的<strong>根节点</strong>，这样就把整个集合移动到了另一个集合下。想象成树形结构就很好理解了。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(nlogn)$</li><li>空间复杂度: $O(n)$</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findRedundantConnection(<span class="type">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> edges.length;</span><br><span class="line">        <span class="type">int</span>[] parent = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] edge = edges[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">node1</span> <span class="operator">=</span> edge[<span class="number">0</span>], node2 = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (find(parent, node1) != find(parent, node2)) &#123;</span><br><span class="line">                union(parent, node1, node2);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span>[] parent, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        parent[find(parent, index1)] = find(parent, index2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] parent, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[index] != index) &#123;</span><br><span class="line">            parent[index] = find(parent, parent[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3186. 施咒的最大总伤害</title>
      <link href="/2024/10/23/3186-%E6%96%BD%E5%92%92%E7%9A%84%E6%9C%80%E5%A4%A7%E6%80%BB%E4%BC%A4%E5%AE%B3/"/>
      <url>/2024/10/23/3186-%E6%96%BD%E5%92%92%E7%9A%84%E6%9C%80%E5%A4%A7%E6%80%BB%E4%BC%A4%E5%AE%B3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/description/">3186. 施咒的最大总伤害</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>看到题目有数值排列，以及限制在<code>power[i]</code>附近两个数，首先我们可以自然地想到要先排序。</p><p>接着，相同数值应该被归并到一起，我们创建一个数组来存储它，并创建另一个数组来存储相同数值的和。</p><p>然后，从题意可以看到，选择一个咒语，相差两个伤害值以内的咒语就不能使用，这相当于两者二选一，而<strong>选择</strong>是动态规划的拿手领域，顺其自然可以想到用dp求解。</p><p>我们设<code>dp[i][j]</code>为截止到第<code>i</code>小伤害值时的最大总伤害，<code>j</code>为1表示选择<code>i</code>，为1则表示不选择，由此我们可以列出状态转移方程，详见代码。</p><blockquote><p>dp的一个经典应用就是第<code>i</code>个元素选择和不选择，分为两种状态。</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$</li><li>空间复杂度: $O(n)$</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maximumTotalDamage</span><span class="params">(<span class="type">int</span>[] power)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(power);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> power.length;</span><br><span class="line">        <span class="type">long</span> dp[][] = <span class="keyword">new</span> <span class="title class_">long</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="type">long</span> a[] = <span class="keyword">new</span> <span class="title class_">long</span>[n];</span><br><span class="line">        <span class="type">int</span> b[] = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">            b[cnt] = power[start];</span><br><span class="line">            a[cnt] = power[start];</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n - <span class="number">1</span> &amp;&amp; power[i + <span class="number">1</span>] == power[i]) &#123;</span><br><span class="line">                a[cnt] += power[i + <span class="number">1</span>];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; cnt; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">2</span> &amp;&amp; b[i] - <span class="number">2</span> == b[i - <span class="number">2</span>]) &#123;</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i - <span class="number">2</span>][<span class="number">0</span>] + a[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b[i] - <span class="number">1</span> == b[i - <span class="number">1</span>] || b[i] - <span class="number">2</span> == b[i - <span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + a[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i][<span class="number">0</span>] + a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[cnt - <span class="number">1</span>][<span class="number">0</span>], dp[cnt - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>124. 二叉树中的最大路径和</title>
      <link href="/2024/10/22/124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
      <url>/2024/10/22/124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/">124. 二叉树中的最大路径和</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>用dp的思想，遍历这个树，dfs函数返回当前子树的最大路径和，如果最大路径和为负数则不途径这个子树，设为0。同时在dfs遍历的时候，以左右子树分别最大路径和加上当前结点的值尝试更新答案，因为左右子树的最大路径和都是非负的。</p><p>显然在这个过程中，我们是可以遍历树上所有结点的。</p><h1 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h1><p>一开始看到路径和，我想到的是把树看成图来解，想到了枚举所有叶子到叶子的路径，然后对单条路径用dp的思想求最大值，但是这样显然是$O(n^2)$算法，会超时。</p><p>后来舍友的想法给了我提醒，同样是使用dp的思想，但是用树的遍历来做。这样是对的，树的题目还是得用树的遍历才能最大程度地利用其性质。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$，n为节点数目。</li><li>空间复杂度: $O(n)$，递归深度，最坏情况下为一条链。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">1001</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftVal</span> <span class="operator">=</span> dfs(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightVal</span> <span class="operator">=</span> dfs(root.right);</span><br><span class="line">        max = Math.max(leftVal + rightVal + root.val, max);</span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(leftVal + root.val, rightVal + root.val), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3185. 构成整天的下标对数目 II</title>
      <link href="/2024/10/22/3185-%E6%9E%84%E6%88%90%E6%95%B4%E5%A4%A9%E7%9A%84%E4%B8%8B%E6%A0%87%E5%AF%B9%E6%95%B0%E7%9B%AE-II/"/>
      <url>/2024/10/22/3185-%E6%9E%84%E6%88%90%E6%95%B4%E5%A4%A9%E7%9A%84%E4%B8%8B%E6%A0%87%E5%AF%B9%E6%95%B0%E7%9B%AE-II/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/count-pairs-that-form-a-complete-day-ii/description/">3185. 构成整天的下标对数目 II</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>将日期取模映射到24小时，使用哈希表存储时间，并在遍历到每一个时间时，答案加上之前出现的与之构成整天的日期个数，这样就是实现了配对，一次遍历即可。</p><h1 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h1><p>因为我是先做的I再做的II，一开始直接把I的复制过来发现有一个大数组的结果不对。我尝试把ans改成long，但是发现不对最后还是得转回int，也没有用。这才发现原来是返回值应该是long。</p><p>然后我一开始使用了哈希表来存储数据，发现时间花销较大。哈希表需要判空操作等，自然花销的常数时间是比较大的。对于<strong>键范围已知且为连续整数</strong>的取值范围，我们可以直接用数组来作为哈希表存储，这样不仅代码好写，时间效率也有常数级别的较高优化。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$</li><li>空间复杂度: $O(n)$</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countCompleteDayPairs</span><span class="params">(<span class="type">int</span>[] hours)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] m = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">24</span>];</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; hours.length; i++) &#123;</span><br><span class="line">            ans += m[(<span class="number">24</span> - (hours[i] % <span class="number">24</span>)) % <span class="number">24</span>];</span><br><span class="line">            m[hours[i] % <span class="number">24</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>188. 买卖股票的最佳时机 IV</title>
      <link href="/2024/10/18/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-IV/"/>
      <url>/2024/10/18/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-IV/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">188. 买卖股票的最佳时机 IV</a>，记录官解。</p></blockquote><h1 id="做题历程"><a href="#做题历程" class="headerlink" title="做题历程"></a>做题历程</h1><blockquote><p>做完这题，我才发现我之前几道股票题的做法是碰巧利用了题目的特性，无法扩大到更大条件。</p></blockquote><p>借着上一题的思路，我想着能否再分而治之，把<code>k</code>次购买分成若干个<code>1</code>次购买。一个想法是把数组分成若干个部分，然后对每个部分求出1次购买的值。但是这样做时间复杂度太高，是k的阶乘乘以n的数量级，而且显而易见地进行了大量的重复计算。</p><h1 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h1><p>我前面思路没有做出来的原因是，少利用了<strong>是否持有股票</strong>这一重要条件。把这个条件加入到动态规划条件中，并加入<strong>至多进行k次交易</strong>这个条件，题目就迎刃而解了。动态规划的转移方程可以参见代码。</p><p>由此可见遇到错误死胡同需要转变思路想想。在动态规划题目里特别是变换<strong>状态条件</strong>。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(nk)$，<code>n</code>为数组长度。</li><li>空间复杂度: $O(k)$。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        k = Math.min(n / <span class="number">2</span>, k);</span><br><span class="line">        <span class="type">int</span> dp[][] = <span class="keyword">new</span> <span class="title class_">int</span>[k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">                dp[j][<span class="number">1</span>] = Math.max(dp[j - <span class="number">1</span>][<span class="number">0</span>] - prices[i], dp[j][<span class="number">1</span>]);</span><br><span class="line">                dp[j][<span class="number">0</span>] = Math.max(dp[j][<span class="number">1</span>] + prices[i], dp[j][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>97. 交错字符串</title>
      <link href="/2024/10/18/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%9197-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2024/10/18/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%9197-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/interleaving-string/description/">97. 交错字符串</a>，记录官解。</p></blockquote><h1 id="做题历程"><a href="#做题历程" class="headerlink" title="做题历程"></a>做题历程</h1><p>起初我试图使用双指针解题，但是对于一些测试用例，双指针（带有贪心思想）的解答是错误的，并且可以发现这些错误可以用回溯解决。</p><p>因此接下来我就试图用动态规划来解这个题。我想到的是用两个动态规划数组，分别记录字符串<code>a</code>和字符串<code>b</code>的当前长度，但是没做出来；后来撇了一眼官解，用的是二维数组来记录当前两字符串的长度，并优化掉其中一维，但是我自己去做还是没有做出来。</p><p>在看完官解的解答后，我发现我没做出来的原因是，我遍历的是<strong>数组c的长度</strong>，并在内层循环遍历<strong>数组a的长度</strong>，而官解遍历的是<strong>数组a和b的长度</strong>，这就导致我的写法非常难写。从中我也学习到了，动态规划的最外层循环不一定要是问题的规模大小，也可以是别的条件的规模大小。</p><p>动态规划题目找到dp数组的<strong>变化条件</strong>和<strong>循环方式</strong>可见非常重要，这两个知道后转移方程反而很容易想到。</p><h1 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h1><p>正如前文所述，状态转移方程就很好想出来了，如代码所示就不赘述。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(mn)$，<code>m</code>,<code>n</code>为数组<code>a</code>,<code>b</code>的长度。</li><li>空间复杂度: $O(m)$。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length(), m = s2.length(), t = s3.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n + m != t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[] f = <span class="keyword">new</span> <span class="title class_">boolean</span>[m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        f[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> i + j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    f[j] = f[j] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(p);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    f[j] = f[j] || (f[j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(p));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>123. 买卖股票的最佳时机 III</title>
      <link href="/2024/10/17/123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-III/"/>
      <url>/2024/10/17/123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-III/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">123. 买卖股票的最佳时机 III</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>你选用何种方法解题？</p></blockquote><p>本题要完成<strong>最多两笔交易</strong>，而且一次只能持有一支股票，两笔交易不能够有重叠的时间，因此我的想法是，如何把题目规模变小，从而转化为最多只能进行一笔交易的情况，而这个情况之前我们已经用动态规划解决了。</p><p>由于最多是两笔交易，我们可以分别从左边开始和从右边开始进行计算<strong>最多进行一次交易的最大收益</strong>，在计算完成后，我们只需遍历数组，求出截止到<code>i</code>点从左开始计算和从右开始计算的最大收益和，并返回最大收益即可。</p><p>一个实现细节是，对于从右开始的计算，我们保存的是<strong>最大股票价格</strong>而不是最小的，因为虽然从右往左计算，动态规划的值仍然是<strong>从区间左边开始，截止到右边的单次股票交易最大收益</strong>，而不是反过来的。</p><p>一个小小的优化是，在我们做完从左开始的计算后，对于从右开始的计算我们就不必再新开一个dp数组了，可以直接利用原来dp数组的空间，同时也不需要再多遍历一次，原地求两向相加最大收益即可。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$：遍历两遍数组，n为数组长度。</li><li>空间复杂度: $O(n)$：n为数组长度。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> [] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; n; i++) &#123;</span><br><span class="line">            temp = Math.min(temp, prices[i]);</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], prices[i] - temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> dp[n - <span class="number">1</span>];</span><br><span class="line">        temp = prices[n - <span class="number">1</span>];</span><br><span class="line">        dp[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            temp = Math.max(temp, prices[i]);</span><br><span class="line">            ans = Math.max(ans, dp[i] + dp[i + <span class="number">1</span>]);</span><br><span class="line">            dp[i] = Math.max(dp[i + <span class="number">1</span>], temp - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>批量任务的JS异步问题</title>
      <link href="/2024/10/15/%E6%89%B9%E9%87%8F%E4%BB%BB%E5%8A%A1%E7%9A%84JS%E5%BC%82%E6%AD%A5%E9%97%AE%E9%A2%98/"/>
      <url>/2024/10/15/%E6%89%B9%E9%87%8F%E4%BB%BB%E5%8A%A1%E7%9A%84JS%E5%BC%82%E6%AD%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>项目中遇到了这样一个情景，需要先向后端查询一个表的所有数据，然后这个表的每行数据都向后端查询这行数据的<code>id</code>是否在另一个表中存在。</p><blockquote><p>实际上为了减少网络传输的开支，这个动作应该在后端完成，但是正好借此机会学习这种情况的解决方式。</p></blockquote><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>起初我在第一个调用后的<code>then</code>范围内用<code>for</code>循环调用了若干个Promise请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">refreshList</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">loading</span> = <span class="literal">true</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">processService</span>.<span class="title function_">list</span>(&#123;</span><br><span class="line">        <span class="attr">currentPage</span>: <span class="variable language_">this</span>.<span class="property">tablePage</span>.<span class="property">currentPage</span>,</span><br><span class="line">        <span class="attr">pageSize</span>: <span class="variable language_">this</span>.<span class="property">tablePage</span>.<span class="property">pageSize</span></span><br><span class="line">      &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">records</span> = data.<span class="property">records</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">records</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">processService</span>.<span class="title function_">isFinish</span>(<span class="variable language_">this</span>.<span class="property">records</span>[i].<span class="property">id</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">records</span>[i].<span class="property">done</span> = data.<span class="property">done</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tablePage</span>.<span class="property">total</span> = <span class="variable language_">this</span>.<span class="property">records</span>.<span class="property">length</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">loading</span> = <span class="literal">false</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>但是这样做之后，前端显示的数据会先短暂闪烁，最终不显示。起初我以为是前端控件的问题，排除了很久都找不出问题的原因所在。后来才想到可能是异步程序的问题。</p><h1 id="异步问题"><a href="#异步问题" class="headerlink" title="异步问题"></a>异步问题</h1><p>首先，即使没有调用多个Promise，这个程序也存在问题。首先<code>.then</code>不会默认等待，在最外层的<code>list</code>调用链中，<code>this.records[i].done</code>的操作是需要异步请求的，这就导致了在这个操作完成前，<code>this.records</code>的值就已经读取完成并且<code>this.loading = false</code>，因此表格已经认为加载完毕，之后等待值传来时就没有完成响应式更新。</p><h1 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h1><p>之后我堆代码进行了如下更改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">async</span> <span class="title function_">refreshList</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">loading</span> = <span class="literal">true</span></span><br><span class="line">   <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">processService</span>.<span class="title function_">list</span>(&#123;</span><br><span class="line">     <span class="attr">currentPage</span>: <span class="variable language_">this</span>.<span class="property">tablePage</span>.<span class="property">currentPage</span>,</span><br><span class="line">     <span class="attr">pageSize</span>: <span class="variable language_">this</span>.<span class="property">tablePage</span>.<span class="property">pageSize</span></span><br><span class="line">   &#125;)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">records</span> = data.<span class="property">records</span></span><br><span class="line"><span class="keyword">const</span> promises = <span class="variable language_">this</span>.<span class="property">records</span>.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">processService</span>.<span class="title function_">isFinish</span>(item.<span class="property">id</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">item.<span class="property">done</span> = data;</span><br><span class="line"><span class="keyword">return</span> item;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">records</span> = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">tablePage</span>.<span class="property">total</span> = <span class="variable language_">this</span>.<span class="property">records</span>.<span class="property">length</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">loading</span> = <span class="literal">false</span></span><br><span class="line"> &#125;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>首先第一点就是我增加了<code>async/await</code>。通过<code>await</code>等待可以防止异步程序出现乱序的错误。</p><p>然后就是Array.prototype.<strong>map</strong>()可以返回一个数组，这个数组的每个元素都是原数组每个元素调用一次提供的函数的返回值后形成的。使用这个语法可以简化开发。</p><p>再者，学习到了一个新的知识点，<code>Promise.all()</code>支持对多个<code>promise</code>进行集中处理，聚合多个<code>promise</code>。这样也可以对多个<code>promise</code>进行<code>await</code>了。</p><p>这次的错误确实加深了对异步编程的印象。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 异步编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>46. 全排列</title>
      <link href="/2024/10/11/46-%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2024/10/11/46-%E5%85%A8%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/permutations/description/">46. 全排列</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>本题可以用回溯的思路来解决。对于搜索函数<code>dfs</code>，我们记录当前搜索进行到的位置，然后遍历所有可能的选项，继续调用<code>dfs</code>函数进行搜索，在搜索完毕后回溯回原来的状态，继续遍历。当搜索完全部位置时，<code>dfs</code>函数返回搜索的值。</p><h2 id="小tips"><a href="#小tips" class="headerlink" title="小tips"></a>小tips</h2><p>本题由于可以直接覆盖当前位置的选项，可以不用移除最后一个元素，同时把增加一个元素改成修改一个元素。</p><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[nums.length]);</span><br></pre></td></tr></table></figure><p>可以用n个整数初始化ArrayList，以使得set函数可用。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n×n!)$，，其中 n 为序列的长度。</li><li>空间复杂度: $O(n)$。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] vis;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; l = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; p;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        p = Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[nums.length]);</span><br><span class="line">        vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        dfs(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> [] nums, <span class="type">int</span> nowPos)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nowPos == nums.length) &#123;</span><br><span class="line">            l.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(p));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">                p.set(nowPos, nums[i]);</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">                dfs(nums, nowPos + <span class="number">1</span>);</span><br><span class="line">                vis[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>42. 接雨水</title>
      <link href="/2024/10/11/42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
      <url>/2024/10/11/42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/trapping-rain-water/description/">42. 接雨水</a>。比较朴素的做法。</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>我们用列的方式看这道题，先从左向右看，用双指针维护一个区间，这个区间满足区<strong>间右端点的高度大于等于左端点</strong>，这样这个区间内的水量可以用左端点高度乘以开区间宽度减去开区间内柱子高度求得。</p><p>但是这个求法可能无法解决最右边的区间水量。显然，从左往右看和从右往左看是一样的，我们只需要从右往左看到最后一个区间的开头，求出那一部分的水量，再加上去即可。</p><p>第二个做法为什么可行呢？因为当我们求不出最后一个区间的水量时，区间开头的高度一定是大于区间内的所有点的，这样从右往左算一定可以算出来。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$。最坏情况遍历两次数组，<code>n</code>为数组长度。</li><li>空间复杂度: $O(1)$。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; height[i] == <span class="number">0</span>) i++;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; height[i] &lt; height[start]) &#123;</span><br><span class="line">                curSum += height[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">                i = start;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = ret + (i - start - <span class="number">1</span>) * Math.min(height[start], height[i]) - curSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> j;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            j--;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; i &amp;&amp; height[j] &lt; height[start]) &#123;</span><br><span class="line">                curSum += height[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = ret + (start - j - <span class="number">1</span>) * Math.min(height[start], height[j]) - curSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12. 整数转罗马数字</title>
      <link href="/2024/10/11/12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
      <url>/2024/10/11/12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/integer-to-roman/description/">12. 整数转罗马数字</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>模拟题目所说罗马数字转换规则即可。另外，实际上不需要判断数字以哪位开头，因为每次选择选项中最大的那个时，自然会满足题目所说的转换规则。</p><p>另外，由于情况是有限的，可以给每个位的情况都列一个表，这样时间复杂度是$O(1)$。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$，<code>n</code>为<code>num</code>位数。</li><li>空间复杂度: $O(1)$。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] values = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span> , <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        String [] svalues = &#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>&#125;; </span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Integer.toString(num);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">13</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &gt;= values[i]) &#123;</span><br><span class="line">                    sb.append(svalues[i]);</span><br><span class="line">                    num -= values[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3164. 优质数对的总数 II</title>
      <link href="/2024/10/11/3164-%E4%BC%98%E8%B4%A8%E6%95%B0%E5%AF%B9%E7%9A%84%E6%80%BB%E6%95%B0-II/"/>
      <url>/2024/10/11/3164-%E4%BC%98%E8%B4%A8%E6%95%B0%E5%AF%B9%E7%9A%84%E6%80%BB%E6%95%B0-II/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/find-the-number-of-good-pairs-ii/description/">3164. 优质数对的总数 II</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>观察本题数据量，可以知道暴力模拟是会超时的，那要怎么求解呢？</p><p>首先，两个数组的长度都是$10^5$，每个数据的大小不大于$10^6$，如果我们遍历<code>nums2</code>，并在二重循环里以<code>nums2[j] * k</code>为步伐大小遍历<code>nums2[j] * k</code>，如果答案在<code>nums[1]</code>里有则记录下来（哈希查找时间复杂度$O(1)$），直到<code>nums[1]</code>的最大值为止。第二层遍历的期望时间是比遍历<code>nums1</code>要小的。</p><p>但是这样遇到一些测试用例仍然无法通过，仔细看可以发现，题目并没有说明<code>nums1</code>或<code>nums2</code>中的整数不重复，这样对于重复的整数的计算都是冗余的，我们用哈希表维护出现的次数，在找到时改成加上对应出现的次数的乘积即可。</p><blockquote><p>这些测试用例一般都是<code>nums2[j]</code>极小而<code>nums1[i]</code>极大，并且多次重复。如果没有重复，前者就会不可避免地增大，后者相应减小，这样时间复杂度是较低的。</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: $O(n+m+v&#x2F;k×logm)$，其中<code>n</code>和<code>m</code>分别是数组<code>nums1</code>和<code>nums2</code>的长度，<code>k</code>是给定的正整数，<code>v</code>是数组<code>nums1​</code>最大值，<code>logm</code>是「调和级数」求和的结果。</p></li><li><p>空间复杂度: $O(n + m)$。</p></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">numberOfPairs</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; m = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; m2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            max = max &lt; nums1[i] ? nums1[i] : max;</span><br><span class="line">            m.merge(nums1[i], <span class="number">1</span>, Integer::sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">            m2.merge(nums2[i], <span class="number">1</span>, Integer::sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; e : m2.entrySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">div</span> <span class="operator">=</span> e.getKey() * k;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> div; j &lt;= max; j += div) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m.containsKey(j)) ans += (<span class="type">long</span>)(m.get(j)) * (<span class="type">long</span>)(e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1436. 旅行终点站</title>
      <link href="/2024/10/08/1436-%E6%97%85%E8%A1%8C%E7%BB%88%E7%82%B9%E7%AB%99/"/>
      <url>/2024/10/08/1436-%E6%97%85%E8%A1%8C%E7%BB%88%E7%82%B9%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/destination-city/description/">1436. 旅行终点站</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>由于题目数据保证了一定有且仅有一个终点站，而且终点站的性质是不通往其他任意城市，我们只需要用哈希表保存所有在<code>cityB</code>出现的站，然后找出没有出现在<code>cityA</code>中的即可。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(nm)$：遍历两次数组。其中<code>n</code>是<code>paths</code>的长度，<code>m</code>是字符串的长度。</li><li>空间复杂度: $O(nm)$：哈希表。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">destCity</span><span class="params">(List&lt;List&lt;String&gt;&gt; paths)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> paths.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            s.add(paths.get(i).get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!s.contains(paths.get(i).get(<span class="number">1</span>))) <span class="keyword">return</span> paths.get(i).get(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>871. 最低加油次数</title>
      <link href="/2024/10/08/871-%E6%9C%80%E4%BD%8E%E5%8A%A0%E6%B2%B9%E6%AC%A1%E6%95%B0/"/>
      <url>/2024/10/08/871-%E6%9C%80%E4%BD%8E%E5%8A%A0%E6%B2%B9%E6%AC%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/minimum-number-of-refueling-stops/description/">871. 最低加油次数</a></p></blockquote><h1 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="1.动态规划"></a>1.动态规划</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>起初看到题目的规模不大，便以为可以使用$O(n^2)$的算法来做，这是想到用动态规划的一个契机。</p><p>再就是题目是符合动态规划的条件的：</p><ol><li>题目符合无后效性，后面的加油站的选择对前面没有影响。</li><li>题目存在最优子结构，即我们可以通过构造<code>dp[i][j]</code>，其中<code>i</code>表示到达第<code>i</code>站，加了<code>j</code>次油时所剩的油，通过不断扩大<code>i</code>的规模即可求解。</li></ol><p>起初，设定<code>dp[0][0]</code>为<code>startFuel - stations[0][0]</code>，表示到达第<code>0</code>站而且未加油，如果这个值大于<code>0</code>，则可以加上<code>stations[0][1]</code>。</p><p>之后我们遍历<code>i</code>，并<strong>从大到小</strong>遍历所有小于等于<code>i</code>的<code>j</code>，判断<code>dp[i-1][j]</code>能否到达第<code>i</code>站，如果可以，而且这样剩的油更多的话，则更新<code>dp[i][j + 1]</code>。这里注意到，由于<code>dp[i]</code>之和前<code>dp[i - 1]</code>有关，我们可以省略这一维度。而我们从大到小遍历<code>j</code>，可以防止在更新过程中用<code>dp[i][j + 1]</code>的值覆盖之前<code>dp[i - 1][j + 1]</code>的值。</p><p>最后在遍历结束后，我们找出最小的所剩油量足够行驶完剩余距离的次数即可。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度: $O(n^2)$：双层for循环，<code>n</code>为数组长度。</li><li>空间复杂度: $O(n)$：动态规划所用空间。</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minRefuelStops</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> startFuel, <span class="type">int</span>[][] stations)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> stations.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target &lt;= startFuel ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//到第i站，加油j次所剩的油。</span></span><br><span class="line">        <span class="type">int</span> dp[] = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = startFuel - stations[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (dp[<span class="number">0</span>] &gt;= <span class="number">0</span>) dp[<span class="number">1</span>] = dp[<span class="number">0</span>] + stations[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[j] = dp[j] + stations[i - <span class="number">1</span>][<span class="number">0</span>] - stations[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &gt;= <span class="number">0</span>) dp[j + <span class="number">1</span>] = Math.max(dp[j + <span class="number">1</span>], dp[j] + stations[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">remain</span> <span class="operator">=</span> target - stations[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt;= remain) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-贪心"><a href="#2-贪心" class="headerlink" title="2.贪心"></a>2.贪心</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>本题实际上有更好的做法。要知道，能够使用动态规划解决的题目就<strong>有可能</strong>能用贪心解决。</p><p>想象这样一个情景，车在行驶的过程中，如果身上的油足够它走过接下来若干个加油站，那么它如果要加油次数最少，肯定要在这些加油站中选一个能加最多油的站先加上。</p><p>这样做的情况下加油次数最少是保证了，但是能否确保不会因为少加油而无法到达终点？</p><p>这是可能存在的，但是实际上由于要到达终点我们会经过所有的加油站，如果后面发现油不够了，只要还记住没有加油的站里哪个油最多，一一再加上也是可以的（反悔）。</p><p>上面我们发现，我们需要维护的是已经到达的站按油量最多排序的优先队列，再加上贪心即可解决问题。</p><h2 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度: $O(n)$：<code>n</code>为数组长度。</li><li>空间复杂度: $O(n)$：最大堆所用空间。</li></ul><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minRefuelStops</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> startFuel, <span class="type">int</span>[][] stations)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> stations.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target &lt;= startFuel ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b[<span class="number">1</span>] - a[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">nowFuel</span> <span class="operator">=</span> startFuel;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nowPos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (nowFuel &lt; target - nowPos) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cnt &lt; n &amp;&amp; stations[cnt][<span class="number">0</span>] &lt;= nowFuel + nowPos) &#123;</span><br><span class="line">                q.add(stations[cnt++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (q.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] add = q.poll();</span><br><span class="line">            nowFuel += add[<span class="number">1</span>] + nowPos - add[<span class="number">0</span>];</span><br><span class="line">            nowPos = add[<span class="number">0</span>];</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>134. 加油站</title>
      <link href="/2024/10/06/134-%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
      <url>/2024/10/06/134-%E5%8A%A0%E6%B2%B9%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/gas-station/description/">134. 加油站</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先能想到的直观做法是，把<code>gas</code>和<code>cost</code>相减，求出一个每到一站的油量变化，然后我们尝试从某个油量变化为正的站开始，如果能走一圈则答案为该油站，否则从下一个正油站继续尝试遍历。</p><p>这样做也能以$O(n)$的复杂度完成，但是代码相对难写，而且还需要判断是否能够走完。</p><p>进一步考虑我们可以发现，如果把所有相减值求和，求得的结果为负，那么无论怎样都不能走完，显然是返回-1。</p><p>那么对于相减值大于等于零的情况呢？</p><p>实际上这样是一定可以走完的。我们利用大于零的性质进行以下推导：</p><p>假设到<code>i</code>位，当前的总油量变为了负数，由于所有站的相减值总和大于0，我们可以知道在<code>i+1</code>到<code>n - 1</code>中间的和加上当前累计值肯定大于0，因此我们选择下一个相减值大于0的点，从这个点出发，若能走到<code>n-1</code>，则该点即为答案；否则继续寻找下一个点，而这一直保持了之后的和加上当前累计值一定大于0的性质，所以一定可以找到一个满足要求的点。</p><p>在这个过程中我们可以发现，我们只需要找到一个点，从这个点开始能走到结尾即可。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$，n为数组长度。</li><li>空间复杂度: $O(1)$。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> gas.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            total += gas[i] - cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (total &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; sum &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                sum += gas[i] - cost[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= <span class="number">0</span>) <span class="keyword">return</span> start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yarn run serve无法运行</title>
      <link href="/2024/10/06/yarn-run-serve%E5%9C%A8vscode%E4%B8%AD%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C/"/>
      <url>/2024/10/06/yarn-run-serve%E5%9C%A8vscode%E4%B8%AD%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>这几天出现了一个bug，之前vscode可以运行的前端程序，在使用<code>yarn run serve</code>之后会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yarn run v1.22.22</span><br><span class="line">$ vue-cli-service serve</span><br><span class="line">&#x27;vue-cli-service&#x27; is not recognized as an internal or external command,</span><br><span class="line">operable program or batch file.</span><br><span class="line">error Command failed with exit code 1.</span><br><span class="line">info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.</span><br></pre></td></tr></table></figure><p>后来，我根据网上的提示，尝试了删除node_modules重新安装，删除node环境重新安装，都不行。甚至npm install都出现了问题。</p><p>后来，碰巧使用系统终端（而不是vscode里的）来云心npm install，发现竟然可以了。于是我也在该终端运行yarn run serve，发现果然也可以。</p><p>于是就可以知道问题出在vscode上。我查看了vscode的权限，并使用管理员打开，以及在vscode里打开pwsh，都不能成功运行，这样暂时只能用系统终端来运行了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>135. 分发糖果</title>
      <link href="/2024/10/06/135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/"/>
      <url>/2024/10/06/135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/candy/description/">135. 分发糖果</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>本题可以采用分块处理的做法，因为我们可以观察到这样一个性质：</p><p>对于第<code>i</code>位，其之后有若干个连续位评分递减，到第<code>j</code>位为第一个不满足下一位小于<code>j</code>，那么如果第<code>j</code>位只有<code>1</code>个糖果，并且前面递增<code>1</code>个糖果，所分发的糖果是最小的。</p><p>而如果<code>i</code>大于前一位的评分，我们只需要保证<code>i</code>能比前一位多一个糖果即可。</p><p>因为题目对于相同评分的孩子的糖果数没有要求，我们就不必考虑相等的情况。</p><p>这样遍历完一次数组，我们就可以求出所有位置的糖果，把他们加起来就得到了答案。</p><h2 id="空间复杂度O-1-做法"><a href="#空间复杂度O-1-做法" class="headerlink" title="空间复杂度O(1)做法"></a>空间复杂度O(1)做法</h2><p>我们可以发现上述过程并不需要保存所有位置的糖果数，如果是递减的情况，我们就可以直接求出需要加上的糖果数；如果是递增的情况，我们只需要记录上一次的糖果数，看情况是否需要增加糖果即可。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$：n为数组长度</li><li>空间复杂度: $O(n)$或$O(1)$。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ratings.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">int</span> values[] = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n - <span class="number">1</span> &amp;&amp; ratings[i + <span class="number">1</span>] &lt; ratings[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= start; j--) &#123;</span><br><span class="line">                values[j] = i - j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (start &gt; <span class="number">0</span> &amp;&amp; ratings[start - <span class="number">1</span>] &lt; ratings[start]) &#123;</span><br><span class="line">                values[start] = Math.max(values[start], values[start - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            total += values[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ratings.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n - <span class="number">1</span> &amp;&amp; ratings[i + <span class="number">1</span>] &lt; ratings[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= start; j--) &#123;</span><br><span class="line">                total += i - j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (start &gt; <span class="number">0</span> &amp;&amp; ratings[start - <span class="number">1</span>] &lt; ratings[start]) &#123;</span><br><span class="line">                total += Math.max(<span class="number">0</span>, pre + <span class="number">1</span> - i + start);</span><br><span class="line">                <span class="keyword">if</span> (i == start) pre++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    pre = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1227. 飞机座位分配概率</title>
      <link href="/2024/10/04/%E3%80%90%E6%95%B0%E5%AD%A6%E3%80%911227-%E9%A3%9E%E6%9C%BA%E5%BA%A7%E4%BD%8D%E5%88%86%E9%85%8D%E6%A6%82%E7%8E%87/"/>
      <url>/2024/10/04/%E3%80%90%E6%95%B0%E5%AD%A6%E3%80%911227-%E9%A3%9E%E6%9C%BA%E5%BA%A7%E4%BD%8D%E5%88%86%E9%85%8D%E6%A6%82%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/airplane-seat-assignment-probability/description/">1227. 飞机座位分配概率</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>由于这道题后面人的选择对前面人的选择没有影响，而且题目中隐约可以看出存在利用更小规模的最优子结构来求解的可能，这道题可以尝试用动态规划的思路来求解，设<code>f(n)</code>为截止到第<code>n</code>个人时，第<code>n</code>个人坐到自己位置的概率。</p><p>这样，当<code>n&gt;=3</code>时，就可以根据第一个人坐的情况分为三种情况：</p><ol><li>坐到自己的位置，$\frac 1n$的概率，此时<code>n</code>坐到自己位置的概率为<code>1</code>。</li><li>坐到n的位置，$\frac 1n$的概率，此时<code>n</code>坐到自己位置的概率为<code>0</code>。</li><li>坐到其他的位置，每个位置$\frac 1n$的概率，设该位置为<code>i</code>，则<code>1</code>之后、<code>i</code>之前的位置一定是正确的，<code>1</code>和<code>i</code>之后一共有<code>n - i + 1</code>个位置，同时还有同样多的人没有入场，而且第<code>i</code>号面临和1一样的情况，即他也要随机坐一个位置，并且他不是最后一个人，因此转换为规模为<code>n - i + 1</code>的子问题。</li></ol><p>这样，就可以得出递推式，将<code>n-1</code>带入递推式，再将两式相减即可求出解。</p><blockquote><p>详见<a href="https://leetcode.cn/problems/airplane-seat-assignment-probability/solutions/664495/fei-ji-zuo-wei-fen-pei-gai-lu-by-leetcod-gyw4/">官解</a>。</p></blockquote><h1 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h1><p>当时觉得动态规划难解，没有想出正确的最优子结构，就开始选择尝试模拟所有情况来暴力求解，但是这样时间复杂度非常高（阶乘）。在做题的时候一定不能蛮做，首先要排除时间复杂度不够的做法，如果全是不够的话需要看是否没有找出其中的数学关系。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(1)$</li><li>空间复杂度: $O(1)$</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">nthPersonGetsNthSeat</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3306. 元音辅音字符串计数 II</title>
      <link href="/2024/10/02/%E3%80%90%E6%81%B0%E5%A5%BD%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%913306-%E5%85%83%E9%9F%B3%E8%BE%85%E9%9F%B3%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%A1%E6%95%B0-II/"/>
      <url>/2024/10/02/%E3%80%90%E6%81%B0%E5%A5%BD%E5%9E%8B%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%913306-%E5%85%83%E9%9F%B3%E8%BE%85%E9%9F%B3%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%A1%E6%95%B0-II/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/count-of-substrings-containing-every-vowel-and-k-consonants-ii/description/">3306. 元音辅音字符串计数 II</a><br>周赛时没做出来，思路见<a href="https://leetcode.cn/problems/count-of-substrings-containing-every-vowel-and-k-consonants-ii/solutions/2934309/liang-ci-hua-chuang-pythonjavacgo-by-end-2lpz/">灵茶山艾府</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这题初做没有做出来，因为没有理解双指针滑动窗口的特点：需要保证维护的子串满足一定的单调性，即长度变长，只可能更满足或者保持现状；变短反之。但是，如果任务是<code>恰好型</code>，并不能说越长越容易恰好，可能情况会变坏，所以是不能直接用双指针来做的。</p><p>但是，我们可以把问题进行转换，至少有五个元音字母的条件不变，<strong>恰好</strong>包含 k 个辅音字母的条件，可以转为以下两个<strong>至少型</strong>任务：</p><ol><li>每个元音字母至少出现一次，并且至少包含<code>k</code>个辅音字母的子串个数。</li><li>每个元音字母至少出现一次，并且至少包含<code>k+1</code>个辅音字母的子串个数。</li></ol><p>这样，只需要两个任务的答案相减，就可以求出恰好k个的答案。</p><h1 id="Java解题技巧"><a href="#Java解题技巧" class="headerlink" title="Java解题技巧"></a>Java解题技巧</h1><p>HashMap使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m.merge(key, <span class="number">1</span>, Integer::sum);</span><br><span class="line">m.merge(key, -<span class="number">1</span>, Integer::sum)</span><br></pre></td></tr></table></figure><p>可以不用判空地进行Map的值增减操作。</p><p>另外，要判断是否为元音，可以使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;aeiou&quot;</span>.indexOf(out) &gt;= <span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$，双指针两次遍历一遍数组。</li><li>空间复杂度: $O(1)$。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">countOfSubstrings</span><span class="params">(String word, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = word.toCharArray();</span><br><span class="line">        <span class="keyword">return</span> f(s, k) - f(s, k + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">f</span><span class="params">(<span class="type">char</span>[] word, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 这里用哈希表实现，替换成数组会更快</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; cnt1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">// 每种元音的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt2</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 辅音个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> b : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;aeiou&quot;</span>.indexOf(b) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                cnt1.merge(b, <span class="number">1</span>, Integer::sum); <span class="comment">// ++cnt1[b]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cnt1.size() == <span class="number">5</span> &amp;&amp; cnt2 &gt;= k) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">out</span> <span class="operator">=</span> word[left];</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;aeiou&quot;</span>.indexOf(out) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cnt1.merge(out, -<span class="number">1</span>, Integer::sum) == <span class="number">0</span>) &#123; <span class="comment">// --cnt1[out] == 0</span></span><br><span class="line">                        cnt1.remove(out);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cnt2--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1870. 准时到达的列车最小时速</title>
      <link href="/2024/10/02/1870-%E5%87%86%E6%97%B6%E5%88%B0%E8%BE%BE%E7%9A%84%E5%88%97%E8%BD%A6%E6%9C%80%E5%B0%8F%E6%97%B6%E9%80%9F/"/>
      <url>/2024/10/02/1870-%E5%87%86%E6%97%B6%E5%88%B0%E8%BE%BE%E7%9A%84%E5%88%97%E8%BD%A6%E6%9C%80%E5%B0%8F%E6%97%B6%E9%80%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/minimum-speed-to-arrive-on-time/description/">1870. 准时到达的列车最小时速</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题目中，速度越大越能在要求的时间内到达，而我们要求最小时间，很自然地就联想到二分答案。</p><p>但是有一些小细节需要注意，例如，答案的右边界是<code>max(dist)</code>，因为<code>hour</code>是最大小数位为二位的小数，因此最小可能需要的时间是需要除以<code>0.01</code>的。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(nlogU)$，<code>U</code>为<code>max(dist)</code></li><li>空间复杂度: $O(1)$</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSpeedOnTime</span><span class="params">(<span class="type">int</span>[] dist, <span class="type">double</span> hour)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> dist.length;</span><br><span class="line">        <span class="keyword">if</span> (hour &lt;= n - <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[i] &gt; max) max = dist[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> max * <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">now</span> <span class="operator">=</span> cal(m, dist, hour);</span><br><span class="line">            <span class="keyword">if</span> (now &lt; hour) &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (now &gt; hour) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> speed, <span class="type">int</span> [] dist, <span class="type">double</span> hour)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> dist.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            now += Math.ceil(dist[i] / (<span class="type">double</span>) speed);</span><br><span class="line">        &#125;</span><br><span class="line">        now += dist[n - <span class="number">1</span>] / (<span class="type">double</span>) speed;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>做力扣的思考</title>
      <link href="/2024/09/30/%E5%81%9A%E5%8A%9B%E6%89%A3%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2024/09/30/%E5%81%9A%E5%8A%9B%E6%89%A3%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>到目前为止，做的题目大多是中等题，从没做出的题的经验中，略微感觉有些思路可循。</p><p>在我看来，要做出一道题目需要想到以下几点：</p><ol><li>读题目，观察是否符合某一数据结构或者算法模式。</li><li>如果第一步想到的方法效率不高或者找不到直接对应的模式，思考题目是否隐含了什么可推导出的条件。</li><li>尝试将题目的说法进行等价转换，以符合算法或者数据结构的模式。</li><li>尝试使用逆向思维、转换做法等方式，以优化。</li></ol><p>然后，对于算法和数据机构的掌握就是核心的基础了，需要多多做题磨练。也希望在练习的途中，能发现更多解题的新思路。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1845. 座位预约管理系统</title>
      <link href="/2024/09/30/1845-%E5%BA%A7%E4%BD%8D%E9%A2%84%E7%BA%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/09/30/1845-%E5%BA%A7%E4%BD%8D%E9%A2%84%E7%BA%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/seat-reservation-manager/description/">1845. 座位预约管理系统</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先想到的是使用最小堆来模拟，因为题目的<code>reserve</code>返回的是最小可预约座位，并把座位变为不可预约。如果用最小堆来维护<strong>可预约座位</strong>，那么<code>reserve</code>操作就是出堆操作；<code>unreserve</code>就是入堆操作。出入堆操作时间复杂度为$O(logn)$。</p><p>但是如果<code>n</code>太大，初始化操作就会消耗太多的时间。我们可以用逆向思维：如果我们维护<strong>曾经被预约过，又被释放的座位</strong>，就不需要初始化操作。当执行预约操作时，如果堆里有座位，就将执行出堆操作。否则返回<code>已被预约的座位数+1</code>；当执行取消预约时，将该座位入堆。</p><blockquote><p>优化的方法参考<a href="https://leetcode.cn/problems/seat-reservation-manager/solutions/2838121/liang-chong-fang-fa-wei-hu-ke-yu-yue-de-tmub8/">灵茶山艾府</a></p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: 初始化$O(1)$,<code>reserve</code>和<code>unreserve</code>为$O(log q)$，<code>q</code>为<code>reserve</code>的调用次数。</li><li>空间复杂度: $O(q)$。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeatManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;Integer&gt; available = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> seats;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SeatManager</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reserve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!available.isEmpty()) &#123; <span class="comment">// 有空出来的椅子</span></span><br><span class="line">            <span class="keyword">return</span> available.poll(); <span class="comment">// 坐编号最小的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ++seats; <span class="comment">// 添加一把新的椅子</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unreserve</span><span class="params">(<span class="type">int</span> seatNumber)</span> &#123;</span><br><span class="line">        available.add(seatNumber); <span class="comment">// 有人离开了椅子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>238. 除自身以外数组的乘积</title>
      <link href="/2024/09/29/238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/"/>
      <url>/2024/09/29/238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/product-of-array-except-self/description/">238. 除自身以外数组的乘积</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>在不能使用除法的情况下，考虑每个答案的组成方式：第<code>i</code>位的结果为其前缀乘积和后缀乘积之积。离线求解前后缀乘积时间复杂度为$O(n)$，符合题目要求。</p><p>题目中给了个提示，可以在$O(1)$（不考虑返回数组）的情况下完成。但是完全不存储前后缀是没法在$O(n)$的复杂度下完成的，应该想到可以暂时把数据存在返回数组里。</p><p>这样，我们只需先计算一遍后缀积，然后在计算结果时，保留当前前缀和即可。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$：遍历两次数组。</li><li>空间复杂度: $O(1)$：实际上是$O(n)$，如题目所说不考虑返回数组空间时$O(1)$。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> r[] = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        r[n - <span class="number">1</span>] = nums[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            r[i] = r[i + <span class="number">1</span>] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        r[<span class="number">0</span>] = r[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            r[i] = pre * r[i + <span class="number">1</span>];</span><br><span class="line">            pre *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        r[n - <span class="number">1</span>] = pre;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2073. 买票需要的时间</title>
      <link href="/2024/09/29/2073-%E4%B9%B0%E7%A5%A8%E9%9C%80%E8%A6%81%E7%9A%84%E6%97%B6%E9%97%B4/"/>
      <url>/2024/09/29/2073-%E4%B9%B0%E7%A5%A8%E9%9C%80%E8%A6%81%E7%9A%84%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/time-needed-to-buy-tickets/description/">2073. 买票需要的时间</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>先分两段来考虑：</p><ol><li>刚开始第k个人及之前的人买票，需要<code>k + 1</code>的时间，并且这些人需要的票减一。</li><li>接下来每轮，前方的人若是需要买的票少于第二段开始<code>k</code>的票，则他们一定会买完自己的票；反之，则购买第二段开始<code>k</code>的票数的票。</li></ol><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$：一次遍历数组。</li><li>空间复杂度: $O(n)$：若干变量。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">timeRequiredToBuy</span><span class="params">(<span class="type">int</span>[] tickets, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> k + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tickets.length;</span><br><span class="line">        tickets[k]--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; k) &#123;</span><br><span class="line">                tickets[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tickets[i] &gt; tickets[k]) &#123;</span><br><span class="line">                ret += tickets[k];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ret += tickets[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>380. O(1) 时间插入、删除和获取随机元素</title>
      <link href="/2024/09/28/380-O(1)%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/"/>
      <url>/2024/09/28/380-O(1)%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/insert-delete-getrandom-o1/description/">380. O(1) 时间插入、删除和获取随机元素</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>哈希表可以完成$O(1)$的插入和删除，但是无法用下标获得元素。考虑到<strong>变长数组</strong>可以在$O(1)$的时间完成获取元素，我们只需要再维护一个变长数组即可。用哈希表维护元素即它们在变长数组的位置。在添加元素时，把元素添加到变长数组的末端；在删除元素时，更新数组末端元素在哈下表的位置，用末端元素替换数组被删除元素。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(1)$，哈希表插入删除时间都是$O(1)$，删除数组最后一个元素也是$O(1)$。</li><li>空间复杂度: $O(n)$，哈希表和数组。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; s;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; a;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RandomizedSet</span><span class="params">()</span> &#123;</span><br><span class="line">        s = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        random = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.containsKey(val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        s.put(val, count);</span><br><span class="line">        a.add(val);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!s.containsKey(val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        count--;</span><br><span class="line">        s.put(a.get(count), s.get(val));</span><br><span class="line">        a.set(s.get(val), a.get(count));</span><br><span class="line">        a.remove(count);</span><br><span class="line">        s.remove(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.get(random.nextInt(count));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>274. H指数</title>
      <link href="/2024/09/28/274-H%20%E6%8C%87%E6%95%B0/"/>
      <url>/2024/09/28/274-H%20%E6%8C%87%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/h-index/description/">274. H 指数</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>看到题目中有<code>至少h篇大于等于h</code>这样的比大小字样，可以想到排序数组，这样可以使数组具有单调性。</p><p>将数组<strong>从大到小</strong>排序，用指针<code>i</code>遍历数组，如果有第<code>i</code>大的引用小于<code>i + 1</code>（个数），那么显然就不存在<code>i + 1</code>个大于等于<code>i + 1</code>的文章（之后的文章都比它小），这样所求的<code>i</code>就是H指数。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(nlogn)$，排序的时间消耗，在本题里数据范围较小，如果使用计数排序可以降到$O(n+k)$</li><li>空间复杂度: $O(1)$，只需若干常量。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] citations)</span> &#123;</span><br><span class="line">        Arrays.sort(citations);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> citations.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (citations[i] &lt; n - i) &#123;</span><br><span class="line">                <span class="keyword">return</span> n - i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2516. 每种字符至少取 K 个</title>
      <link href="/2024/09/27/2516-%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E8%87%B3%E5%B0%91%E5%8F%96K%E4%B8%AA/"/>
      <url>/2024/09/27/2516-%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E8%87%B3%E5%B0%91%E5%8F%96K%E4%B8%AA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/description/">2516. 每种字符至少取 K 个</a></p></blockquote><h1 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h1><p>看到从两边求解，我首先想到的是，先尝试贪心试试？每次如果某个字符未达到上限就取，在两边都没有时，哪边离得最近就取：但这样显然是不正确的。</p><p>接下来想到的是记忆化搜索或者说动态规划。但是这题又不大满足<strong>无后效性</strong>这一特点，前面的操作对于后面子字符串是有影响的。</p><p>于是我尝试了暴力搜索，但是效率太低，最后超时了。</p><h1 id="正确思路"><a href="#正确思路" class="headerlink" title="正确思路"></a>正确思路</h1><p>很多题目都不能直接从他本身的描述直接开始做，需要发掘其中的隐藏要点。本题中由于从两边考虑多种方法都难以求解，归根结底原因很大程度就是两边求解是不连续的，那么反过来想，中间的字符串不就是连续的吗？</p><p>而只要字符串是连续的，我们就可以自然而然想到双指针滑动窗口的解决方法。对于所给问题，实际上可以首先转为求解<strong>余下符合条件的最长中间子字符串</strong>，本质上也是对于每个要求的字符，要找出正好符合一定数量的字串。这样考虑双指针就很容易了，我们维护<code>i</code>到<code>j</code>为除去两端的中间子串，每次若<code>j</code>位置字符没有达到所需数量就自增<code>j</code>，否则自增<code>i</code>的位置，以减少<code>j</code>位置字符的计数，同时维护最长的中间字串长度，这样即可求解。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$，遍历两次数组。</li><li>空间复杂度: $O(1)$，若干常量，和常量大小map。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">takeCharacters</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span> [] cs = s.toCharArray();</span><br><span class="line">        Map&lt;Character, Integer&gt; m = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        m.put(<span class="string">&#x27;a&#x27;</span>, -k);</span><br><span class="line">        m.put(<span class="string">&#x27;b&#x27;</span>, -k);</span><br><span class="line">        m.put(<span class="string">&#x27;c&#x27;</span>, -k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            m.put(cs[i], m.get(cs[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer value : m.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            m.put(cs[j], m.get(cs[j]) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j &amp;&amp; m.get(cs[j]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                m.put(cs[i], m.get(cs[i]) + <span class="number">1</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            count = Math.max(count, j - i + <span class="number">1</span>);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>45. 跳跃游戏 II</title>
      <link href="/2024/09/21/45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II/"/>
      <url>/2024/09/21/45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/jump-game/description/">55. 跳跃游戏</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>和55-跳跃游戏一样，我们在不断往前跳的过程中，可跳到的范围会越来越大。本题要求解的是跳到最后的最短次数，可以想到使用贪心的思想：对于<code>i</code>之后可以跳到的所有点，我们选择跳到<strong>能够到达范围最远</strong>的点，显然这样的跳跃（相对于本次选择的其他点）对于减少步数是最优的。不断遍历这个过程，直到能够到达最后点即可。</p><p>这样，我们只需要遍历一遍数组就能找到最少的跳跃次数。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$：最多遍历一遍数组。</li><li>空间复杂度: $O(1)$：若干常量。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">now</span> <span class="operator">=</span> right;</span><br><span class="line">            <span class="keyword">if</span> (now &gt;= n - <span class="number">1</span>) <span class="keyword">return</span> ret;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= now) &#123;</span><br><span class="line">                right = Math.max(right, i + nums[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2376. 统计特殊整数</title>
      <link href="/2024/09/20/%E3%80%90%E6%95%B0%E4%BD%8Ddp%E3%80%912376-%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%AE%8A%E6%95%B4%E6%95%B0/"/>
      <url>/2024/09/20/%E3%80%90%E6%95%B0%E4%BD%8Ddp%E3%80%912376-%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%AE%8A%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/count-special-integers/description/">2376. 统计特殊整数</a><br>记录新学到的知识点，思路见<a href="https://leetcode.cn/problems/count-special-integers/solutions/1746956/shu-wei-dp-mo-ban-by-endlesscheng-xtgx/">灵茶山艾府</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="位运算和集合论"><a href="#位运算和集合论" class="headerlink" title="位运算和集合论"></a>位运算和集合论</h2><p>通过将位运算和集合论结合，可以用来表示<strong>数位状态</strong>，用来作为数位dp的一部分使用。</p><p>具体方法是，对于从右到左第<code>i</code>位数，如果为1就代表<code>i</code>这个数在集合中。对于要枚举的范围不大（例如数位D，范围为0-9）的数来说，可以很方便地用一个整数来存储数位的访问状态。</p><p>取出第<code>i</code>位数和加入第<code>i</code>位数都是$O(D)$的时间复杂度。设集合为x，则取出放入操作可以用位运算求解：</p><ol><li>取出：<code>x &gt;&gt; i &amp; 1</code></li><li>放入：<code>1 &lt;&lt; i | x</code></li></ol><h2 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h2><p>通过记忆化搜索来找出所有可能的状态，这样可以把需要遍历的情况压缩到状态数乘以单个状态计算时间的大小，状态数在本体中为位数（很小）乘以$O(2^D)$，后者是集合可能有的所有情况。同时单个状态的计算时间通常是很小的。这样就大大减小了计算的量，可以高效地找出所有符合条件的情况。</p><h2 id="对于数位问题的技巧"><a href="#对于数位问题的技巧" class="headerlink" title="对于数位问题的技巧"></a>对于数位问题的技巧</h2><h3 id="1-对于不能超过最大数n的解决方式"><a href="#1-对于不能超过最大数n的解决方式" class="headerlink" title="1.对于不能超过最大数n的解决方式"></a>1.对于不能超过最大数<code>n</code>的解决方式</h3><p>设置一个<code>isLimit</code>标志，表示当前位置是否受到约束，即如果超过<code>s[i]</code>则非法。若<code>isLimit</code>为true，则当前可以遍历的数就存在一个上限<code>s[i]</code>，否则为9。在记忆化搜索的过程中维护和更新这个标志。</p><h3 id="2-对于前置不能存在0，又可能为空的解决方式"><a href="#2-对于前置不能存在0，又可能为空的解决方式" class="headerlink" title="2.对于前置不能存在0，又可能为空的解决方式"></a>2.对于前置不能存在0，又可能为空的解决方式</h3><p>设置一个<code>isNum</code>标志，表示前一位是否有填数字。如果前一位空，则这一位可以空（直接遍历下一位），也可以填1-9；如果前一位不空，则这一位只能填0-9。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(mD2^D)$。其中<code>m</code>为<code>s</code>的长度，<code>D</code>为10。</li><li>空间复杂度: $O(m2^D)$。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSpecialNumbers</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = Integer.toString(n).toCharArray();</span><br><span class="line">        <span class="type">int</span>[][] memo = <span class="keyword">new</span> <span class="title class_">int</span>[s.length][<span class="number">1</span> &lt;&lt; <span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : memo) &#123;</span><br><span class="line">            Arrays.fill(row, -<span class="number">1</span>); <span class="comment">// -1 表示没有计算过</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span>, s, memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> mask, <span class="type">boolean</span> isLimit, <span class="type">boolean</span> isNum, <span class="type">char</span>[] s, <span class="type">int</span>[][] memo)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == s.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> isNum ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// isNum 为 true 表示得到了一个合法数字</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isLimit &amp;&amp; isNum &amp;&amp; memo[i][mask] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][mask]; <span class="comment">// 之前计算过</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!isNum) &#123; <span class="comment">// 可以跳过当前数位</span></span><br><span class="line">            res = dfs(i + <span class="number">1</span>, mask, <span class="literal">false</span>, <span class="literal">false</span>, s, memo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果前面填的数字都和 n 的一样，那么这一位至多填数字 s[i]（否则就超过 n 啦）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> isLimit ? s[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>;</span><br><span class="line">        <span class="comment">// 枚举要填入的数字 d</span></span><br><span class="line">        <span class="comment">// 如果前面没有填数字，则必须从 1 开始（因为不能有前导零）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> isNum ? <span class="number">0</span> : <span class="number">1</span>; d &lt;= up; d++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mask &gt;&gt; d &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123; <span class="comment">// d 不在 mask 中，说明之前没有填过 d</span></span><br><span class="line">                res += dfs(i + <span class="number">1</span>, mask | (<span class="number">1</span> &lt;&lt; d), isLimit &amp;&amp; d == up, <span class="literal">true</span>, s, memo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isLimit &amp;&amp; isNum) &#123;</span><br><span class="line">            memo[i][mask] = res; <span class="comment">// 记忆化</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring和MybatisPlus踩坑</title>
      <link href="/2024/09/16/Spring%E5%92%8CMybatisPlus%E8%B8%A9%E5%9D%91/"/>
      <url>/2024/09/16/Spring%E5%92%8CMybatisPlus%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1 id="发现build后还有原来的代码"><a href="#发现build后还有原来的代码" class="headerlink" title="发现build后还有原来的代码"></a>发现build后还有原来的代码</h1><p>build只会加缓存，不会减缓存，因此如果删除文件，需要rebuild。</p><h1 id="Bean冲突"><a href="#Bean冲突" class="headerlink" title="Bean冲突"></a>Bean冲突</h1><p>遇到了processBean冲突，排查后发现是框架文件里有这个名称的bean，因此换个名称就可以解决。不要把名称设的太宽泛。</p><h1 id="MybatisPlus学习"><a href="#MybatisPlus学习" class="headerlink" title="MybatisPlus学习"></a>MybatisPlus学习</h1><p>过于细化的框架损失自由度，并且会引起很多难以解决的bug，只有在组里有前人对框架非常熟悉，且框架经过检验时，使用框架才好。</p><p>所以采用适用性相对较广的MybatisPlus。</p><p>后端设置UUID：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableId(type = IdType.ASSIGN_UUID)</span>  </span><br><span class="line"><span class="keyword">private</span> String id;</span><br></pre></td></tr></table></figure><p>后端分页：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ProcessingMapper.java</span></span><br><span class="line"><span class="meta">@Select(&quot;SELECT * FROM &quot; + TABLE_NAME)</span>  </span><br><span class="line">IPage&lt;Processing&gt; <span class="title function_">selectPageVo</span><span class="params">(IPage&lt;?&gt; page)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ProcessingService.java</span></span><br><span class="line"><span class="keyword">public</span> IPage&lt;Processing&gt; <span class="title function_">getProcessingPage</span><span class="params">(<span class="type">int</span> currentPage, <span class="type">int</span> pageSize)</span>&#123;  </span><br><span class="line">    Page&lt;Processing&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(currentPage, pageSize);  </span><br><span class="line">    <span class="keyword">return</span> processingMapper.selectPageVo(page);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Post的时候后端一直报错"><a href="#Post的时候后端一直报错" class="headerlink" title="Post的时候后端一直报错"></a>Post的时候后端一直报错</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误: nested exception is org.apache.ibatis.reflection.ReflectionException: There is no getter <span class="keyword">for</span> property named <span class="string">&#x27;rawData&#x27;</span> in <span class="string">&#x27;class com.jeeplus.processmanage.domain.Processing&#x27;</span></span><br></pre></td></tr></table></figure><p>一直在前端找，都没找到哪里有rawData这个东西，后来发现是后端的<code>Mapper</code>当时复制了另一个文件，里面有insert这个东西，自己没有注意到。所以，出现莫名其妙的错误时，<strong>要回想一下自己所没有注意到，特别是复制黏贴的事物</strong>。<del>复制黏贴还是少用为好。</del></p><h2 id="报SQL语句错误"><a href="#报SQL语句错误" class="headerlink" title="报SQL语句错误"></a>报SQL语句错误</h2><p>procedure是一个保留关键字，不能作为列名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误: ### Error updating database. Cause: java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version <span class="keyword">for</span> the right syntax to use near <span class="string">&#x27;procedure, equipment_used, operator_info, material_id ) VALUES ( &#x27;</span><span class="number">183558877960</span><span class="string">&#x27; at line 4 ### The error may exist in com/jeeplus/processmanage/mapper/ProcessingMapper.java (best guess) ### The error may involve com.jeeplus.processmanage.mapper.ProcessingMapper.insert-Inline ### The error occurred while setting parameters ### SQL: INSERT INTO process_process ( id, technique, procedure, equipment_used, operator_info, material_id ) VALUES ( ?, ?, ?, ?, ?, ? ) ### Cause: java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;</span>procedure, equipment_used, operator_info, material_id ) VALUES ( <span class="string">&#x27;183558877960&#x27;</span> at line <span class="number">4</span> ; bad SQL grammar []; nested exception is java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version <span class="keyword">for</span> the right syntax to use near <span class="string">&#x27;procedure, equipment_used, operator_info, material_id ) VALUES ( &#x27;</span><span class="number">183558877960</span><span class="string">&#x27; at line 4</span></span><br></pre></td></tr></table></figure><blockquote><p>在 SQL 语言中，<code>PROCEDURE</code> 是一个保留字，用于定义存储过程。存储过程是一组为了完成特定功能的 SQL 语句集合，它可以在数据库中被保存和重用。</p></blockquote><p>可见sql和spring是要注意命名错误的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2390. 从字符串中移除星号</title>
      <link href="/2024/09/14/%E3%80%90%E6%A0%88%E3%80%912390-%E4%BB%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%A7%BB%E9%99%A4%E6%98%9F%E5%8F%B7/"/>
      <url>/2024/09/14/%E3%80%90%E6%A0%88%E3%80%912390-%E4%BB%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%A7%BB%E9%99%A4%E6%98%9F%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/removing-stars-from-a-string/description/">2390. 从字符串中移除星号</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>想到用栈维护，思路就很清晰了。</p><p>要想到使用栈，重点是注意到每次都是对<strong>最后一个元素</strong>进行操作的，正好符合栈的性质。</p><blockquote><p>这题我错误地想使用双指针的做法来做，结果写法挺复杂不说，还TLE了。。。这就是没有抓住关键性质的后果。</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$</li><li>空间复杂度: $O(n)$</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeStars</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                st.deleteCharAt(st.length() - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2576.求出最多标记的下标</title>
      <link href="/2024/09/13/%E3%80%90%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%E3%80%912576-%E6%B1%82%E5%87%BA%E6%9C%80%E5%A4%9A%E6%A0%87%E8%AE%B0%E4%B8%8B%E6%A0%87/"/>
      <url>/2024/09/13/%E3%80%90%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%E3%80%912576-%E6%B1%82%E5%87%BA%E6%9C%80%E5%A4%9A%E6%A0%87%E8%AE%B0%E4%B8%8B%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/description/">2576. 求出最多标记下标</a>&gt;<br>思考贪心方向错误，记录对于<a href="https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/solutions/2134078/er-fen-da-an-pythonjavacgo-by-endlessche-t9f5">灵茶山艾府解答</a>的理解。</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>首先还是思考题目中可能存在的隐藏性质，来把题目转为可计算机求解的另一种表达方式。可以发现，<strong>如果数组有k个匹配对，那么前k个元素和最后k个元素一定能一一匹配上</strong>。这一点其实用反证法很好想，<code>i</code>从<code>0</code>开始自增到<code>k</code>，如果第<code>i</code>个元素的两倍小于第<code>n-k+i</code>个元素，那么就只能往第<code>n-k+1</code>个以后去找，但是这样就没有k个配对了。</p><p>接下来就是如何利用这个性质。</p><p>我们可以利用<strong>k个匹配对</strong>这个关键点，尝试不同的<strong>最大匹配数k</strong>。为了尽可能少的遍历<code>k</code>值，自然想到二分答案的做法。显然<code>k</code>越大的情况下，<strong>可以匹配的对数</strong>越多，符合二分搜索的条件。二分搜索<code>k</code>，然后验证前述性质，如果满足就尝试取更大的<code>k</code>值，反之同理即可。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>起初想到的思路是首先将数组进行排序，然后使用贪心，每次将最大的和最接近其二分之一的数进行匹配，但是这样的做法可以举出反例<code>3,4,6,8,100,101</code>，是不正确的。</p><p>对于这一类题目，在一个性质不行的时候，要试着把<strong>答案</strong>也作为一个变量，来思考其他的性质，这样可以利用<strong>二分法</strong>，是非常高效的。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(nlogn)$，二分答案$O(logn)$复杂度，<code>n</code>为数组元素。</li><li>空间复杂度: $O(1)$，若干常量空间。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxNumOfMarkedIndices</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length / <span class="number">2</span>; <span class="comment">// 开区间</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(nums, mid)) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right * <span class="number">2</span>; <span class="comment">// 最多匹配 left 对，有 left * 2 个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] * <span class="number">2</span> &gt; nums[nums.length - k + i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对比方法HG-prediction代码调试</title>
      <link href="/2024/09/06/%E5%AF%B9%E6%AF%94%E6%96%B9%E6%B3%95HG-prediction%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/"/>
      <url>/2024/09/06/%E5%AF%B9%E6%AF%94%E6%96%B9%E6%B3%95HG-prediction%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>给定了xslx格式的血糖数据(列为病人编号，时间，血糖值，每个病人一个文件,有大量文件)，要在HG-predicition代码中运行该数据集。</p><h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><p>通过阅读代码，可知该方法使用的是pkl格式的数据，并提供了一个convert-data方法，来把字典格式的pkl数据转为代码处理所需的单维向量格式的pkl数据。</p><p>首先把xslx格式的数据统一合并到一个csv格式的文件中（因为超过了xlsx的行数上限）。</p><p>然后转为字典格式的pkl数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 读取CSV文件</span></span><br><span class="line">    csv_file = <span class="string">&#x27;data.csv&#x27;</span></span><br><span class="line">    data = pd.read_csv(csv_file)</span><br><span class="line">    <span class="comment"># 将CSV数据转换为函数所需的字典格式</span></span><br><span class="line">    pkl_data = &#123;&#125;</span><br><span class="line">    date_formats = [<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>, <span class="string">&#x27;%Y-%m-%d %H:%M&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> index, row <span class="keyword">in</span> data.iterrows():</span><br><span class="line">        patient_id = row[<span class="string">&#x27;住院号&#x27;</span>]</span><br><span class="line">        <span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line">        <span class="keyword">for</span> date_format <span class="keyword">in</span> date_formats:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                timestamp = <span class="built_in">int</span>(datetime.strptime(row[<span class="string">&#x27;测量时间&#x27;</span>], date_format).timestamp())</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> ValueError:</span><br><span class="line">                <span class="keyword">continue</span>      </span><br><span class="line">        value = row[<span class="string">&#x27;测量值&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> patient_id <span class="keyword">not</span> <span class="keyword">in</span> pkl_data:</span><br><span class="line">            pkl_data[patient_id] = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> timestamp <span class="keyword">not</span> <span class="keyword">in</span> pkl_data[patient_id]:</span><br><span class="line">            pkl_data[patient_id][timestamp] = &#123;&#125;</span><br><span class="line">        pkl_data[patient_id][timestamp][<span class="string">&#x27;glucose&#x27;</span>] = value</span><br><span class="line">        pkl_data[patient_id][timestamp][<span class="string">&#x27;Time&#x27;</span>] = timestamp</span><br><span class="line"></span><br><span class="line">    pkl_to_X_y(pkl_data, <span class="string">&#x27;.&#x27;</span>, blen=<span class="number">9</span>, flen=<span class="number">6</span>, ignore_NA=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>原始数据没有聚类标签，正好可以使用代码提供的<code>judge_label</code>函数判断，注意这里单位不同，要把<code>70</code>改为<code>7</code>。</p><h1 id="提示空数组错误"><a href="#提示空数组错误" class="headerlink" title="提示空数组错误"></a>提示空数组错误</h1><p>在更改了数据格式之后，发现<code>pkl_to_X_y</code>函数读不到数据，而这一段代码会跳过不符合要求的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> ignore_NA <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">any</span>([t <span class="keyword">not</span> <span class="keyword">in</span> feats_dict <span class="keyword">for</span> t <span class="keyword">in</span> b_time_steps]):</span><br><span class="line">                    <span class="comment"># some backward time steps not available</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">any</span>([t <span class="keyword">not</span> <span class="keyword">in</span> feats_dict <span class="keyword">for</span> t <span class="keyword">in</span> f_time_steps]):</span><br><span class="line">                    <span class="comment"># some forward time steps not available</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>因此考虑到是否是因为什么原因导致数据不符合要求，发现对于下面这段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">            b_time_steps = [sec - i * <span class="number">300</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">0</span>, blen))]</span><br><span class="line"></span><br><span class="line">            f_time_steps = [sec + j * <span class="number">300</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, flen + <span class="number">1</span>)]</span><br></pre></td></tr></table></figure><p>其数据间隔5分钟，而现在要使用的数据间隔为15分钟，更改为<code>900</code>就可以运行。</p><h1 id="概念学习"><a href="#概念学习" class="headerlink" title="概念学习"></a>概念学习</h1><p>之前没有了解过时序数列预测的深度学习算法，这里学到了几个概念：</p><h2 id="1-预测长度"><a href="#1-预测长度" class="headerlink" title="1.预测长度"></a>1.预测长度</h2><p>“forecast length”：预测长度<br>“backcast length”：回溯长度</p><ol><li><strong>Forecast Length</strong>：这是指模型需要预测未来的时间步长的数量。</li><li><strong>Backcast Length</strong>：这是指在训练模型时，用于估计模型参数的历史数据的时间步长的数量。Backcast length 用于确定模型在进行预测之前需要观察多少历史数据。</li></ol><h2 id="2-度量指标"><a href="#2-度量指标" class="headerlink" title="2.度量指标"></a>2.度量指标</h2><p>MSE：预测值与实际值之差的平方的平均值。<br>RMSE：是MSE的平方根，和原数据同一个指标。<br>MAE：预测值与实际值之差的绝对值的平均值。</p><h2 id="3-早停策略"><a href="#3-早停策略" class="headerlink" title="3.早停策略"></a>3.早停策略</h2><p><code>patience</code>为连续多少次loss不下降后，就终止学习。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迁移doccano到新服务器</title>
      <link href="/2024/09/06/%E8%BF%81%E7%A7%BBdoccano%E5%88%B0%E6%96%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2024/09/06/%E8%BF%81%E7%A7%BBdoccano%E5%88%B0%E6%96%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="迁移方式"><a href="#迁移方式" class="headerlink" title="迁移方式"></a>迁移方式</h1><p>首先配置好服务器的ssh连接。<br>然后使用scp迁移。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r -C 服务器名称:源地址 目标地址</span><br></pre></td></tr></table></figure><h1 id="环境冲突"><a href="#环境冲突" class="headerlink" title="环境冲突"></a>环境冲突</h1><p>老服务器上的requirements写得不正确，配到新环境冲突很多。<br>因此到doccano的官方仓库查看，找到了poerty文件。</p><p>但是poerty很卡，使用GPT把poetry转为pip对应的requirments之后，再对比源环境，即可运行。</p><h1 id="报django找不到client文件的错误"><a href="#报django找不到client文件的错误" class="headerlink" title="报django找不到client文件的错误"></a>报django找不到client文件的错误</h1><p>前后端分容器时，如果后端要用到前端的文件，可能会找不到，比如django的template文件。</p><p>通过对照原服务器，得知了doccano将前端的dist文件夹放在后端文件夹中，并以此作为django的template。</p><h1 id="网络连接错误"><a href="#网络连接错误" class="headerlink" title="网络连接错误"></a>网络连接错误</h1><p>docker-compose中NGINX服务器的网络模式可改成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    network_mode: host</span><br></pre></td></tr></table></figure><p>以连接后端8099端口。</p><h1 id="找不到表的问题："><a href="#找不到表的问题：" class="headerlink" title="找不到表的问题："></a>找不到表的问题：</h1><p>web_1            |   File “&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;django&#x2F;db&#x2F;backends&#x2F;sqlite3&#x2F;base.py”, line 357, in execute<br>web_1            |     return Database.Cursor.execute(self, query, params)<br>web_1            | django.db.utils.OperationalError: no such table: auth_user</p><p>要使用cli.py 的migrate建表，然后create user</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command: /bin/sh -c &quot;python3 cli.py migrate &amp;&amp; python3 cli.py createuser &amp;&amp; python3 cli.py webserver --port 8099 &gt;&gt; webserver.txt&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> doccano </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024. 考试的最大困扰度</title>
      <link href="/2024/09/03/2024-%E8%80%83%E8%AF%95%E7%9A%84%E6%9C%80%E5%A4%A7%E5%9B%B0%E6%89%B0%E5%BA%A6/"/>
      <url>/2024/09/03/2024-%E8%80%83%E8%AF%95%E7%9A%84%E6%9C%80%E5%A4%A7%E5%9B%B0%E6%89%B0%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/description/">2024. 考试的最大困扰度</a><br>尝试了滑动窗口没做出来，这里记录官解的理解</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>由于字符串中的字符只有<code>t</code>和<code>f</code>，我们可以遍历每种字符最长串的长度，然后取最大值即可。</p><blockquote><p>之前在用滑动窗口做的时候没有想到这个做法，然后就很难想。</p></blockquote><p>给定指定字符，我们可以使用滑动窗口的方法，维护<code>left</code>到<code>right</code>这个区间为更改数量范围内的连续字符串。当<code>right</code>位置的字符不同时，如果更改字符的次数小于<code>k</code>，使用次数加一，否则不断右移<code>left</code>位置，直到找到第一个更改的地方为止。在<code>right</code>不断右移的过程中，记录能够到达的最大长度。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$，n为字符串长度，遍历字符串两次。</li><li>空间复杂度: $O(1)$。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxConsecutiveAnswers</span><span class="params">(String answerKey, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxConsecutiveChar(answerKey, k, <span class="string">&#x27;T&#x27;</span>), maxConsecutiveChar(answerKey, k, <span class="string">&#x27;F&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxConsecutiveChar</span><span class="params">(String answerKey, <span class="type">int</span> k, <span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> answerKey.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>, sum = <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            sum += answerKey.charAt(right) != ch ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (sum &gt; k) &#123;</span><br><span class="line">                sum -= answerKey.charAt(left++) != ch ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3142.判断矩阵是否满足条件</title>
      <link href="/2024/08/29/3142-%E5%88%A4%E6%96%AD%E7%9F%A9%E9%98%B5%E6%98%AF%E5%90%A6%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6/"/>
      <url>/2024/08/29/3142-%E5%88%A4%E6%96%AD%E7%9F%A9%E9%98%B5%E6%98%AF%E5%90%A6%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/check-if-grid-satisfies-conditions/description/">3142. 判断矩阵是否满足条件</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>遍历一遍数组，按照题目的要求进行条件判断。</p><blockquote><p>注意不能通过简单设置循环边界为<code>n-1</code>,<code>m-1</code>来满足下边和右边的格子存在，因为例如如果只有<code>i=n-1</code>而<code>j!=m-1</code>时，仍然是需要进行判断的。</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(mn)$，遍历一遍数组。</li><li>空间复杂度: $O(1)$，只需要开<code>i,j</code>两个变量。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">satisfiesConditions</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != grid.length - <span class="number">1</span> &amp;&amp; grid[i][j] != grid[i + <span class="number">1</span>][j] || j!=grid[<span class="number">0</span>].length-<span class="number">1</span> &amp;&amp;  grid[i][j] == grid[i][j+<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动态规划】3144.分割字符频率相等的最少子字符串</title>
      <link href="/2024/08/29/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%913144-%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E9%A2%91%E7%8E%87%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%91%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2024/08/29/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%913144-%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E9%A2%91%E7%8E%87%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%91%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/minimum-substring-partition-of-equal-character-frequency/description/">3144. 分割字符频率相等的最少子字符串</a><br>难度分1917，记录官解的理解</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>观察题目要求为最少平衡子字符串的划分方法，可以发现如果设子结构<code>dp[i]</code>为截止到<code>i</code>的子字符串的解，对于这个问题：</p><ol><li>没有后效性，即<em>已经求解的子问题不受后续决策的影响</em>。</li><li>存在最优子结构，即<em>原问题的最优解可以从子问题的最优解构建得来</em></li></ol><p>对于小于<code>i</code>的<code>j</code>，有<code>dp[i] = Math.min(dp[i], dp[j] + 1)</code>，即试图在<code>j+1</code>的位置进行一次划分，如果更优则更新<code>dp[i]</code>的值。</p><blockquote><p>在思考dp问题的时候，需要注意到这种通过<strong>尝试更新</strong>来求解dp值的方法，很多问题都无法直接断定地从一个子状态更新。这种尝试更新一般来说带着一次遍历的复杂度。</p></blockquote><p>这样，问题就转为了如何判断<code>j+1</code>到<code>i</code>的字符串是否为平衡字符串，若不是平衡字符串则不能更新。最直观的想法是我们维护一个哈希表，通过不断往哈希表里加入元素，并判断某个元素出现的次数是否等于其他所有元素出现的次数，满足即可，这样每次判断都要遍历一遍哈希表。</p><p>仔细观察哈希表，我们发现，只需要出现最多次数的元素乘以哈希表的长度等于<code>j+1</code>到<code>i</code>的字符串长度即可，因此可以将时间优化到常数级。</p><blockquote><p>要注意一个性质可能带来的另外其他性质。</p></blockquote><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n^2)$，其中<code>n</code>为数组<code>s</code>长度。</li><li>空间复杂度: $O(n+C)$，其中<code>n</code>是数组<code>s</code>长度，C是<code>s</code>中的字符数。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><pre><code class="Java">class Solution &#123;    static final int INF = 0x3f3f3f3f;    public int minimumSubstringsInPartition(String s) &#123;        int n = s.length();        int[] d = new int[n + 1];        Arrays.fill(d, INF);        d[0] = 0;        for (int i = 1; i &lt;= n; i++) &#123;            Map&lt;Character, Integer&gt; occCnt = new HashMap&lt;Character, Integer&gt;();            int maxCnt = 0;            for (int j = i; j &gt;= 1; j--) &#123;                occCnt.put(s.charAt(j - 1), occCnt.getOrDefault(s.charAt(j - 1), 0) + 1);                maxCnt = Math.max(maxCnt, occCnt.get(s.charAt(j - 1)));                if (maxCnt * occCnt.size() == (i - j + 1) &amp;&amp; d[j - 1] != INF) &#123;                    d[i] = Math.min(d[i], d[j - 1] + 1);                &#125;            &#125;        &#125;        return d[n];    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【二分法，双指针】3134.找出唯一性数组的中位数</title>
      <link href="/2024/08/27/%E3%80%90%E4%BA%8C%E5%88%86%E6%B3%95%EF%BC%8C%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%913134-%E6%89%BE%E5%87%BA%E5%94%AF%E4%B8%80%E6%80%A7%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2024/08/27/%E3%80%90%E4%BA%8C%E5%88%86%E6%B3%95%EF%BC%8C%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%913134-%E6%89%BE%E5%87%BA%E5%94%AF%E4%B8%80%E6%80%A7%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/find-the-median-of-the-uniqueness-array/description/">3134. 找出唯一性数组的中位数</a><br>难度分2451，这里记录对于官解的理解。</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>观察提示中数组的长度，可知这题使用$O(n^2)$复杂度的解法都会超时，而所有非空子数组共有<code>n*(n+1)/2</code>个，显然是不可行的。因此需要考虑二分法。如果二分法可行，再加上数组的单遍遍历，复杂度为$O(nlogn)$，就不会超时。</p><p>要使用二分法，首先我们需要保证二分查找的数组是<strong>有序</strong>的。</p><blockquote><p>这里的有序是广义的有序，只需要保证在某个性质上是有序的即可。</p></blockquote><p>首先，我们观察到<code>t</code>越大，唯一性数组中t出现的次数不一定越多，这个性质可以排除。</p><p>因此另找一个性质。对于以答案为下标的数组，设<code>t</code>为答案的某个值（即数组下标），对于性质<strong>数组nums中不同元素个数不大于t的非空子数组个数ct</strong>，该数组是有序的。也就是说，<code>t</code>的值越大，<code>ct</code>的值也就越大。</p><blockquote><p>这里数组的元素是累加性质的，所以一定递增，可以作为一种二分的思考选择。</p></blockquote><p>同时我们可以注意到，对于不同元素个数为<code>t</code>的<code>nums</code>数组切片<code>nums[j...i]</code>，其子数组的不同元素个数也不大于<code>t</code>。如果我们使用下标<code>i</code>遍历<code>nums</code>数组，并且每一轮都把<code>j</code>到<code>i</code>之间的取值作为左端点，<code>i</code>作为右端点的所有<code>i-j+1</code>个数组累加到<code>ct</code>中，我们最后就可以得到<code>ct</code>的值。</p><p>而<code>j</code>和<code>i</code>的值都可以通过滑动窗口来找到，用一个哈希表来存储不同元素的个数，大于t时下把<code>j</code>右移并更新哈希表，直到哈希表的元素个数不大于<code>t</code>。</p><blockquote><p>使用滑动窗口才能达成$O(n)$复杂度，对于子数组的问题非常有用。</p></blockquote><p>对于二分答案，上界为<code>n</code>，下界为<code>1</code>，我们要寻找的中位数在数组的<code>(n*(n+1)/2+1)/2</code>的位置上，只要找到不小于该数的最小<code>ct</code>值，t就是要求的答案。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(nlogn)$：二分法$logn$，滑动窗口$n$。</li><li>空间复杂度: $O(n)$：哈希表的开销。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">medianOfUniquenessArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">long</span> <span class="variable">median</span> <span class="operator">=</span> ((<span class="type">long</span>) n * (n + <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">1</span>, hi = n;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(nums, mid, median)) &#123;</span><br><span class="line">                res = mid;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测数组中不同元素数目小于等于 t 的连续子数组数目是否大于等于 median</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> t, <span class="type">long</span> median)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">tot</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            cnt.put(nums[i], cnt.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (cnt.size() &gt; t) &#123;</span><br><span class="line">                cnt.put(nums[j], cnt.get(nums[j]) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (cnt.get(nums[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt.remove(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            tot += i - j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tot &gt;= median;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>690.员工的重要性</title>
      <link href="/2024/08/26/690-%E5%91%98%E5%B7%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/"/>
      <url>/2024/08/26/690-%E5%91%98%E5%B7%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/employee-importance/description/">690. 员工的重要性</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>使用哈希表在常数时间获取<code>id</code>对应的<code>employee</code>，使用dfs搜索即可。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$，所有操作都是线性时间，HashMap查找只需要常数时间。</li><li>空间复杂度: $O(n)$，HashMap的空间复杂度。</li></ul><h1 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h1><p>TreeMap的时间复杂度要比HashMap要高。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for Employee.</span></span><br><span class="line"><span class="comment">class Employee &#123;</span></span><br><span class="line"><span class="comment">    public int id;</span></span><br><span class="line"><span class="comment">    public int importance;</span></span><br><span class="line"><span class="comment">    public List&lt;Integer&gt; subordinates;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer, Employee&gt; m = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getImportance</span><span class="params">(List&lt;Employee&gt; employees, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> employees.size();</span><br><span class="line">        <span class="keyword">for</span> (Employee e: employees) &#123;</span><br><span class="line">            m.put(e.id, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">start</span> <span class="operator">=</span> m.get(id);</span><br><span class="line">        <span class="keyword">return</span> cal(start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(Employee e)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> e.importance;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : e.subordinates) &#123;</span><br><span class="line">            ans += cal(m.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【状压dp】698.划分为k个相等的子集</title>
      <link href="/2024/08/26/%E3%80%90%E7%8A%B6%E5%8E%8Bdp%E3%80%91698-%E5%88%92%E5%88%86%E4%B8%BAk%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86/"/>
      <url>/2024/08/26/%E3%80%90%E7%8A%B6%E5%8E%8Bdp%E3%80%91698-%E5%88%92%E5%88%86%E4%B8%BAk%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/description/">698. 划分为k个相等的子集</a></p></blockquote><blockquote><p>这题没有成功做出来，这里记录对于官解的理解。</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>第一个重要的点是把题目的要求进行转换。将数组里的元素分为<code>k</code>个和相同的集合，那么对于整个数组的和<code>all</code>这<code>k</code>个集合每一个的和都为<code>all/k</code>，记为<code>per</code>。</p><blockquote><p>起初没有注意到这一点，因此想不出什么思路。</p></blockquote><p>因此，题目就转化为了我们可以逐渐选择元素，在这过程中计算当前累计和<code>curSum</code>，当累计和可以整除<code>per</code>时，证明我们成功选好了一个集合。如果加上当前元素后累计和大于<code>per</code>，证明这个选择是不成立的。</p><p>于是，我们需要枚举所有可能的组合情况，以查明数组是否可分。由于每个元素都有选择和不选择两种状态，我们可以使用<strong>状压dp</strong>来进行记忆化搜索。</p><blockquote><p>状压 DP 是动态规划的一种，通过将状态压缩为整数来达到优化转移的目的。</p></blockquote><p>状压dp的思想有点类似于哈希，同样把一种状态压缩成了一个整数，并存储在数组中。</p><p>在本题中，<code>dp[i]</code>若为<code>true</code>，则表示对于<code>i</code>这种状态，分好的集合中每个集合的内部和都小于等于<code>per</code>。若<code>dp[(i&lt;&lt;n)-1]</code>为<code>true</code>，则表示全部选好时每个集合的内部和都小于等于<code>per</code>，那么这样就分好了集合。</p><p>在状态转化时，我们对每个为<code>true</code>的<code>dp[i]</code>逐渐加上若干个元素，记为状态<code>next</code>。若<code>next</code>仍然满足定义，则把<code>dp[next]</code>的值置为true。</p><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>最重要的一步就是把题目的要求进行转化，往便于算法处理的方向靠。状压dp对于要遍历若干元素选或不选的情况时很有用。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n×2^n)$，其中 n 为数组 nums 的长度，共有 2n 个状态，每一个状态进行了 n 次尝试。</li><li>空间复杂度: $O(2^n)$，其中 n 为数组 nums 的长度，主要为状态数组的空间开销。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartitionKSubsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">all</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span> (all % k != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">per</span> <span class="operator">=</span> all / k;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums[n - <span class="number">1</span>] &gt; per) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">1</span> &lt;&lt; n];</span><br><span class="line">        <span class="type">int</span>[] curSum = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span> &lt;&lt; n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dp[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curSum[i] + nums[j] &gt; per) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (((i &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> i | (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                    <span class="keyword">if</span> (!dp[next]) &#123;</span><br><span class="line">                        curSum[next] = (curSum[i] + nums[j]) % per;</span><br><span class="line">                        dp[next] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>55.跳跃游戏</title>
      <link href="/2024/08/24/55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
      <url>/2024/08/24/55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/jump-game/description/">55. 跳跃游戏</a></p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>在遍历数组的过程中，易知可跳到的范围会随着遍历的深入越来越远，因此只需在遍历过程中维护可跳到的最远距离，看是否能遍历完整个数组即可。</p><h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><p>设<code>max</code>为从数组起点能到达的最远距离，在遍历到某一点时，若该点可及，也就是说<code>max</code>&lt;<code>i</code>，则尝试更新在加入这一点后的所能到达的最远距离<code>i + nums[i]</code>。</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li>时间复杂度: $O(n)$：最多遍历一遍数组。</li><li>空间复杂度: $O(1)$：若干常量。</li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            max = Math.max(max, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>121 &amp;&amp; 122. 买卖股票的最佳时机</title>
      <link href="/2024/08/23/121%20&amp;&amp;%20122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
      <url>/2024/08/23/121%20&amp;&amp;%20122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="第一题："><a href="#第一题：" class="headerlink" title="第一题："></a>第一题：</h1><blockquote><p>Problem: <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121. 买卖股票的最佳时机</a></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求只能在某一天买入股票，在另一天卖出，把股票的价格看成一个<strong>高度图</strong>，只要求出只能从前向后走的情况下最大下降量即可。</p><p>因此，在第一题中，我们从后向前遍历数组，保存到目前为止<strong>价格的最小值</strong>和<strong>结果的预估值</strong>。然后尝试在当前位置购入股票，并更新价格最小值。从前向后做的话方法类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curMax</span> <span class="operator">=</span> prices[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ans = Math.max(ans, curMax - prices[i]);</span><br><span class="line">            curMax = Math.max(prices[i], curMax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>起初使用过动态规划的思想来做，多开了一个最小值数组。后面发现<code>dp[i]</code>只和<code>dp[i + 1]</code>有关，注意到这个数组是不必要的。</p><h1 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h1><blockquote><p>Problem: <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122. 买卖股票的最佳时机 II</a></p></blockquote><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>本题和上一题的区别是可以选择多次购入卖出股票。和上一题一样，思考一个下山的过程，只要下山就可以获得奖励，上山也<strong>没有</strong>惩罚。</p><p>因此使用贪心的思想，对于某一天的股票，只要价格比上一天低就可以售出，用反证法就可以证明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                ans += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用LLM和doccano进行关系抽取和验证</title>
      <link href="/2023/11/29/RE/"/>
      <url>/2023/11/29/RE/</url>
      
        <content type="html"><![CDATA[<h1 id="关系抽取"><a href="#关系抽取" class="headerlink" title="关系抽取"></a><strong>关系抽取</strong></h1><p>在企业项目中，需要对制冷这一冷门领域的操作指南和说明文档进行关系抽取。为此笔者尝试了许多传统方法的模型，但效果都欠佳。受到当下在NLP（Natural Language Processing，自然语言处理）中流行且功能强大的LLM（Large Language Model，大语言模型）的启发，笔者尝试了使用本地和API的大模型进行关系抽取，取得了相对于传统方法较好的效果。</p><h2 id="使用传统深度学习方法的关系抽取的不足"><a href="#使用传统深度学习方法的关系抽取的不足" class="headerlink" title="使用传统深度学习方法的关系抽取的不足"></a><strong>使用传统深度学习方法的关系抽取的不足</strong></h2><p>起初，笔者尝试了使用传统深度学习方法进行关系抽取。基本思路是使用IDCNN&#x2F;biLSTM和CRF进行实体检测，然后使用biGRU和attention机制进行特征提取。但是传统深度学习方法有两个基本的问题：</p><ul><li>在冷门领域不具备zero-shot能力。训练这些模型的训练集（如DUIE）相对于LLM来说还是太少，而且预训练数据显然没有覆盖到制冷领域相关的知识。于是这些模型在制冷领域中都不能够提取出关系。</li><li>可用的训练数据较少。制冷领域可用的有标签训练数据太少，不足以训练出可用的模型。</li></ul><p>笔者测试了<a href="https://github.com/PaddlePaddle/PaddleNLP/tree/develop/examples/information_extraction/DuIE">DuIE</a>，<a href="https://www.modelscope.cn/models/damo/nlp_structbert_siamese-uninlu_chinese-base/summary">SiameseUniNLU</a>等主流模型，都无法在企业项目的文档中提取出任何的关系。</p><h2 id="使用-LLM进行关系抽取"><a href="#使用-LLM进行关系抽取" class="headerlink" title="使用 LLM进行关系抽取"></a><strong>使用 LLM进行关系抽取</strong></h2><p>当下，大语言模型得到了越来越多的使用，同时开源大语言模型的效果也在逐步提高。论文<a href="https://arxiv.org/pdf/2302.10205.pdf">Zero-Shot Information Extraction via Chatting with ChatGPT</a> 中的研究表明：在两个语言的6个数据集上的实验结果表明，使用ChatGPT等LLM的关系抽取取得了非常好的效果，甚至在几个数据集上（例如NYT11-HRL）上超过了全监督模型的表现。出于这篇论文的启发，笔者使用LLM进行关系抽取。</p><h3 id="LLM模型大小的影响"><a href="#LLM模型大小的影响" class="headerlink" title="LLM模型大小的影响"></a><strong>LLM模型大小的影响</strong></h3><p>首先，笔者在文心一言的网页对话上进行了初步尝试，发现了这个思路是可行的。</p><p><img src="/./2023/11/29/RE/AsposeWords2f6cad52-b522-451f-bc0b-541f2ef53fa0001.png"><img src="/./2023/11/29/RE/AsposeWords2f6cad52-b522-451f-bc0b-541f2ef53fa0002.png"></p><p>但是，商用大模型由于参数量更大、使用的计算资源更多、训练数据也更大，本地的开源大模型效果肯定比不上商用API。因此笔者在本地部署了一些主流的开源大模型，以测试是否可行。</p><p>笔者在ChatGLM3-6B-Chat，Baichuan2-13B-Chat和Baichuan2-13B-Chat-4bits量化版上都进行了实验，发现模型参数量的大小会显著地影响得出的效果。在企业项目的文档中，对于笔者准备好的相同的prompt，ChatGLM3-6B-Chat的关系抽取效果一般，难以提取出完整实体。Baichuan2-13B-Chat-4bits量化版本表现则更优，已经可以提取出较为准确的实体和关系，精度更高的Baichuan2-13B-Chat模型效果也符合预期地达到了更佳的表现。同时，商用大模型文心一言网页版得到了最理想的效果。通过实验可以发现，基本上关系抽取的效果是与LLM本身的能力（通常和参数大小正相关）是成正相关的。</p><p><img src="/./2023/11/29/RE/AsposeWords2f6cad52-b522-451f-bc0b-541f2ef53fa0003.png"><img src="/./2023/11/29/RE/AsposeWords2f6cad52-b522-451f-bc0b-541f2ef53fa0004.png"></p><p><img src="/./2023/11/29/RE/AsposeWords2f6cad52-b522-451f-bc0b-541f2ef53fa0005.png"><img src="/./2023/11/29/RE/AsposeWords2f6cad52-b522-451f-bc0b-541f2ef53fa0006.png"></p><p><img src="/./2023/11/29/RE/AsposeWords2f6cad52-b522-451f-bc0b-541f2ef53fa0007.png"><img src="/./2023/11/29/RE/AsposeWords2f6cad52-b522-451f-bc0b-541f2ef53fa0008.png"></p><h3 id="Prompt编写"><a href="#Prompt编写" class="headerlink" title="Prompt编写"></a><strong>Prompt编写</strong></h3><p>参考了论文<a href="https://arxiv.org/pdf/2302.10205.pdf">Zero-Shot Information Extraction via Chatting with ChatGPT</a>中prompt的编写方式，以及在Baichuan2上的实验，最终对于无schema的关系提取，笔者得出这个模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假设你是一个实体关系抽取模型，你需要抽取出接下来用三重反引号限定的句子中成对的关系实体。该句子来源于&#123;context&#125;中。抽取出的每个关系需要完全符合&#123;&#123;<span class="string">&quot;subject&quot;</span>:主体, <span class="string">&quot;subject_type&quot;</span>:<span class="string">&quot;主体类型&quot;</span>, <span class="string">&quot;relation&quot;</span>:<span class="string">&quot;联系&quot;</span>, <span class="string">&quot;object&quot;</span>:<span class="string">&quot;客体&quot;</span>, <span class="string">&quot;object_type&quot;</span>:<span class="string">&quot;客体类型&quot;</span>&#125;&#125;的JSON格式，主体类型、联系和客体类型的值都必须是中文，主体和客体必须完整摘自句子中，主体和客体越长、越完整越好。最后只输出符合JSON格式的结果。</span><br><span class="line">```&#123;line&#125;```</span><br></pre></td></tr></table></figure><p>这里对该prompt进行说明：</p><p>Prompt中的{context}可以是文档名字，或者这个文档的主体内容。经过实验，笔者发现给定文档名称可以让LLM更好地理解文档中的句子。</p><p>接下来笔者指定了LLM输出JSON格式的结果。通过指定找出的关系所需的格式，LLM可以给出一个较为标准的回答，便于后续的处理。而且经过实验笔者发现，在有了给定的回答格式之后，LLM的关系抽取表现也会变好。</p><p>同时笔者在实验过程中发现，LLM在遇到文档中的英文部分时，回答可能会以英文形式给出，因此笔者在prompt中限定了输出需要是中文。需要注意的是，较小的模型即使给定了这个限定，也可能不会得到像预期一样的输出。</p><p>笔者在这里加上主体和客体必须完整摘自句子中的指令，这是因为笔者之后需要把输出内容上传到doccano标注工具上，笔者需要保证实体和客体出自原句，以便找出其在原句中的位置。</p><p>Prompt中还强调了主体和客体越长、越完整越好，这个是可选的选项，经过实验笔者发现，如果加上这句话，LLM会从一个更大局的角度来找出句子中的关系，这更符合企业项目中说明文档关系提取的需求。如果去掉这句话，找出来的关系会偏向于局部的关系。需要注意的是，对于Baichuan2-13B这类较小的LLM，由于模型理解能力有限，它可能还是无法提取出符合句子中心思想的关系。但是文心一言等商用大模型就可以做到。</p><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a><strong>数据处理</strong></h3><p>由于LLM可以直接以自然语言作为输入，数据预处理工作稍微简化了一些。笔者需要考虑的问题是，对于较长的输入文本，是应该以<strong>段落</strong>还是<strong>句子</strong>为标准作为关系抽取的输入。以段落为标准进行关系抽取可以让LLM更全面地了解一个句子的意思，而且可以降低LLM的指示prompt和输入prompt的比值，提高推理效率。但是，这种方法需要占用较大的显存，一些机器可能不能满足这样高的显存要求。另外，如果是要提取文本段的核心关系，考虑是以段落还是以句子为标准，可以从不同粒度提取想要的结果。经过测试，两种标准都能有较好的关系抽取效果。因此，在机器显存足够的情况下，使用段落作为标准进行关系抽取效果更好。</p><p>读取文档后，再去除空行，以避免计算资源的浪费。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data_file = <span class="built_in">open</span>(<span class="string">&quot;./2023/11/29/RE/data/data_0.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">data = data_file.readlines()</span><br><span class="line">data = [line <span class="keyword">for</span> line <span class="keyword">in</span> data <span class="keyword">if</span> line != <span class="string">&quot;\n&quot;</span>]</span><br></pre></td></tr></table></figure><p>笔者让LLM输出符合JSON格式的结果，以便下游任务使用。</p><p>但是对于LLM，尤其是本地部署的参数较小的LLM，即使在prompt中明确给出了任务要求的输出格式，仍然会出现输出不符合要求的情况，如果不进行处理会对下游工作造成一定的麻烦。</p><p>经过实验，笔者发现LLM可能会出现以下形式的非法输出：在开始或结尾输出类似“好的，接下来我将进行关系抽取任务”的冗余信息；在最后一个JSON对象后加上逗号；输出的[]号不匹配；输出的JSON对象之间没有逗号；输出不符合要求的键值对；由于提取不出关系，输出的内容中不包含JSON。</p><p>起初笔者尝试了使用python的字符串删减，替换方式来处理，但是通过实验发现，对于LLM输出的不稳定结果，这种操作方法的鲁棒性太差。后来笔者发现，既然笔者的核心目标是LLM输出的JSON语句，那么笔者实际上可以直接提取符合JSON格式的语句段。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">relations = re.findall(<span class="string">r&#x27;(&#123;\s*?\n\s*?&quot;subject&quot;:.*?,\s*?&quot;subject_type&quot;:.*?,\s*?&quot;relation&quot;:.*?,\s*?&quot;object&quot;:.*?,\s*?&quot;object_type&quot;:.*?\s*?&#125;)&#x27;</span>, response)</span><br></pre></td></tr></table></figure><p>这个正则表达式会匹配（几乎）符合要求的JSON对象，由于输出的内容中可能不包含JSON，需要再加上控制判断。</p><p>然后用replace来解决最后一个JSON对象后加上逗号的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = re.sub(<span class="string">r&quot;,\s*?\n?\s*?&#125;&quot;</span>, <span class="string">&quot;\n&#125;&quot;</span>, response)</span><br></pre></td></tr></table></figure><p>找到符合条件的JSON对象后，只需要再用python的字符串方法把它们拼接起来，最终就可以形成一个可用的JSON。</p><h3 id="基于schema和无schema的关系抽取"><a href="#基于schema和无schema的关系抽取" class="headerlink" title="基于schema和无schema的关系抽取"></a><strong>基于schema和无schema的关系抽取</strong></h3><p>在关系抽取任务中，schema，也就是诸如(人名-编写-小说)这样的关系模式，可以用来限制和指导关系抽取模型抽取关系。而LLM相对于传统深度学习的关系抽取模型来说，还拥有无schema进行关系抽取的能力；也就是说，LLM会自动地根据任务需要和上下文提取出合适地关系，而不限定是什么模式。基于schema进行关系抽取可以让LLM抽取出笔者想要的特定模式，适合笔者有明确的抽取目标的场景；而无schema的关系抽取可以节省相关人员的工作量，也可以更好地发挥大模型的理解能力，缺点是抽取出的关系和实体标签可能比较繁杂。</p><p>通过实验笔者发现，对于企业项目中说明文档性质的内容，在使用Baichuan2-13B模型的情况下，如果使用基于schema的关系抽取，LLM回答的内容的置信度会下降很多，经常出现强行匹配schema的情况，而且即使是符合schema的关系，效果也只是一般。而如果不使用schema则不会有这种情况发生，因此笔者默认使用无schema的模式，如果要使用基于schema的模式，可以参考<a href="https://github.com/cocacola-lab/ChatIE">ChatIE</a>中的Prompt。</p><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a><strong>其他问题</strong></h3><p>如果使用Baichuan2-13B等本地开源模型，且机器性能一般，只能勉强运行的话，对于较长的句子，LLM可能会卡死，即使过了十几二十分钟也不会输出结果。因此，笔者使用了timeout_decorator库来为推理设置超时时间（只在Linux平台上有效）。同时在JSON文件记录了输出对应于原始文本的位置index。</p><p>因为长文本处理随时都有可能因为各种异常原因暂停，笔者把程序断开时所在的index记录为check_point，以使得程序在断开后能从断开的句子处继续写入。</p><p>由于大模型输出结果的不稳定性，最后的文档可能还不是标准的JSON格式，需要再进行JSON校验。</p><h1 id="doccano标注"><a href="#doccano标注" class="headerlink" title="doccano标注"></a><strong>doccano标注</strong></h1><p>由于不管是传统深度学习模型还是大语言模型，都无法完美地提取出期望的结果，笔者使用了开源的文档标注工具<a href="https://github.com/doccano/doccano">doccano</a>，以实现人在回路进行关系的校验和增删。由于要将LLM的不稳定输出提交到需要稳定输入的doccano标注工具上，笔者编写相关转换和处理的Python代码。</p><h2 id="doccano客户端"><a href="#doccano客户端" class="headerlink" title="doccano客户端"></a><strong>doccano客户端</strong></h2><p>连接doccano需要token鉴权，因此首先需要知道doccano部署的ip和端口，以及username和password。笔者使用下面的代码来进行客户端的初始化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, entrypoint, password</span>):</span><br><span class="line">    <span class="variable language_">self</span>.entrypoint = entrypoint</span><br><span class="line">    <span class="variable language_">self</span>.client = requests.Session()</span><br><span class="line">    <span class="variable language_">self</span>.client.auth = (username, password)</span><br><span class="line">    token = <span class="variable language_">self</span>.client.request(<span class="string">&quot;POST&quot;</span>,<span class="string">f&#x27;<span class="subst">&#123;self.entrypoint&#125;</span>/v1/auth/login/&#x27;</span>, json=&#123;<span class="string">&#x27;username&#x27;</span>: username, <span class="string">&#x27;password&#x27;</span>: password&#125;).cookies[<span class="string">&#x27;csrftoken&#x27;</span>]</span><br><span class="line">    <span class="variable language_">self</span>.client.headers.update(&#123;<span class="string">&#x27;X-CSRFToken&#x27;</span>: token&#125;)</span><br></pre></td></tr></table></figure><p>Client类中定义的其他方法用于对doccano客户端的增删改查操作。</p><p>在Doccano中，一个项目（project）是拥有共同标签集的文本集的概念，一个文档（document）是一个用于标注的文本。标签（labels）包括实体标签和联系标签，实体标签和关系标签分别用span-type和relation-type表示。一个标注实体用（span）表示，记录相关实体的起始和结束偏移量，以及实体标签；一个标注关系用（relation）表示，记录头实体，尾实体和关系标签。</p><h2 id="数据处理-1"><a href="#数据处理-1" class="headerlink" title="数据处理"></a><strong>数据处理</strong></h2><p>首先，笔者需要对<a href="#_%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86">数据处理</a>中得到的JSON格式输出进行人工确认，确保符合JSON格式，一般只需要修改几处异常即可（其中，重复的键值对无需处理，Python的json库自动取最后一个值）。</p><p>笔者还需要读取原始文本，然后指定文章的划分方法，这里一般是换行符或者句号。</p><p>接下来是读取JSON格式的输出文本，然后需要删除不符合条件的关系。笔者删除掉缺少由prompt指定的必要的JSON关键字的响应，因为这通常隐含了这个提取效果不够好，才会缺少某一个关键字。同样的，当键值对的值不为字符串、键值对的值为空时，笔者也删除掉这个关系。笔者不关注多余的键值对（例如，LLM会提取出“evidence”，“object_part”这样不符合要求的键），因为笔者直接忽视这部分即可（也提供了像上述一样删除的选项）。</p><h2 id="上传标签"><a href="#上传标签" class="headerlink" title="上传标签"></a><strong>上传标签</strong></h2><p>如果之前没有上传过标签，笔者就把JSON输出的所有实体类型、关系、联系类型都上传到doccano服务器上。Doccano会自动屏蔽掉重复的标签，所以无需额外处理。如果要删除标签，可以调用client的响应函数。</p><h2 id="获取标签id"><a href="#获取标签id" class="headerlink" title="获取标签id"></a><strong>获取标签id</strong></h2><p>在doccano中，笔者是通过标签的id来操作标签的，而不是用标签的名称。而id又是doccano指定的，所以笔者需要事先从doccano获得标签，并把标签和对应文本的键值对保存到内存里，以便后续上传实体和关系时使用。</p><h2 id="上传实体和关系"><a href="#上传实体和关系" class="headerlink" title="上传实体和关系"></a><strong>上传实体和关系</strong></h2><h3 id="实体位置的计算"><a href="#实体位置的计算" class="headerlink" title="实体位置的计算"></a><strong>实体位置的计算</strong></h3><p>上传实体时最主要的问题就是实体位置的计算。因为doccano记录实体在文章中的位置，以便于进行检验和修改，所以笔者需要上传正确的实体位置。</p><p>这一部分工作（还有之前相当一部分的工作）笔者没有交给LLM来做，因为这类有确切结果，且容易编写算法求解的工作，编写对应的Python脚本来解决，可以既保证结果的准确性又减少算力的浪费。</p><p>笔者使用一个变量global_offset来记录实体在文章中的实际偏移量。对于LLM输出的JSON文档中对于每一个文本段给出的所有回复，笔者都尝试找出这个回复中的实体和客体第一次出现在这个文本段的位置（因为同样名称的实体在一个文本段中几乎可以肯定是相同含义的），如果找不到这个实体（通常是因为LLM的模型较小，而忽视了笔者的要求），笔者通过匹配前若干个相同的字符来找到文本段的位置（同样是因为文本段较小，几乎不会找错专有实体）。如果确实找不到这个实体（几乎不会出现），笔者也就只能跳过这个句子。最终，这个实体的实际起始偏移量和实际结束偏移量结合global_offset和实体的长度就都可以计算出来了</p><p>在每个句子处理完后，笔者把global_offset加上这个句子的长度。需要注意的一个细节是，由于LLM可能对于某些文段没有输出，笔者需要把跳过对应的句子的长度也都加起来。</p><h3 id="重复实体的处理"><a href="#重复实体的处理" class="headerlink" title="重复实体的处理"></a><strong>重复实体的处理</strong></h3><p>对于每个句子，一个实体可能会在多个关系中出现，而doccano不会对重复的实体进行过滤（这是因为一个实体可能有多个类型，但是实际上doccano对于相同的类型也不会过滤），因此笔者需要判断是否已经上传过了这个实体，否则标注的结果会很混乱。这里判断相同的依据是：起始偏移量、结束偏移量和标签都相同。</p><p>这样做还有一个额外的好处。当程序因为各种原因断开时，笔者可以简单地从头执行这个程序，因为重复的实体不会被重复上传。</p><h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a><strong>上传</strong></h3><p>所有的上述工作做完后，笔者就可以上传实体和关系了。上传实体时只需要上传初始、结束偏移量和实体标签id，上传关系时只需要上传头尾实体id和标签id。对于重复的关系，doccano会自动过滤掉。</p><p><img src="/./2023/11/29/RE/AsposeWords2f6cad52-b522-451f-bc0b-541f2ef53fa0009.png"><img src="/./2023/11/29/RE/AsposeWords2f6cad52-b522-451f-bc0b-541f2ef53fa0010.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
            <tag> LLM </tag>
            
            <tag> doccano </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Multimodal Machine Learning: A Survey and Taxonomy</title>
      <link href="/2023/10/15/Multimodal-Machine-Learning-A-Survey-and-Taxonomy/"/>
      <url>/2023/10/15/Multimodal-Machine-Learning-A-Survey-and-Taxonomy/</url>
      
        <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><p>一般来说，模态就是指，一种事情发生或者被经历的方法。</p><p>当一个研究的问题或者说数据集包含了多个模态时，就是多模态问题或者多模态数据集。</p><p>多模态数据主要有：自然语言；视觉信号；音频信号等。<br>我认为多模态主要包括这些，是因为这些信息是日常生活红数据量最丰富、最有价值和最容易获取的信息，在当下最具有研究价值；而一些其他的信息，像是红外、超声、嗅觉、触觉、加速度信号等，可能只会在机器人等限定的领域有用处，相对来说应用范围没有那么广泛，信号的局限性较大。</p><p>多模态的五大挑战：表示，转换，对齐，融合，协同学习<br>这几大方面的挑战是：<br>表示：怎样表示、总结不同模态的信息。不同模态的数据经常是异质的，比如语言是符号性的，音频和视频是用信号表示的。<br>转换：不同模态之间的联系可能是开放的，比如一个图片可以有多种语言解释。<br>对齐：把不同的模态直接联系起来，比如把做菜的步骤关联到对应的视频。<br>融合：把不同模态的数据综合起来做预测。<br>协同学习：把一种模态的学习模型迁移到另一个模态的模型中</p><p>我认为这几个问题中，表示主要是数据处理层面的，涉及到模型如何设计、数据怎样表示；翻译和对齐可以是模型的一部分能力，也可以是这个多模态模型的功能；融合主要是涉及到模型的输出部分；而协同学习则是和迁移学习相似，主要是对模型开发人员有用。我认为这几个问题中最有挑战性的可能是协同学习，因为不同模态之间的模型差异实在太大，感觉这样的机制很难实现。</p><h1 id="2-多模态的应用："><a href="#2-多模态的应用：" class="headerlink" title="2 多模态的应用："></a>2 多模态的应用：</h1><p>1.视听结合的言语识别，图像注解等 V-A<br>多模态可以增强模型的鲁棒性<br>2.多媒体内容的索引和检索 V-A<br>3.人类社交时的多模态行为的理解 V-A<br>4.媒体解释 V-L<br>5.事件检测 V-L<br>6.多媒体生成 V-L</p><p>跨模态检索会用到除了融合以外的所有技术</p><h1 id="3-表示"><a href="#3-表示" class="headerlink" title="3 表示"></a>3 表示</h1><p>把多模态的数据用计算模型可以识别的格式表示出来，可以是向量&#x2F;张量表示。<br>困难  </p><ol><li>结合异质数据  </li><li>处理不同的噪音  </li><li>处理丢失的数据<br>现在很多的多模态数据的表示都是单模态数据的简单拼接。</li></ol><p>好的表示的特点：平滑、保留时空顺序、稀疏、自然聚类</p><h3 id="联合表示："><a href="#联合表示：" class="headerlink" title="联合表示："></a>联合表示：</h3><p>联合表示把多个单模态数据结合到相同的表示空间 。<br>通常用在多模态数据要结合起来使用的时候<br>AVSR，情感分析，多模态手势识别等</p><p>神经网络<br>通常把最后一层或者倒数第二层拿来用<br>1.先分别用独立层训练，然后通过一个隐藏层来把这些模态投影到一个联合的空间中<br>2.对于没有标签的数据，可以用自编码器<br>基于联合表示的神经网络的一大好处是：<br>可以学习无标签数据，而且可以微调来适应特殊的任务</p><p>概率图模型<br>使用DBM等<br>优点：泛化性好，可以更好地处理缺失模态的数据<br>缺点：难以训练，计算代价高</p><p>序列表示<br>使用RNN</p><h3 id="协同表示："><a href="#协同表示：" class="headerlink" title="协同表示："></a>协同表示：</h3><p>协同表示分别处理单模态信号，同时保留有相似的约束。<br>通常用在一次只使用一种模态数据的时候<br>比如多模态检索、翻译、结合、零次学习</p><p>相似模型：<br>最小化不同模态间在坐标空间的距离<br>可以使用神经网络，可以端到端学习协同表示(RNN\LSTM等)</p><p>结构化坐标空间：<br>添加了额外的限制<br>主要形式有跨模态哈希、图像和语言的顺序嵌入、典型关联分析：<br>把高纬度数据压缩到低纬度，相似的对象有相似的码<br>可以使用神经网络</p><h1 id="4-翻译"><a href="#4-翻译" class="headerlink" title="4.翻译"></a>4.翻译</h1><p>给出一个模态的实体，生成在另一个模态的相同的实体<br>例子：语音合成，视觉语音生成，视频描述，跨模态检索<br>两种类型：基于样例的，生成式的</p><h2 id="4-1-基于样例的：使用字典"><a href="#4-1-基于样例的：使用字典" class="headerlink" title="4.1 基于样例的：使用字典"></a>4.1 基于样例的：使用字典</h2><p>使用两类算法：基于检索的，基于结合的<br>基于检索的：直接使用检索，可用单模态空间或者跨媒体语义空间，后者更好，可以双向翻译<br>基于结合的：使用更复杂的规则，把多个结果结合起来生成一个更好的翻译<br>缺点：模型大、查询慢、字典要求大、不一定有对应结果</p><h2 id="4-2-生成式的：生成模型"><a href="#4-2-生成式的：生成模型" class="headerlink" title="4.2 生成式的：生成模型"></a>4.2 生成式的：生成模型</h2><p>类型：基于语法的，编码解码器（最常用），持续生成模型</p><p>基于语法的：用语法限制目标域<br>优势：更可能生成语法和逻辑正确的结果<br>局限：智能产生公式化的结果，难以创新；训练过程要分段、复杂</p><p>编码解码器：先编码到一个隐表示，然后再用解码器解码<br>使用端到端的神经网络，编码通常和模态本身有关，解码通常用RNN和LSTM。缺点是需要大量数据，而且神经网络可能是再记忆训练数据</p><p>持续生成模型：基于源模态数据流持续生成目标模态，最适合时序序列，例如文字转语音</p><h2 id="4-3-模型评估"><a href="#4-3-模型评估" class="headerlink" title="4.3 模型评估"></a>4.3 模型评估</h2><p>一种评估方法是人工判断：<br>语音合成：自然度，平均观点分数<br>VSS：真实度<br>媒体描述：语法语义正确，相关度，顺序，细节<br>自动评估效果一般</p><p>也可以用检索来作为描述的评估方法</p><h1 id="5-对齐"><a href="#5-对齐" class="headerlink" title="5 对齐"></a>5 对齐</h1><p>找到不同模态之间的子模块实体之间的联系和对应关系<br>两种对齐：显式和隐式</p><h2 id="5-1-显式对齐"><a href="#5-1-显式对齐" class="headerlink" title="5.1 显式对齐"></a>5.1 显式对齐</h2><p>最重要的方式是用相似矩阵来评价</p><p>无监督：不需要对齐的标签<br>假设对齐有限制，例如时间顺序，或者相似矩阵存在<br>DTW用于对齐多视角时间序列，CCA。可以同时学习相似矩阵和对齐<br>图模型，需要专家知识。</p><p>有监督：需要有标签的对齐实例<br>方法和无监督的比较像</p><p>深度学习也在显式对齐里面很好用，LSTM，CNN</p><h2 id="5-2-隐式对齐"><a href="#5-2-隐式对齐" class="headerlink" title="5.2 隐式对齐"></a>5.2 隐式对齐</h2><p>是其他任务中间的步骤，通常是隐式的<br>不依赖于有监督的样本</p><p>图模型：需要人工设定对齐方式，比较不常用</p><p>神经网络：最常用的方法，尤其是在翻译的中间步骤，可以给翻译带来很大的提升，加入注意力机制效果更好</p><h2 id="5-3-难点"><a href="#5-3-难点" class="headerlink" title="5.3 难点"></a>5.3 难点</h2><p>标签数据少，相似矩阵难设计，对齐关系可能是多对多，或者不存在</p><h1 id="6-融合"><a href="#6-融合" class="headerlink" title="6 融合"></a>6 融合</h1><p>集成多个模态的信息来做预测，一般认为是在预测的后部阶段</p><ol><li>更健壮的预测结果</li><li>可以捕捉到补充的信息</li><li>缺失一个维度的信息时仍可以起作用</li></ol><h2 id="6-1-模型无关的方法"><a href="#6-1-模型无关的方法" class="headerlink" title="6.1 模型无关的方法"></a>6.1 模型无关的方法</h2><p>可以分为早期，晚期和杂交融合<br>比较简单，但是不能充分利用多模态的特点</p><h2 id="6-2-基于模型的方法"><a href="#6-2-基于模型的方法" class="headerlink" title="6.2 基于模型的方法"></a>6.2 基于模型的方法</h2><p>基于核的方法：<br>不同的模态使用不同的核，核可以看成数据点的相似函数<br>优点是损失函数是凸的，好优化；<br>缺点是测试时也要用训练数据，查询慢，内存消耗大</p><p>图模型：<br>生成式的：建模联合概率<br>判别式的：建模条件概率<br>优点：容易利用数据的时间和空间结构，所以在AVSR和情感检测常用；可以加入专家知识</p><p>神经网络：最常用<br>优势：可以从大量的数据中学习；端到端训练；效果好<br>缺点：可解释性差，需要大量数据</p><p>融合的困难：<br>数据可能没有在时间上对齐<br>难以捕捉互补的信息<br>每个模态都可能会有噪音</p><h1 id="7-共同学习"><a href="#7-共同学习" class="headerlink" title="7 共同学习"></a>7 共同学习</h1><p>用另一个模态的模型知识来辅助一个模态的模型学习<br>这是与任务无关的，因此可以在多模态融合、翻译、对齐模型中使用</p><h2 id="7-1-平行数据"><a href="#7-1-平行数据" class="headerlink" title="7.1 平行数据"></a>7.1 平行数据</h2><p>不同模态使用一个数据集，对应关系已经确定<br>共同训练：创建更多有标签数据<br>迁移学习：可以多模态表示，单模态的时候也更好</p><h2 id="7-2-不平行数据"><a href="#7-2-不平行数据" class="headerlink" title="7.2 不平行数据"></a>7.2 不平行数据</h2><p>不需要有共享的实例，只需要有共享的概念或类别<br>迁移学习<br>概念建构：通过不仅仅是语言，也包含其他模态的数据来学习语义<br>零次学习：不需要之前见过任何相关的有标签的数据，就识别出一个概念<br>单模态：通过部分特征来推出实体<br>多模态：使用另一个模态来推出没有认识的模态</p><h2 id="7-3-混合数据"><a href="#7-3-混合数据" class="headerlink" title="7.3 混合数据"></a>7.3 混合数据</h2><p>两个模态用一个共享的模态或者数据集来桥接</p>]]></content>
      
      
      
        <tags>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
